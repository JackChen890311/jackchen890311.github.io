<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>My Interview Experience with PicCollage</title>
      <link href="/2025/11/01/interview-with-piccollage/"/>
      <url>/2025/11/01/interview-with-piccollage/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次說到我<a href="https://jackchen890311.github.io/2025/07/01/fulltime-2025/">找正職的故事</a>，但其實還有後續。過了幾個月之後，不安分的我又去面試了 <a href="https://piccollage.com/">PicCollage</a> 這間公司。這間也跟玩美移動類似，是做圖片相關的 App，我之前丟過好幾次他們的實習，但都是沒下文或直接感謝信。</p><p>起因是三月多去逛就業博覽會的時候，剛好遇到認識的朋友在裡面工作，就跟他聊了一下，畢竟我一直對這間公司很感興趣，雖然後來覺得有點懶所以沒丟。但過了一陣子之後又覺得很心動，不挑戰一下有點可惜，就去麻煩我朋友內推。又隔了一陣子他看到訊息之後，到五月初總算成功推到了，雖然時程上算是小晚，但想說我沒啥損失就還是面面看。</p><h2 id="面試過程"><a href="#面試過程" class="headerlink" title="面試過程"></a>面試過程</h2><p>應徵職位：Machine Learning Engineer<br>部門介紹：<a href="https://piccollage-company.medium.com/%E6%B7%B1%E5%85%A5%E7%9E%AD%E8%A7%A3-piccollage-%E4%B8%80%E6%8E%A2-piccollage-mlad-%E5%9C%98%E9%9A%8A-1d3ceff7e35b">PicCollage MLAD - Medium</a></p><p>時程：</p><ul><li>5&#x2F;2 朋友幫忙內推完成</li><li>5&#x2F;7 主管詢問畢業時間</li><li>5&#x2F;20 收到一面邀請</li><li>5&#x2F;27 ML Head + HR 線上一面</li><li>6&#x2F;5 Engineer 線上二面</li><li>6&#x2F;17 Engineer 線上三面</li><li>6&#x2F;26 Engineer Director 線上四面</li><li>7&#x2F;2 Onsite Interview 實體五面</li><li>7&#x2F;8 Offer Get (Oral)</li><li>7&#x2F;9 線上 Offer Call</li><li>7&#x2F;10 主動再約線上 Offer Call</li><li>7&#x2F;24 Follow-up Offer Call</li><li>7&#x2F;28 Offer Accepted</li></ul><h3 id="ML-Head-HR-線上一面"><a href="#ML-Head-HR-線上一面" class="headerlink" title="ML Head + HR 線上一面"></a>ML Head + HR 線上一面</h3><p>原本等兩週了還是沒下文，正打算放棄並且總算填了替代役，結果一面邀請就來了！</p><h4 id="Take-home-Work"><a href="#Take-home-Work" class="headerlink" title="Take-home Work"></a>Take-home Work</h4><p>Explain attention to people with different background knowledge</p><!-- How would you explain the idea of attention in transformers to:- Someone with a knowledge of ML but no knowledge of transformers- Someone with a strong math background but no knowledge of ML --><h4 id="面試流程-30-mins-："><a href="#面試流程-30-mins-：" class="headerlink" title="面試流程 (30 mins)："></a>面試流程 (30 mins)：</h4><ul><li>Follow-up on homework: 5-10 mins</li></ul><!-- (Attention: shape of input / Q K V /output) --><ul><li>Resume: 5-10 mins (Education &#x2F; Master’s Thesis)</li><li>Behavioral Questions: 5-10 mins</li></ul><!-- (Past Work Achievements / Difficulties / What do you want to build) --><ul><li>Q &amp; A</li></ul><h3 id="Engineer-線上二面"><a href="#Engineer-線上二面" class="headerlink" title="Engineer 線上二面"></a>Engineer 線上二面</h3><p>這次的面試體驗數一數二的好，工程師人很好，會引導我寫題目，忘記的細節也可以向他提問；並且題目難度適中，順順的就可以在時間內解完。加上最後 Q &amp; A 聽他描述工作內容、工作風氣等等，又讓我更想去了一點！</p><h4 id="Take-home-Work-1"><a href="#Take-home-Work-1" class="headerlink" title="Take-home Work"></a>Take-home Work</h4><p>Use numpy to speed up a simulation process</p><!-- https://en.wikipedia.org/wiki/Logistic_map --><h4 id="面試流程-45-mins"><a href="#面試流程-45-mins" class="headerlink" title="面試流程 (45 mins)"></a>面試流程 (45 mins)</h4><ul><li>Follow-up on homework: &lt;5 mins </li><li>Coding (CV): 35 mins</li><li>Q &amp; A</li></ul><!-- - Find mask where R + G > B- Rotation of 2d points- Broadcasting: Pairwise l2 loss --><h3 id="Engineer-線上三面"><a href="#Engineer-線上三面" class="headerlink" title="Engineer 線上三面"></a>Engineer 線上三面</h3><p>面完前面兩輪後，我被 HR 加入他們的 Slack Channel，第三階段的面試與討論都在裡面進行。原本想說是不是用來討論作法的，但問了 HR 他說「可以確認題目」，想了想還是不討論作法相關的問題。</p><h4 id="Take-home-Quiz"><a href="#Take-home-Quiz" class="headerlink" title="Take-home Quiz"></a>Take-home Quiz</h4><p>Train a small model that follows a given distribution (colored image, specific pattern)<br>Can choose from various models like VAE, GAN, AR, Diffusion…  </p><!-- Data: One 300 x 300 photo of a colored "Pi" notation, given in [x, y, r, g, b] --><p>Focus:</p><ul><li>Problem Formulation, Solution Correctness, and their Explanation</li><li>Code Organization</li><li>Evaluation Method</li></ul><h4 id="面試流程-45-mins-1"><a href="#面試流程-45-mins-1" class="headerlink" title="面試流程 (45 mins)"></a>面試流程 (45 mins)</h4><ul><li>Follow-up on quiz: Until finished (~30 mins)</li><li>Q &amp; A</li></ul><p>原本以為會有類似的 Follow-up，結果完全就是在討論這份作業而已，也因此他問得很細節，包含資料前處理、模型設計、參數選擇、可能的問題與解法、程式碼架構等等都有涵蓋到，也因此你要很清楚知道自己在幹嘛。雖然我對我的訓練結果還算滿意，但有點可惜的地方是我因為時間不足，加上可能稍微放錯重點，因此我選用了相較簡單的評估方式（i.e. 用眼睛看），因此也被工程師挑說這部分沒做蠻可惜的（週四給題目週二面試，加上我還邊上班邊搞論文，週末才開始做，確實是有點緊湊）。</p><p>最後問他下一關，他說下一關是 onsite session，會到公司跟他們討論題目 &amp; pair programming，大概會要 4-5 hours，我想說天啊我以為下一關就是發 offer 了嗚，雖然我成功挺進到第三關，但我越來越害怕下一關會被面得體無完膚……（說不定也沒有下一關）。</p><h3 id="Engineer-Director-線上四面"><a href="#Engineer-Director-線上四面" class="headerlink" title="Engineer Director 線上四面"></a>Engineer Director 線上四面</h3><p>等了一週多後，迎來的竟然不是 onsite session 也不是 thank you letter，而是一個 20 minutes 的 “Casual Chat with Engineer Director”。不太確定到底會問什麼，但反正是 Casual Chat，也只能直接上了吧。</p><h4 id="面試流程-20-mins"><a href="#面試流程-20-mins" class="headerlink" title="面試流程 (20 mins)"></a>面試流程 (20 mins)</h4><ul><li>Resume &amp; Chat (~15 mins)</li><li>Q &amp; A</li></ul><p>面完之後的感想，就是確實是 Casual Chat，但我口說退步好多 QQ。這關我感覺不篩人，就是想了解一下人選而已。面試官人很好，英文也很順暢聽很清楚，主要就是問一些履歷上他好奇的問題，像是他問了我之前的面試體驗、論文內容、實習經歷、專案架構等等，基本上熟自己的履歷就可以答的不錯。此外，也有一些延伸問題，像是你的興趣、如何跟上最新 AI 發展等等，不會太難。最後我也問了他像是如何決定產品開發方向、目前遇到什麼問題等等，整體來說就是有收穫的聊天。</p><h3 id="Onsite-Interview-實體五面"><a href="#Onsite-Interview-實體五面" class="headerlink" title="Onsite Interview 實體五面"></a>Onsite Interview 實體五面</h3><p>最終總算迎來大魔王 - Onsite Interview。這關要去他們辦公室，進行總共 5 小時半的面試，其中會有不同環節與不同面試官來跟你面試，也會有一些像是辦公室導覽的環節。這樣的面試模式算是非常少見，畢竟前面已經經歷了那麼多關，再加上把一堆環節塞在同一天，這過程中公司要耗費的人力可想而知。HR 說裡面的每位員工都經歷過這個環節，雖然我自己覺得到這關代表蠻有機會（這是最後一關），但我也有看到幾個面完這關後還是收到感謝信的例子。總之，懷抱著忐忑不安的心情，我來到了他們位於國館附近的辦公室（地點實在是很讚！）。</p><h4 id="面試流程-5-5-hrs"><a href="#面試流程-5-5-hrs" class="headerlink" title="面試流程 (~5.5 hrs)"></a>面試流程 (~5.5 hrs)</h4><ul><li>20 mins - Office Tour &amp; Reminder：這部分主要以參觀辦公室環境以及介紹今天面試流程與注意事項為主，參加者是 HR</li><li>12 mins - Fast QA：這部分會有 10 個以上的員工參加，主要就是針對你的履歷問相關問題，藉由把大家聚在一起一次了解你</li><li>40 mins - Casual Lunch Chat：PicCollage 會提供午餐餐點，這邊就是跟他們團隊成員一起用餐聊天，氣氛算是輕鬆</li><li>20 mins - (Break)</li><li>40 mins - ML Problem Solving：ML 相關的問題，以數學為主，參加者是 ML Team Lead</li><li>50 mins - Pair Programming：非常簡單的 Coding 題，有 OOP 概念會加分，參加者是 ML Engineer</li><li>10 mins - (Break)</li><li>40 mins - Problem Solving：預測問題的解法討論，會有多個變體與 Follow-up，參加者是 Engineer Lead &amp; CEO</li><li>10 mins - (Break)</li><li>45 mins - Product Ideas Discussion：針對產品新功能的發想、討論、規劃、實作等等，參加者是 Product Team (PM&#x2F;PD)</li><li>5 mins - (Break)</li><li>30 mins - Closing Chat：簡單聊一下對面試整體的體驗與想法，參加者是 Engineer Head &amp; Maybe COO&#x2F;CFO</li></ul><p>結束的時候只覺得天哪好累，還有我終於走完所有的面試流程了，好不容易（他應該是我面試生涯中面過最累人的一間公司）！整體的面試體驗是很不錯的，PicCollage 的人都很好，面試題目設計都很扎實有趣，也可以透過面試的過程來模擬體驗公司環境與風氣，還有以後工作的感覺。</p><p>整體的面試體驗我覺得我表現還可，沒有很好也沒有太失常，但有些應該要表現出來的地方沒有表現好，像是突然忘記某個東西的計算方法（結束後馬上想起來…）還有 Coding 時前面卡住太久（不過最後有完成，並且還有多時間）等等。</p><p>但我覺得值得開心的事情是他們似乎都對我的論文很有興趣，除了在吃飯時間有聊到之外，在面試時也很多人都有追問，可能我的碩論確實跟他們工作很有相關？我覺得這件事情是好的，第一是他們真的有想要深入了解我（還有人看過我的網站，受寵若驚 XD），還有就是如果碩論跟他們在做的事情相關，那應該更有理由錄取我了(？)。</p><p>附帶一提，PicCollage 的公司環境很不錯，有興趣的可以參考<a href="https://youtu.be/QpZibLTpFjI?si=L4pxDgQ7p9JlV_a7">這個影片</a>。</p><h3 id="面試結果"><a href="#面試結果" class="headerlink" title="面試結果"></a>面試結果</h3><p>Offer Get! 太開心了！在拿到 Offer 之後，花了一陣子跟他談（compete）薪水，還有選擇到底要不要放棄已經有的 offer 跟研替來這間。過程中也是猶豫了幾週，問了很多不同人的意見，最後因為地點、工作風氣、工作內容、職涯考量、公司福利等等因素，決定放棄研替加入 PicCollage。談薪水真的是門大學問，必須跟大家說，不論如何，一！定！要！談！薪！水！</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>發這篇文的時候，已經在 PicCollage 工作大約一個月，並且要準備去當兵了。雖然我因為來這間公司而放棄了研發替代役，因此還要去服四個月的兵役（也許下一篇文會是兵旅生活？），但目前為止在 PicCollage 的生活都過得很開心，也很享受 PicCollage 的公司文化、福利跟風氣，讓我更加堅信自己的選擇，還有感謝當初有好好努力的自己！之後有機會再回來跟大家分享工作生活，我先去當兵囉～</p>]]></content>
      
      
      <categories>
          
          <category> 工作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fulltime </tag>
            
            <tag> Interview </tag>
            
            <tag> PicCollage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2025 年科技業正職預聘/研替面試心得（TSMC, Google, NVIDIA, Synology, MediaTek, Perfect Corp., Appier)</title>
      <link href="/2025/07/01/fulltime-2025/"/>
      <url>/2025/07/01/fulltime-2025/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每年的面試分享文，似乎已經默默的成為我的某種習慣了（還沒看過我之前文章的，可以參考 <a href="https://jackchen890311.github.io/2023/05/24/summer-intern-2023/">2023</a> 跟 <a href="https://jackchen890311.github.io/2024/06/28/summer-intern-2024/">2024</a> 的分享）。但今年比較不同的是，我要碩士畢業了！因此本篇分享會從以往的實習轉成正職，職位的部分我大多都是找 ML 相關為主。</p><h1 id="面試紀錄"><a href="#面試紀錄" class="headerlink" title="面試紀錄"></a>面試紀錄</h1><ul><li>投遞履歷：7 家公司</li><li>面試邀請：6 家公司</li><li>Offer Get：2 家公司</li></ul><h2 id="TSMC"><a href="#TSMC" class="headerlink" title="TSMC"></a>TSMC</h2><p>應徵職位：沒分，統一丟<br>備註：有研替<br>時程：</p><ul><li>8&#x2F;30 EPO interview invitation</li><li>9&#x2F;12 EPO interview</li><li>10&#x2F;1 EPO Thank you</li><li>9&#x2F;16? 收到 IT 副理電話聊天詢問面試意願</li><li>9&#x2F;23? 沒收到後續，打電話回去問，他好像說他忘記，當天就收到面試邀請</li><li>10&#x2F;15 收到 IT 另一個處約時間，想約同天但卡到</li><li>10&#x2F;18 IT interview (AAPD)</li><li>10&#x2F;25 IT interview (MLAD)</li><li>11&#x2F;1 收到資歷查核</li><li>11&#x2F;5 資歷查核送出，有問是否需要廠測，對方說去年有紀錄不用</li><li>11&#x2F;20 收到 HR 致電說明 Offer 細節並確認意願</li><li>11&#x2F;28 Offer Get (MLAD)</li></ul><p>台積電的面試是各部門自己安排，但大部分的形式似乎都差不多，就是請你自我介紹，然後再針對經歷提問。所以建議準備個簡單的簡報，照著講就好，不難準備。</p><h3 id="EBO-OPC-SWE-for-Advanced-Optical-Lithography-Technology"><a href="#EBO-OPC-SWE-for-Advanced-Optical-Lithography-Technology" class="headerlink" title="EBO OPC - SWE for Advanced Optical Lithography Technology"></a>EBO OPC - SWE for Advanced Optical Lithography Technology</h3><p>這是我最早收到的面試，在聽完我自我介紹後，他好像也沒有太多問題，就開始介紹部門工作，大致上是開發光照相關的內部軟體之類的。但我印象特別深刻的是他一直問我可不可以接受加班，還跟我打預防針說進來每天大概都是八點以後下班，不停的跟我確認可不可以接受。雖然打預防針是不錯啦，但我真的不知道怎麼回答，畢竟我也不想說不接受（雖然最後也稍微表達出不想加班了），搞得有點尷尬。過了一陣子收到感謝信，我想也是好啦，我也不想進去賣肝。</p><h3 id="Online-Coding-Test-For-IT"><a href="#Online-Coding-Test-For-IT" class="headerlink" title="Online Coding Test (For IT)"></a>Online Coding Test (For IT)</h3><ul><li>3 Questions 90 mins, no limit on language</li><li>聽說配分是 50, 50, 75，實習要 100 正職要 120，不確定真實性僅供參考</li><li>我後兩題全對，第一題大概對一半（竟然敗在第一題嗎…）</li><li>第一題：經典的 1&#x2F;0 背包問題，但對時間的要求蠻嚴格的，我寫到我覺得最佳了還是有一半沒過，回去複習…</li><li>第二題：處理登入跟登出系統的 log，計算時間差並做一些判斷之類的，我用 hash table 輕鬆解決，不太難</li><li>第三題：我忘記詳細內容了，但印象是用 Heap 的概念解的，也沒有很難。</li></ul><h3 id="IT-AAID-AAPD-AI-ML-Engineer-LLM"><a href="#IT-AAID-AAPD-AI-ML-Engineer-LLM" class="headerlink" title="IT AAID AAPD - AI&#x2F;ML Engineer (LLM)"></a>IT AAID AAPD - AI&#x2F;ML Engineer (LLM)</h3><p>IT 也是台積最主要的核心 AI 部門，底下還有分幾個不同的處。這個單位的話，主要是在做給台積內部使用的工具，像是他們其實有內部自己的 Chatbot 叫 T-genie，去年實習的時候有用過，就是這個單位開發的。所以這個單位主要的服務對象是內部的 general user，主要接觸的工具應該比較偏 LLM 相關。</p><!-- mainly focus on application in internal user (LLM) --><h3 id="IT-AAID-MLAD-AI-ML-Engineer-CV"><a href="#IT-AAID-MLAD-AI-ML-Engineer-CV" class="headerlink" title="IT AAID MLAD - AI&#x2F;ML Engineer (CV)"></a>IT AAID MLAD - AI&#x2F;ML Engineer (CV)</h3><p>這個單位跟上面應該算是平行的單位，主要做的事情是把 AI 應用在 FAB 相關的場域上（我去年的是 FAC，不太一樣）。這邊的 FAB 就跟晶圓製造比較直接相關了，像是瑕疵檢測等等，技術方面的話應該比較偏重 CV。但我印象中他們對於 Gen AI 的應用相對較少，頂多就是有一些 Synthetic Data Generation 之類的。</p><!-- mainly focus on application in FAB (CV) --><h3 id="後續"><a href="#後續" class="headerlink" title="後續"></a>後續</h3><p>後續應該是拿到 AAID MLAD 的 Offer，但我因為<a href="https://jackchen890311.github.io/2023/09/11/intern-at-TSMC/">前年已經在 TSMC 實習過了</a>，對這間公司的風氣覺得還好，最後就婉拒了。但不得不說 TSMC 的薪水是真的香，IT 部門大部分應該也不會太可怕，不失為一個選擇。</p><h2 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h2><p>應徵職位：SWE New Grad, Silicon New Grad, Imaging and On-Device ML SWE (Silicon), Silicon Intern<br>時程：</p><ul><li>10&#x2F;1 請人內推，送出所有職位的申請</li><li>10&#x2F;16 收到 Imaging and On-Device ML SWE 感謝信</li><li>10&#x2F;21 收到 SWE 約面試</li><li>11&#x2F;7 SWE 1st Round Coding Interview （原本敲定 10&#x2F;31，後來臨時往後延）</li><li>11&#x2F;15 主動寄信詢問後續，無聲卡</li><li>12&#x2F;25 無聊丟一下 Silicon Intern</li><li>12&#x2F;31 Silicon Intern 感謝信（聽學長說是畢業時間問題）</li><li>1&#x2F;9 請學長內推 Silicon Intern</li><li>2&#x2F;6 Silicon Intern 1st Round Tech Interview</li><li>2&#x2F;19 Silicon Intern 2nd Round Tech Interview</li><li>2&#x2F;25 Positive Feedback (But waiting for other interviewees)</li><li>3&#x2F;21 Follow-up on Results but No Reply</li><li>4&#x2F;15 Thank You Letter (Reason: Strong performance but found better fit candidate)</li></ul><h3 id="SWE-1st-Round"><a href="#SWE-1st-Round" class="headerlink" title="SWE 1st Round"></a>SWE 1st Round</h3><ul><li>考官是中國人，但英文面試，所以有點痛苦</li><li>題目大概是 Multi-source distinct shortest path，只有一個 destination</li><li>走過的路徑只算一次，也就是說兩個 source 可以藉由 share path 來減少路徑</li><li>Warm-up 就是給我一個 case 請我找出更好的走法</li><li>我答的蠻爛的，應該是涼了，英文 + 不熟悉的題目完全無法</li><li>但面試官還加時 20 mins 讓我把問題做完，最後有給出可行解，時間複雜度不算太糟</li></ul><h3 id="Silicon-Intern-1st-Round-Tech-Interview"><a href="#Silicon-Intern-1st-Round-Tech-Interview" class="headerlink" title="Silicon Intern 1st Round Tech Interview"></a>Silicon Intern 1st Round Tech Interview</h3><ul><li>English based</li><li>介紹自己的 ML 專案</li><li>介紹 GAN &#x2F; Diffusion</li><li>GAN &#x2F; Diffusion Training problems and solutions</li><li>介紹 Transformer and its pros and cons</li><li>有沒有能力自幹 Training code</li><li>Training failed how to check</li><li>Explain any DL optimization methods (Literally Any)</li><li>Coding<ul><li>Circular array calculate shortest distance between 2 indexes</li><li>Follow-up: shortest distance between given index and item</li></ul></li></ul><h3 id="Silicon-Intern-2nd-Round-Tech-Interview"><a href="#Silicon-Intern-2nd-Round-Tech-Interview" class="headerlink" title="Silicon Intern 2nd Round Tech Interview"></a>Silicon Intern 2nd Round Tech Interview</h3><ul><li>English based</li><li>Activation Functions<ul><li>Swish Analysis (Derivative, Choose of Constant, Characteristics, Compare with other Activation Functions)</li><li>Activation Functions in Transformer</li></ul></li><li>Latent Diffusion Models<ul><li>Conditioning, Inference</li><li>Extend to Video Generation: How to do that? Some related problems and how to solve it?</li></ul></li></ul><h3 id="後續-1"><a href="#後續-1" class="headerlink" title="後續"></a>後續</h3><p>SWE 後來就無聲卡了，Silicon Intern 收到的回覆是表現很不錯，但請我等他們面完其他候選人。殊不知這一等就等了好久，過程中我主動 follow-up 也被無聲，後來到四月底才收到感謝信，說雖然我表現很好，但他們最後找了其他更適合的人。再更後來我有打聽到，最後好像是選隔壁實驗室，以前上過課的老師的學生，主因應該是因為那個老師有很多前輩在那個部門，並且他本身的發表經驗也比我多（雖然成績應該是沒有比我好）。這次大概是我最靠近 Google 的一次了，非常可惜！</p><h2 id="NVIDIA"><a href="#NVIDIA" class="headerlink" title="NVIDIA"></a>NVIDIA</h2><p>應徵職位：AI Engineer, DL Engineer<br>備註：有研替（他們家研替叫 intern，沒有 RSU 跟不算年資的樣子）<br>時程：</p><ul><li>10&#x2F;21 收到主管聯絡詢問 RDSS 意願</li><li>11&#x2F;4 收到 AI Algorithm SWE (RDSS intern) Online Test 邀請</li><li>11&#x2F;25 收到一面邀請</li><li>12&#x2F;5 線上一面</li><li>12&#x2F;16 收到二面邀請</li><li>12&#x2F;20 線上二面</li><li>12&#x2F;26 寄信詢問後續（因為收到其他 Offer，想加快，但最後沒有理我）</li></ul><h3 id="Online-Test"><a href="#Online-Test" class="headerlink" title="Online Test"></a>Online Test</h3><ul><li>3 Coding + 21 Mutiple Choices, 90 minutes</li><li>Coding 蠻簡單的，感覺不著重考資結跟演算法</li><li>Mutiple Choices 著重 AI &#x2F; DL 相關觀念，會直接把 code 貼出來給你選</li></ul><h4 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h4><ul><li>第一題：色碼處理（字串&#x2F;十六進位&#x2F;整數轉換）</li><li>第二題：Scipy 基本操作（我對 Scipy 完全不熟，所以沒寫出來，誰做 AI 在用 scipy…）</li><li>第三題：座標點朝向彼此移動，判斷是否全部聚在同一點</li></ul><h4 id="Mutiple-Choices"><a href="#Mutiple-Choices" class="headerlink" title="Mutiple Choices"></a>Mutiple Choices</h4><p>考的內容很多元，我覺得出的蠻好的，內容包含主要圍繞在 DL，常見的模型如 CNN, GAN, UNet, AutoEncoder 等等都有出現，也有考一些基本的 CV 與 NLP 概念，像是怎麼訓練、微調、特定任務的標籤要怎麼處理等等，也會詢問常見的 Library 像是 Transformers，需要具備紮實的 DL 基礎。</p><h3 id="線上一面"><a href="#線上一面" class="headerlink" title="線上一面"></a>線上一面</h3><p>流程：</p><ul><li>同一天兩輪，一輪一人一小時</li><li>簡介工作內容，大約 5 分鐘</li><li>個人經歷介紹，大約 10 - 20 分鐘</li><li>AI 相關技術問題，大約 0 - 10 分鐘 <!-- 有被問 GAN，還有 Model train 不起來的情境題 --></li><li>Coding 題與相關 Follow-up，大約 30 分鐘</li></ul><p>先前有寄信問 HR 面試流程，但沒有得到回覆，只好隨意準備。  </p><p>Coding 題的部分沒有很難，但很考驗基礎功力，我遇到的題目如下：</p><ul><li>實作 Convolution（可能會包含 Stride、Padding 等等設定） <!-- 最後還有加考 Dilated，但我來不及做完 --></li><li>實作兩個知名 CV Backbone 裡面的 Block，包含 Layer 定義跟 Forward Process</li></ul><h4 id="關於部門"><a href="#關於部門" class="headerlink" title="關於部門"></a>關於部門</h4><p>我面的這個職缺聽他說是新成立的，主要負責打造內部用的 AI Toolkit（TAO），會把最新的 Paper 的 Code 整合進去，因此感覺是個介於 Research 與 Engineer 之間的存在，同時也有跟一些工廠合作，來推他們的這個 Toolkit，也會幫他們解決一些相關問題。我個人是覺得這東西感覺蠻好玩的，因為同時有 AI 跟 SWE，主要領域又是著重在 CV 上面，完全是很適合我，感覺我面的也還算不賴，希望還有機會。</p><h3 id="線上二面"><a href="#線上二面" class="headerlink" title="線上二面"></a>線上二面</h3><p>流程：</p><ul><li>只有一輪一人一小時</li><li>AI 相關技術問題，大約 30 分鐘 </li><li>個人經歷介紹與相關提問，大約 30 分鐘</li><li>(Optional) Coding Test，我最後因為時間關係沒有遇到</li></ul><p>前半部的 AI 相關討論跟第一次有點類似，但這次的更深入並更開放，如果對 AI 沒有很深刻的了解，我想是很難答的好的。像是他有問你覺得分類問題可以用 MSE Loss 嗎、L1 Loss 跟 L2 Loss 的好處壞處各是什麼、Bias Variance Tradeoff 的概念等等。雖然有些我大學上課有學過，但我當時還真的快忘光，因此我覺得我答的不太好 QQ，希望不要在這個階段告吹，畢竟前面技術關都通過了。後半部的個人經歷就一樣我介紹他問問題，這次的面試官問的蠻細節的，但也還好我都算有答出來，現在就是看前半的表現可不可以了。</p><h3 id="後續-2"><a href="#後續-2" class="headerlink" title="後續"></a>後續</h3><p>後來等一段時間後，我有寄信給 recruiter follow-up，但都被無聲卡，看來敗在第二面表現太爛了……QQ。</p><h2 id="Synology"><a href="#Synology" class="headerlink" title="Synology"></a>Synology</h2><p>應徵職位：Product Developer<br>備註：有研替<br>時程：</p><ul><li>? 投遞履歷</li></ul><h3 id="後續-3"><a href="#後續-3" class="headerlink" title="後續"></a>後續</h3><p>很後來才發現投過，直接被無聲卡，QQ。聽說他們現在都沒在看履歷，或是定期會把舊的刷掉，不知道真假。</p><h2 id="MediaTek"><a href="#MediaTek" class="headerlink" title="MediaTek"></a>MediaTek</h2><p>應徵職位：演算法開發_影像演算法、軟韌體開發_AI &amp; Computing Platform<br>備註：有研替<br>時程：</p><ul><li>10&#x2F;17 收到面談邀約</li><li>11&#x2F;15 以前 完成線上測驗（適性、TOEIC、Coding）</li><li>11&#x2F;15 第一次面試（演算法開發_影像演算法）</li><li>12&#x2F;18 寄信問後續，對方回覆無後續</li><li>1&#x2F;9 又收到另一個 Team 面試邀約</li><li>1&#x2F;17 第一次面試（軟韌體開發_AI &amp; Computing Platform）</li></ul><h3 id="Online-Coding-Test"><a href="#Online-Coding-Test" class="headerlink" title="Online Coding Test"></a>Online Coding Test</h3><ul><li>2 Coding + 16 Mutiple Choices + 8 Blank filling, 90 minutes</li><li>語言限定 C &#x2F; C++ (Coding 只有 C)</li><li>選擇與填空注重語法與 OOP 觀念，需要很熟悉 C &#x2F; C++</li><li>Coding 皆偏基礎（Palindrome, Swap with bit operation）</li></ul><h3 id="第一次面試（演算法開發-影像演算法）"><a href="#第一次面試（演算法開發-影像演算法）" class="headerlink" title="第一次面試（演算法開發_影像演算法）"></a>第一次面試（演算法開發_影像演算法）</h3><p>有聽說 MTK 是多部門一起，但不知為啥當天只來一個部門的兩位主管（來面我的是 AIDE，就是 MTK 裡面主要負責 AI 的部門，達哥就是他們做的）。面試前有要求做簡報，所以前半部都在自我介紹，全部講完後主管開始提問，他們真的問蠻細的，每頁經歷有興趣的都會問，也會 follow 一些相關問題來看你的人格特質，還有你遇到問題會如何解決等等。但我覺得這部分相較好準備，就是把你的經歷都弄熟，展現出你的自信就好，相較之下 Google 的 Coding Interview 難多了。問完已經過一小時多，後面就換部門介紹與提問，整題感覺聊的很不錯，他們也有展現出一定的興趣，應該算蠻有機會的。</p><h3 id="第一次面試（軟韌體開發-AI-Computing-Platform）"><a href="#第一次面試（軟韌體開發-AI-Computing-Platform）" class="headerlink" title="第一次面試（軟韌體開發_AI &amp; Computing Platform）"></a>第一次面試（軟韌體開發_AI &amp; Computing Platform）</h3><p>這個部門我上次也有收到邀請，但面試沒出現，後來拿到 Offer 了想說就加減隨意面。流程一樣自介 -&gt; 提問 -&gt; 部門介紹，這個部門好像主要是寫不同的 OS Driver，還有把 AI Model 放到他們特化的 Chips 上面，跟一些相關的 Evaluation 跟 Verification 等等。其實算是我相對不熟 &amp; 沒興趣的職位，大部分都在碰蠻底層的東西，主要 Skill Set 也是 C&#x2F;C++、OS 等等，加上他還說每年大概一個月需要加班，所以其實我沒啥興趣。但還是花了一個半小時講好講滿，他們還問了很多關於你對工作的選擇看法，可惜的是我應該沒有要選他們。</p><h3 id="後續-4"><a href="#後續-4" class="headerlink" title="後續"></a>後續</h3><p>後來都無聲卡，再更後來好像聽到 AIDE 被解散的風聲。</p><h2 id="玩美移動"><a href="#玩美移動" class="headerlink" title="玩美移動"></a>玩美移動</h2><p>應徵職位：AI Engineer (Image processing)、Machine Learning Engineer<br>備註：有研替<br>時程：</p><ul><li>11&#x2F;18 收到 Mobile Development invitation，但我跑去投 AI &#x2F; ML 的缺</li><li>11&#x2F;19~11&#x2F;21 收到面試詢問與邀約，有 Coding Test</li><li>11&#x2F;28 IQ + 英文 + 主管面談（App AI）</li><li>12&#x2F;12 主管面談（Gen AI）</li><li>12&#x2F;13 收到 Gen AI 口頭 Offer &amp; 約時間現場談薪水 + 參觀辦公室</li><li>12&#x2F;25 現場談薪水 + 參觀辦公室</li><li>1&#x2F;13 Offer Accepted</li></ul><h3 id="Online-Coding-Test-1"><a href="#Online-Coding-Test-1" class="headerlink" title="Online Coding Test"></a>Online Coding Test</h3><p>限定語言：C &#x2F; C++，有開放網路查詢語法</p><ul><li>第一題（M）：String Reduction, given a reduction rule find minimum length</li><li>第二題（M）：Cipher (Rotation based) </li><li>第三題（E）：String Changes, given a change rule (skip &#x2F; duplicate) find changed string</li></ul><!-- String Reduction: ab, ba -> c / ac, ca -> b / bc, cb -> aCaesar Cipher: Case Sensitive & General (Might have more than english character)String Changes: N -> remove next / M -> duplicate previous--><h3 id="IQ-英文-主管面談（App-AI）"><a href="#IQ-英文-主管面談（App-AI）" class="headerlink" title="IQ + 英文 + 主管面談（App AI）"></a>IQ + 英文 + 主管面談（App AI）</h3><p>面試當天共兩小時，第一小時是 IQ + 英文測驗。IQ 的部分分為中文、數學、圖像理解，就跟一般的 IQ 測驗差不多，但時間蠻短的要自己注意速度。英文的部分就是標準的多益測驗，沒啥難度。HR 會看著你線上考，考完之後馬上看成績，確定沒問題後就進入面試環節（不知道太爛會不會直接結束面試 XD）。</p><p>主管面談的部分就一樣，由我講經歷他問問題，但有個比較特別的是他有針對我 Github 上整理的課程作業問細節，特別是 DLCV 的作業內容，我甚至一個一個作業開給他跟他解釋。這部分問蠻細的，包含這個 Task 在做什麼、你為什麼選這麼 Model、有遇到什麼狀況、Dataset 用啥、Performance 多好都有問，雖然我有些都忘記了但還是大致有回答出來。接著就是問一些基本的 DL 相關問題，像是你平常怎麼訓練 Model、參數怎麼選、如何避免 Overfitting 等等，同時也有確認我的一些相關技能，像是影像處理、計算機圖形等等。</p><p>最後部門介紹的部分，他們說他們部門主要做的是 App 端的 Model，也因此模型的大小與效率很重要，除了演算法的開發也會蠻多時間在考慮這個模型能否在手機端直接運算，或是能否用傳統的影像處理方式就做掉節省運算量等等。但也有 Gen AI 相關的應用，像是更換背景、去除物件，但比較是另一個 Team 做的事情。相較之下我其實對另一個 Team 會比較有興趣，所以也有跟面試官表達，也許之後還有機會可以面面看。</p><h3 id="主管面談（Gen-AI）"><a href="#主管面談（Gen-AI）" class="headerlink" title="主管面談（Gen AI）"></a>主管面談（Gen AI）</h3><p>流程跟前面類似，但今天的主管似乎比較少提問，不知道是不是我講得太投入，他就聽著我講偶爾問一兩句這樣，沒有太深入的想了解我經歷的感覺。但後半的部門介紹他講了蠻多的，相較前面的部門，這個部門更著重在一些關於 Gen AI 相關的應用。從需求面出發的話，最近熱門的應用有虛擬試裝、圖片編輯（用自然語言）等等，而這些的相關技術大多圍繞在 Diffusion Models，因此也是主要用到的工具。令我意外的是，他們也有在做一些 LLM &#x2F; VLM 相關的應用，像是 AI 櫃姐等等，還蠻酷的。整體來說這個 Team 做的東西感覺蠻好玩，也會用到很多最近熱門的技術，又跟我的研究大致有相關，只希望他對我還有興趣了。</p><h3 id="現場談薪水-參觀辦公室"><a href="#現場談薪水-參觀辦公室" class="headerlink" title="現場談薪水 + 參觀辦公室"></a>現場談薪水 + 參觀辦公室</h3><p>後來面完隔天就收到 HR 的電話，詢問我的意願並發給我口頭 Offer，同時想跟我約一天現場實體面談（但不是面試，應該就是談 Offer）。蠻驚喜的，因為還在想他面試時感覺沒有問太深入，結果就直接給我 Offer 了，後來就跟他敲定聖誕節去辦公室面談。</p><p>當天來到他們位於大坪林附近的辦公室，是在一般的辦公大樓裡，一共十幾層，大概 1&#x2F;4 ~ 1&#x2F;3 是屬於訊連科技與玩美移動的，兩者又差不多再佔各半。面談進行的還蠻順利的，應該是我未來的主管讓我對於工作提問，並且他也補充了很多他們部門正在做或過去的專案經驗等等。<br>他一開始就先問我有沒有在面其他家，然後再跟我分析說這些工作差異，並且有點像在說服我的感覺，確實聽完之後我又更想去了一點 XD。</p><p>主管還蠻健談的，我問了幾個問題就過了快一小時，最後問完後就是來到談薪水環節。來之前我有做了一點研究，也問了一下我學長有沒有什麼要注意的地方，跟他之前談的數字。一開始給的數字差不多跟我打聽的一致，但我用已經有的 Offer 跟他 Compete，試試看能不能談更高。<br>他看起來也沒有面露難色，並表示會幫我問問看，最後還跟我要了 Line，感覺應該是有機會！於是就獲得了人生第一次談薪水的經驗，還蠻有趣的但有點怕怕的就是了哈哈哈。（其實原本的薪水我覺得也可以接受啦，但如果我有這個市場價那當然越高越好 XD）</p><h3 id="後續-5"><a href="#後續-5" class="headerlink" title="後續"></a>後續</h3><p>後來主管聯繫我，跟我說他幫我談到的薪水，最後落在一開始的數字與我喊的數字之間（我原本以為會直接給到我的數字，不過我喊的確實比較高）。但我這邊因為還想等等看 NVIDIA，所以就請他再等我幾週，但 NVIDIA 那邊都沒有後續，所以最後決定先接受了。</p><h2 id="Appier"><a href="#Appier" class="headerlink" title="Appier"></a>Appier</h2><p>應徵職位：Machine Learning Scientist &amp; Engineer<br>備註：有研替，原本在這實習，請主管幫忙問能否轉正，但是轉到不同 Team，一樣需要面試，並且是跟不同主管<br>時程：</p><ul><li>與現主管約 1-on-1 聊目前 Offer 狀況與轉正情形</li><li>2&#x2F;5 收到 HR 聯絡說明並敲定面試時間</li><li>3&#x2F;6 主管一面（技術面試）</li><li>3&#x2F;20 Thank You Letter</li><li>7&#x2F;14 現主管幫我內推 AI Research Team，但後來沒去面試</li></ul><h3 id="主管一面（Bidding-Team）"><a href="#主管一面（Bidding-Team）" class="headerlink" title="主管一面（Bidding Team）"></a>主管一面（Bidding Team）</h3><ul><li>三個部分：自我介紹與相關專案、Scientist Related Questions、Engineer Related Questions</li><li>每個部分各 20-30 分鐘，但最後總共面了 2 小時</li><li>Scientist<ul><li>Design Product Search Recommendation Model</li><li>Details: Feature &#x2F; Model &#x2F; Training &#x2F; Online &amp; Offline &#x2F; Evaluation…</li></ul></li><li>Engineer<ul><li>Pick one of your project and explain it from start to end</li><li>Two Dimensional Logs Processing &amp; Transformation</li><li>Prefix Sum</li></ul></li></ul><h3 id="後續-6"><a href="#後續-6" class="headerlink" title="後續"></a>後續</h3><p>後來收到 Thank You Letter 了，不太確定原因，但過幾天原主管跟我跟我約了個 1-on-1 聊天，好像說聽到的 Feedback 是我在這邊的專案太簡單，他們覺得還好。Hmmm……確實是有點簡單，我當初做就有類似的想法，不過也有可能是我包裝不好，但我好像也無可奈何，畢竟就是主管給的專案，也沒有其他 junior 或 senior 一起做。後來想說算了，反正現在這個新 Team 做的內容我也還好，相比之下我可能比較會想選完美移動，不過 Appier 的薪水、地理位置、公司風氣真的都很香……。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>2025 的面試分享大概到這邊，體感今年景氣有比去年稍微好一些，但整體而言也不像疫情時那麼好找。很可惜的是這次與 Google 擦肩而過，真的是令我非常的遺憾，Google 真的是身為資工人都想進去體驗一輪的公司。另外，我也有稍微被資工的薪資水準驚訝到，這年代醫牙電資跟果然其他科系有很明顯的差異，很慶幸自己之前有決定轉換跑道，除了學的東西更好玩之外，也拿到了這些不錯的 Offer。</p>]]></content>
      
      
      <categories>
          
          <category> 工作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fulltime </tag>
            
            <tag> Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題</title>
      <link href="/2025/06/10/dsa-tutorial-11/"/>
      <url>/2025/06/10/dsa-tutorial-11/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h2 id="最大子數列問題-Maximum-Subarray-Problem"><a href="#最大子數列問題-Maximum-Subarray-Problem" class="headerlink" title="最大子數列問題 (Maximum Subarray Problem)"></a>最大子數列問題 (Maximum Subarray Problem)</h2><p>最大子陣列問題是指在一個整數數列中，找出一段連續子陣列，使其元素總和最大。這是經典的動態規劃問題之一，常用於資料分析，如股價變動趨勢。</p><p><img src="https://hackmd.io/_uploads/BJFh7JLZxx.png" alt="image"></p><ul><li>例子：給定一個陣列 [-2, -3, 4, -1, -2, 1, 5, -3]，找出總和最大的子陣列。</li><li>解答：最大子陣列為 [4, -1, -2, 1, 5]，其總和為 7。</li></ul><h3 id="Kadane’s-Algorithm"><a href="#Kadane’s-Algorithm" class="headerlink" title="Kadane’s Algorithm"></a>Kadane’s Algorithm</h3><p>Kadane’s Algorithm 是一種專門用來解決此問題的演算法，可在線性時間內計算完成。要了解 Kadane’s Algorithm，讓我們從暴力法一步一步來看。</p><ul><li><a href="https://zhuanlan.zhihu.com/p/85188269">滴滴面试手撕算法题-kadane算法</a></li></ul><h4 id="暴力法：遍歷全部連續子陣列"><a href="#暴力法：遍歷全部連續子陣列" class="headerlink" title="暴力法：遍歷全部連續子陣列"></a>暴力法：遍歷全部連續子陣列</h4><p>最簡單的方式，就是窮舉所有可能的連續子陣列，並計算每一個子陣列的總和，再從中找出最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArrayBF</span>(<span class="params">nums</span>):</span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            total = <span class="built_in">sum</span>(nums[i:j])</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, total)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><ul><li>時間複雜度：$O(n^3)$</li><li>空間複雜度：$O(1)$</li></ul><p>就算我們用小技巧 curr_sum，來優化 sum() 的計算，時間複雜度依舊很高。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArrayBF2</span>(<span class="params">nums</span>):</span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        curr_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            curr_sum += nums[j]</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, curr_sum)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure><ul><li>時間複雜度：$O(n^2)$</li><li>空間複雜度：$O(1)$</li></ul><h4 id="優化時間：動態規劃"><a href="#優化時間：動態規劃" class="headerlink" title="優化時間：動態規劃"></a>優化時間：動態規劃</h4><p>如果我們知道「以某個位置結尾的最大子陣列和」，那我們就可以用它來推導下一個位置的最大值 -&gt; 動態規劃！</p><ul><li>dp[i]: 表示 以 index i 結尾 的最大連續子陣列和。</li><li>dp[i] &#x3D; max(dp[i-1], 0)+ nums[i]<ul><li>延續之前的子陣列（dp[i-1] + nums[i]） or 重新開始（nums[i]）</li><li>若前面總和小於 0，則完全不取前面，重新計算</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArrayDP</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], <span class="number">0</span>) + nums[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure><ul><li>時間複雜度：$O(n)$</li><li>空間複雜度：$O(n)$</li></ul><h4 id="優化空間：Kadane’s-Algorithm"><a href="#優化空間：Kadane’s-Algorithm" class="headerlink" title="優化空間：Kadane’s Algorithm"></a>優化空間：Kadane’s Algorithm</h4><p>如果我們仔細觀察動態規劃的解法，會發現其實根本不需要整個 dp 陣列，因為我們只關心上一個 dp[i-1] 和目前的值。因此，Kadane’s Algorithm 利用以下兩個變數，來更進一步優化 dp 解法的空間複雜度：</p><ul><li>local_max：目前位置為結尾的最大子陣列和</li><li>global_max：迄今為止出現過的最大子陣列和</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArrayKadane</span>(<span class="params">nums</span>):</span><br><span class="line">    local_max = global_max = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        local_max = <span class="built_in">max</span>(local_max, <span class="number">0</span>) + nums[i]</span><br><span class="line">        global_max = <span class="built_in">max</span>(global_max, local_max)</span><br><span class="line">    <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure><ul><li>時間複雜度：$O(n)$</li><li>空間複雜度：$O(1)$</li></ul><p>至此，最大子數列問題已經被我們用僅僅 6 行的程式碼，加上 $O(n)$ 的時間與 $O(1)$ 的空間解決了。Kadane’s Algorithm 是不是很精美呢？</p><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/maximum-subarray/description/">53. Maximum Subarray</a></li><li><a href="https://leetcode.com/problems/maximum-sum-circular-subarray">918. Maximum Sum Circular Subarray</a></li></ul><h2 id="背包問題（Knapsack-Problem）"><a href="#背包問題（Knapsack-Problem）" class="headerlink" title="背包問題（Knapsack Problem）"></a>背包問題（Knapsack Problem）</h2><p><img src="https://hackmd.io/_uploads/SJHGJ6jgyx.png" alt="image"></p><p>背包問題（Knapsack Problem）是最佳化中的經典問題之一。<br>該問題的基本形式是：</p><ul><li>給定一個背包，其容量為固定的正整數（C）</li><li>給定 N 種物品，每個物品都有自己的重量（w）與價值（v）</li><li>目標是在不超過背包容量的前提下，選擇若干物品，使得它們的總價值最大</li></ul><p>這個問題常用來模擬像是資源分配、投資選擇、或是行程安排等情境，也是一個常出現在演算法課程和競賽中的經典題型。</p><ul><li><a href="https://web.ntnu.edu.tw/~algo/KnapsackProblem.html">Knapsack Problem - 演算法筆記</a></li><li><a href="https://www.csie.ntu.edu.tw/~yvchen/f107-ada/doc/181011_DynamicProgramming2.pdf">ADA Handout (DP), Vivian Chen, NTU CSIE</a></li></ul><p>根據限制的種類，背包問題又可以分為以下幾種：</p><h3 id="分數背包問題（Fractional-Knapsack-Problem）"><a href="#分數背包問題（Fractional-Knapsack-Problem）" class="headerlink" title="分數背包問題（Fractional Knapsack Problem）"></a>分數背包問題（Fractional Knapsack Problem）</h3><ul><li>每樣物品可以被切割（可放部分物品）</li><li>解法：用貪婪演算法，依據「單位價值」高到低排序放入背包</li></ul><p>這個問題的解法很直覺，直接依據「單位價值」（v &#x2F; w，也就是我們常說的 CP 值）的高低放入背包，直到背包裝滿為止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fractional_knapsack</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    items = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(weights, values), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]/x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    total_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w, v <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> capacity &gt;= w:</span><br><span class="line">            total_value += v</span><br><span class="line">            capacity -= w</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            total_value += v * (capacity / w)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> total_value</span><br></pre></td></tr></table></figure><h3 id="0-1-背包問題（0-1-Knapsack-Problem）"><a href="#0-1-背包問題（0-1-Knapsack-Problem）" class="headerlink" title="0&#x2F;1 背包問題（0&#x2F;1 Knapsack Problem）"></a>0&#x2F;1 背包問題（0&#x2F;1 Knapsack Problem）</h3><ul><li>每樣物品只能選一次（不可切割），也是最經典的背包問題</li><li>解法：用動態規劃，考慮每一項物品「選」或「不選」</li></ul><p>0&#x2F;1 背包問題是最常見也最經典的背包問題，基本的解法是用 n x C 的 2D DP 矩陣，來代表在不同情況下，背包能達到的最大 total value，計算完後 dp[n][C] 即為解答。</p><p><img src="https://hackmd.io/_uploads/By0VJYKGgg.png" alt="image"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_2d</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (capacity + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(capacity + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> weights[i - <span class="number">1</span>] &lt;= w:</span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w], dp[i - <span class="number">1</span>][w - weights[i - <span class="number">1</span>]] + values[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n][capacity]</span><br></pre></td></tr></table></figure><p>我們也可以再更優化成 1D DP 來節省空間，並同時維持方法的正確性。要注意的是，若僅用一個 DP Array，則在內層迴圈要以倒序方式，才不會讓在該輪更新的值影響到計算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_1d</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    dp = [<span class="number">0</span>] * (capacity + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(capacity, weights[i] - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 倒序，避免重複選</span></span><br><span class="line">            dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[capacity]</span><br></pre></td></tr></table></figure><h3 id="有限背包問題（Bounded-Knapsack-Problem）"><a href="#有限背包問題（Bounded-Knapsack-Problem）" class="headerlink" title="有限背包問題（Bounded Knapsack Problem）"></a>有限背包問題（Bounded Knapsack Problem）</h3><ul><li>每樣物品有固定數量，可能可以選擇大於 1 次</li><li>解法：將物品拆成多個 0&#x2F;1 物品，把問題轉化成 0&#x2F;1 背包問題來解</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bounded_knapsack</span>(<span class="params">weights, values, counts, capacity</span>):</span><br><span class="line">    expanded_weights = []</span><br><span class="line">    expanded_values = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weights)):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(counts[i]):</span><br><span class="line">            expanded_weights.append(weights[i])</span><br><span class="line">            expanded_values.append(values[i])</span><br><span class="line">    <span class="keyword">return</span> knapsack_1d(expanded_weights, expanded_values, capacity)</span><br></pre></td></tr></table></figure><h3 id="無限背包問題（Unbounded-Knapsack-Problem）"><a href="#無限背包問題（Unbounded-Knapsack-Problem）" class="headerlink" title="無限背包問題（Unbounded Knapsack Problem）"></a>無限背包問題（Unbounded Knapsack Problem）</h3><ul><li>每樣物品可以選無限次</li><li>解法：動態規劃，不同於 0&#x2F;1 背包，內層迴圈需順序處理</li></ul><p>因為每種物品可以選無限次，我們就不必用倒序方法來避免重複選擇，直接在內層迴圈順序選取即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unbounded_knapsack</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    dp = [<span class="number">0</span>] * (capacity + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weights)):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(weights[i], capacity + <span class="number">1</span>):  <span class="comment"># 順序，允許重複選</span></span><br><span class="line">            dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    <span class="keyword">return</span> dp[capacity]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="換錢問題（Coin-Change-Problem）"><a href="#換錢問題（Coin-Change-Problem）" class="headerlink" title="換錢問題（Coin Change Problem）"></a>換錢問題（Coin Change Problem）</h2><p><img src="https://hackmd.io/_uploads/rkR7YYtfgg.png" alt="image"></p><p>換錢問題是一個經典的演算法問題，目的是在給定一組硬幣面額與一個目標金額的情況下，找出可以湊出該金額所需的最少硬幣數量。</p><p>這個問題常用於訓練動態規劃（Dynamic Programming）技巧，並在許多實際應用中具有重要意義，例如金融系統、自動販賣機與資源分配等。</p><ul><li><a href="https://web.ntnu.edu.tw/~algo/KnapsackProblem.html">Knapsack Problem#Coin Problem - 演算法筆記</a></li><li><a href="https://medium.com/@cutesciuridae/dynamic-programming-%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-%E4%BB%A5coin-change%E7%82%BA%E4%BE%8B-4a4f3e7d98ea">Dynamic programming 深入淺出 - 以 Coin change 為例</a></li></ul><p>利用這個問題，我們順便來複習一下動態規劃（Dynamic Programming）：<br><img src="https://hackmd.io/_uploads/rJby5FtGex.png" alt="image"></p><p>以這個問題為例：</p><ol><li>定義狀態 [我在哪裡]<br>DP[n] &#x3D;找出n元最精簡的找零零錢數目(用最少數目的銅板湊出)</li><li>定義狀態轉移關係式(通則) [我從哪裡來] &#x3D;&gt; [答案從哪裡推導而來]<br><img src="https://hackmd.io/_uploads/HkegB9YFfgl.png" alt="image"></li><li>釐清初始狀態(終止條件) [第一步怎麼走，怎麼出發的]<br>用每個銅板去縮小找零問題的規模，從n元找零問題一直化簡，降到0元的找<br>終止狀態：<br>0元的找零方法：0，代表不拿任何一枚銅板<br>&lt;0元的找零方法：不合法，應該停止計算，可用 float(‘inf’) 來處理</li></ol><h3 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/coin-change/description/">322. Coin Change</a></li></ul><!-- - [518. Coin Change II](https://leetcode.com/problems/coin-change-ii/description/) --><!-- ## 旅行銷售員問題（TSP, Traveling Salesman Problem）![image](https://hackmd.io/_uploads/Sk8U16sekl.png)  --><!-- # Progress check## 講義- TODO: 尋找更多主題- TODO: Update to blog## 學生- 進階演算法： LC 42, 239 not finished, Kadane finish-->]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (10) - 差分陣列、單調堆疊/佇列</title>
      <link href="/2025/06/10/dsa-tutorial-10/"/>
      <url>/2025/06/10/dsa-tutorial-10/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h2 id="差分陣列（Difference-Array）"><a href="#差分陣列（Difference-Array）" class="headerlink" title="差分陣列（Difference Array）"></a>差分陣列（Difference Array）</h2><p><img src="https://hackmd.io/_uploads/HkVH0QvMyl.png" alt="image"></p><p>差分陣列是一種快速處理<strong>區間更新</strong>的技巧，特別適用於頻繁對陣列特定區間進行加減的情境，其基於前綴和（Prefix Sum）的概念來輔助實現。</p><p>其核心概念是透過維護一個輔助陣列 diff，來記錄原陣列的數值變化，使得區間的加減可以在 O(1) 時間內完成，而最終結果則可透過前綴和的技巧來計算。</p><h3 id="輔助陣列的建立"><a href="#輔助陣列的建立" class="headerlink" title="輔助陣列的建立"></a>輔助陣列的建立</h3><p>輔助陣列 diff 的計算方法為：<br>diff[0] &#x3D; nums[0]<br>diff[i] &#x3D; nums[i] - nums[i-1] (i &gt; 0) </p><hr><p>以上圖來看，原陣列 nums 是 [8, 2, 6, 3, 1]：<br>diff[0] &#x3D; 8<br>diff[1] &#x3D; nums[1] - nums[0] &#x3D; 8 - 2 &#x3D; -6<br>diff[2] &#x3D; nums[2] - nums[1] &#x3D; 6 - 2 &#x3D; 4<br>…<br>diff &#x3D; [8, -6, 4, -3, -2]</p><p>有注意到嗎？每個 diff 記錄的是「這個位置與上個位置的差異」。紀錄差異而不記錄實際數值，將會幫助我們更容易的更新整個區間。</p><h3 id="區間的更新"><a href="#區間的更新" class="headerlink" title="區間的更新"></a>區間的更新</h3><p>在建立完輔助陣列 diff 後，若要對原陣列 nums 在區間 [L, R] 內的所有元素加上 X，則執行：<br>diff[L] +&#x3D; X（標記從 L 開始增加 X）<br>diff[R+1] -&#x3D; X（標記從 R+1 開始減少 X）</p><p>最終透過前綴和來還原結果：<br>nums[i] &#x3D; nums[i-1] + diff[i]</p><hr><p>以上圖來看，若我們想在 [1, 3] 之間的所有元素增加 2：<br>diff[1] +&#x3D; 2<br>diff[3] -&#x3D; 2<br>diff &#x3D; [8, -4, 4, -5, -2]</p><p>透過前綴和還原的結果為：<br>nums2 &#x3D; [8, 4, 8, 3, 1]</p><p>相比原本的結果：<br>nums &#x3D; [8, 2, 6, 3, 1]</p><p>是不是很神奇！</p><ul><li><a href="https://labuladong.online/algo/data-structure/diff-array/">小而美的算法技巧：差分陣列</a></li></ul><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/car-pooling/description/">1094. Car Pooling</a></li><li><a href="https://leetcode.com/problems/corporate-flight-bookings/description/">1109. Corporate Flight Bookings</a></li></ul><h2 id="單調堆疊-佇列（Monotonic-Stack-Queue）"><a href="#單調堆疊-佇列（Monotonic-Stack-Queue）" class="headerlink" title="單調堆疊&#x2F;佇列（Monotonic Stack&#x2F;Queue）"></a>單調堆疊&#x2F;佇列（Monotonic Stack&#x2F;Queue）</h2><p>單調堆疊和單調佇列是處理數列問題的工具，與一般的堆疊&#x2F;佇列類似，但差異是我們在遍歷陣列時，會持續保持堆疊&#x2F;佇列裡面的元素「有規律地排序」，比如從小到大或從大到小，而那些不符合順序的會將其剔除，並拿來做我們需要的運算。</p><p>一般來說，比較常使用到的是單調堆疊，因此在 Leetcode 上也比較有機會看到。單調佇列的概念基本上差不多，只差在移除元素的方法與應用情景不同。</p><!-- ![image](https://hackmd.io/_uploads/rypgyhjgkx.png) --><!-- - [演算法筆記系列 — Monotonic Stack/Queue](https://medium.com/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98%E7%B3%BB%E5%88%97-monotonic-stack-queue-5ad1c35a3dfe) --><h3 id="單調堆疊（Monotonic-Stack）"><a href="#單調堆疊（Monotonic-Stack）" class="headerlink" title="單調堆疊（Monotonic Stack）"></a>單調堆疊（Monotonic Stack）</h3><p>覺得上面有點複雜的話，我們可以來看看以下的例子：</p><h4 id="單調遞增堆疊（Monotonically-Increasing-Stack）"><a href="#單調遞增堆疊（Monotonically-Increasing-Stack）" class="headerlink" title="單調遞增堆疊（Monotonically Increasing Stack）"></a>單調遞增堆疊（Monotonically Increasing Stack）</h4><p><img src="https://hackmd.io/_uploads/r1gLZiqBye.png" alt="image"><br>在遞增的情境下，我們遍歷原始陣列，並將元素加入堆疊中。但若新加入的元素比堆疊頂端的元素還小，我們就將頂端元素取出，再做一次檢查，重複執行直到「單調遞增」的性質被滿足為止。</p><h4 id="單調遞減堆疊（Monotonically-Decreasing-Stack）"><a href="#單調遞減堆疊（Monotonically-Decreasing-Stack）" class="headerlink" title="單調遞減堆疊（Monotonically Decreasing Stack）"></a>單調遞減堆疊（Monotonically Decreasing Stack）</h4><p><img src="https://hackmd.io/_uploads/ByJw-ocByl.png" alt="image"></p><h4 id="單調堆疊的應用"><a href="#單調堆疊的應用" class="headerlink" title="單調堆疊的應用"></a>單調堆疊的應用</h4><p>單調堆疊的主要應用是快速處理「最近相關」的問題，特別是數列中每個元素的上一個&#x2F;下一個更大值&#x2F;更小值。</p><p>假設數列 value &#x3D; [6, 2, 5, 7]，求每個數的「下一個更大值」。</p><ul><li>初始化：<ul><li>stack &#x3D; [] # (index, value) of element</li><li>result &#x3D; [-1, -1, -1, -1] # next greater element</li></ul></li><li>遍歷：<ul><li>6: stack &#x3D; [(0, 6)], result &#x3D; [-1, -1, -1, -1]</li><li>2: stack &#x3D; [(0, 6), (1, 2)], result &#x3D; [-1, -1, -1, -1]</li><li>5: stack &#x3D; [(0, 6), (2, 5)], result &#x3D; [-1, 5, -1, -1]<ul><li>Remove (1, 2) (value[1] &#x3D; 2 &lt; value[2] &#x3D; 5)</li><li>result[1] &#x3D; value[2] &#x3D; 5</li></ul></li><li>7: stack &#x3D; [(3, 7)], result &#x3D; [7, 5, 7, -1]<ul><li>Remove (2, 5) (value[2] &#x3D; 5 &lt; value[3] &#x3D; 7)</li><li>result[2] &#x3D; value[3] &#x3D; 7</li><li>Remove (0, 6) (value[0] &#x3D; 6 &lt; value[3] &#x3D; 7)</li><li>result[0] &#x3D; value[3] &#x3D; 7</li></ul></li></ul></li><li>結果：[7, 5, 7, -1]</li></ul><ul><li><a href="https://haogroot.com/2020/09/01/monotonic-stack-leetcode/">參考：Monotonic Stack – 陪你刷題</a></li></ul><h4 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h4><ul><li><a href="https://leetcode.com/problems/trapping-rain-water/description/">42. Trapping Rain Water</a></li><li><a href="https://leetcode.com/problems/next-greater-element-i/description/">496. Next Greater Element I</a></li><li><a href="https://leetcode.com/problems/daily-temperatures/description">739. Daily Temperatures</a></li></ul><h3 id="單調佇列（Monotonic-Queue）"><a href="#單調佇列（Monotonic-Queue）" class="headerlink" title="單調佇列（Monotonic Queue）"></a>單調佇列（Monotonic Queue）</h3><p>與單調堆疊類似，但單調佇列不是嚴格意義上的佇列。單調佇列允許從兩端移除元素，與一般佇列的只能進先出不同，這麼做的好處是方便我們處理特定的問題。</p><h4 id="單調佇列的應用"><a href="#單調佇列的應用" class="headerlink" title="單調佇列的應用"></a>單調佇列的應用</h4><p><img src="https://hackmd.io/_uploads/Syq69Jsrkg.png" alt="image"><br>單調隊列的主要用途是處理「滑動窗口」問題。滑動窗口是指在數列中一段固定範圍內進行計算，像找最大值或最小值。</p><p>假設數列 value &#x3D; [3, 2, -3, -1, 0]，求各個滑動窗口（k &#x3D; 3）的最大值。</p><ul><li>初始化：<ul><li>queue &#x3D; [] # (index, value) of element</li><li>result &#x3D; [] # sliding window maximum</li></ul></li><li>遍歷：<ul><li>[3, 2, -3]: queue &#x3D; [(0, 3), (1, 2), (2, -3)], result &#x3D; [3]<ul><li>The value of queue is monotonic</li><li>Add value[0] &#x3D; 3 to result</li></ul></li><li>[2, -3, -1]: queue &#x3D; [(1, 2), (3, -1)], result &#x3D; [3, 2]<ul><li>Remove (2, -3) (value[2] &#x3D; -3 &lt; value[3] &#x3D; -1)</li><li>Remove (0, -3) (exceeding boundary)</li><li>Add value[1] &#x3D; 2 to result</li></ul></li><li>[-3, -1, 0]: queue &#x3D; [(4, 0)], result &#x3D; [3, 1, 0]<ul><li>Remove (3, -1) (value[3] &#x3D; -1 &lt; value[4] &#x3D; 0)</li><li>Add (4, 0) in queue for this round</li><li>Remove 1 for exceeding boundary</li><li>Add value[4] &#x3D; 0 to result</li></ul></li></ul></li><li>結果：[3, 2, 0]</li></ul><ul><li><a href="https://bengersay.com/sliding-window-maximum/">參考：Sliding Window Maximum – Monotonic queue 的應用</a></li></ul><h4 id="Leetcode-2"><a href="#Leetcode-2" class="headerlink" title="Leetcode"></a>Leetcode</h4><ul><li><a href="https://leetcode.com/problems/sliding-window-maximum/">239. Sliding Window Maximum</a></li></ul><h3 id="為什麼一個可以從兩端移除，一個只能從一端？"><a href="#為什麼一個可以從兩端移除，一個只能從一端？" class="headerlink" title="為什麼一個可以從兩端移除，一個只能從一端？"></a>為什麼一個可以從兩端移除，一個只能從一端？</h3><p>為什麼會有這樣的差異？</p><ul><li>單調堆疊（Monotonic Stack）：<ul><li>資料的處理是單方向的（例如從左到右或從右到左）。</li><li>只有最近加入的元素是相關的，因此僅需從頂部彈出即可。</li></ul></li><li>單調隊列（Monotonic Queue）：<ul><li>資料是動態處理的，通常涉及一個範圍（例如滑動視窗）。</li><li>兩端的元素都可能變得不相關：前端的元素可能因為超出視窗範圍而需要移除，而後端的元素可能因違反單調性而需要移除。</li></ul></li></ul><p>單調堆疊與單調佇列算是比較進階與特殊的資料結構，平常我們並不會常常使用，但在某些情況下，他們的單調性質可以很好的幫我們解決特定問題，因此也是值得學習的主題。</p>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (9) - 圖的進階議題</title>
      <link href="/2025/06/10/dsa-tutorial-9/"/>
      <url>/2025/06/10/dsa-tutorial-9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h2 id="圖的進階議題（Advanced-Topic-on-Graph）"><a href="#圖的進階議題（Advanced-Topic-on-Graph）" class="headerlink" title="圖的進階議題（Advanced Topic on Graph）"></a>圖的進階議題（Advanced Topic on Graph）</h2><h3 id="最短路徑（Shortest-Path）"><a href="#最短路徑（Shortest-Path）" class="headerlink" title="最短路徑（Shortest Path）"></a>最短路徑（Shortest Path）</h3><p>最短路徑問題（Shortest Path Problem）是圖論中的一個重要課題，目的是尋找從一個起始節點到其他節點的最短路徑。相關的應用像是地圖中的導航系統、網路路由選擇等等，背後都是使用最短路徑的演算法。</p><ul><li><a href="https://web.ntnu.edu.tw/~algo/Path.html">path - 演算法筆記</a></li></ul><h4 id="戴克斯特拉演算法（Dijkstra’s-Algorithm）"><a href="#戴克斯特拉演算法（Dijkstra’s-Algorithm）" class="headerlink" title="戴克斯特拉演算法（Dijkstra’s Algorithm）"></a>戴克斯特拉演算法（Dijkstra’s Algorithm）</h4><p><img src="https://hackmd.io/_uploads/HyE20njxJx.png" alt="image"></p><p>戴克斯特拉演算法是一種廣泛使用的方法，特別適用於權重非負的有向圖和無向圖，通過不斷選擇<strong>當前距離最小的未訪問節點</strong>，並更新其所有相鄰節點的最短距離，來尋找從起始節點到其他所有節點的最短路徑。</p><p>特別要注意的是，若存在負權重的邊，則戴克斯特拉演算法就不再適用。為什麼？讓我們看看以下的圖：<br><img src="https://hackmd.io/_uploads/BkrsVKGb1e.png" alt="image"><br>你想到原因了嗎？在這張圖中，使用戴克斯特拉演算法會發生什麼事情？</p><ul><li><a href="https://medium.com/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98/%E5%9F%BA%E7%A4%8E%E6%BC%94%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97-graph-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87dijkstras-algorithm-6134f62c1fc2">基礎演算法系列 — Graph 資料結構與 Dijkstra’s Algorithm</a></li><li><a href="https://graphicmaths.com/computer-science/graph-theory/dijkstras-algorithm/">Visualization of Above Example</a></li></ul><h4 id="Bellman–Ford-Algorithm"><a href="#Bellman–Ford-Algorithm" class="headerlink" title="Bellman–Ford Algorithm"></a>Bellman–Ford Algorithm</h4><p>相較於戴克斯特拉演算法，Bellman–Ford Algorithm 可以用在含有負權重邊的情況，是一種能處理負權重邊的最短路徑演算法。</p><p>Bellman–Ford 的核心步驟是反覆對所有邊做 Relaxation（檢查是否可以利用某條邊縮短當前已知的最短路徑距離，若可以則更新），經過 V−1 次 Relaxation 的操作後（V 為節點數），可以找到從起點到其他所有節點的最短路徑。</p><p>雖然可以處理包含負權重邊的圖，但圖中不能存在負權重環（總和為負的環）。為什麼？</p><blockquote><p>若圖中存在負權重環，我們可以一直在這個環中不斷遍歷，就會造成最短路徑變為負無限大。<br>反過來說，若在 V−1 次放鬆後，還有可以縮短的路徑，則代表該圖中存在負權重環，因此最短路徑不存在。<br>因此，Bellman–Ford 不僅適用於包含負權重邊的圖，還可以檢測負權重環。</p></blockquote><ul><li><a href="https://ithelp.ithome.com.tw/articles/10209748">[演算法] 最短路徑 (Bellman-Ford 演算法)</a></li></ul><h4 id="Floyd-Warshall-Algorithm"><a href="#Floyd-Warshall-Algorithm" class="headerlink" title="Floyd-Warshall Algorithm"></a>Floyd-Warshall Algorithm</h4><p>Floyd-Warshall 演算法用於解決所有點對最短路徑問題（All-Pairs Shortest Paths Problem），是一種基於動態規劃的方法。與 Dijkstra 和 Bellman-Ford 不同的是，Floyd-Warshall 可以計算算任意兩個節點之間的最短路徑。</p><p>其主要的想法是：假設我們要從節點 i 到節點 j 找最短路徑，若能經由中間節點 k 獲得更短的距離，那麼我們就更新該最短路徑。用遞迴公式表示如下：$d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j])$。因此我們總共需要做 V 次更新，每次都檢查各點對之間的距離是否有更佳解。</p><ul><li><a href="https://ithelp.ithome.com.tw/articles/10209186">[演算法] 最短路徑 (Floyd-Warshall 演算法)</a></li></ul><h4 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h4><ul><li><a href="https://leetcode.com/problems/network-delay-time/description/">743. Network Delay Time</a></li><li><a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/">1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</a></li></ul><!-- - [787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/description/) --><hr><h3 id="生成樹（Spanning-Tree）"><a href="#生成樹（Spanning-Tree）" class="headerlink" title="生成樹（Spanning Tree）"></a>生成樹（Spanning Tree）</h3><ul><li><a href="https://web.ntnu.edu.tw/~algo/SpanningTree.html">演算法筆記：Spanning Tree</a></li></ul><p>從一張圖取出一棵樹，樹上可以連接圖上所有點，就稱為該圖的生成樹，一個圖可能有不只一種生成樹。</p><p><img src="https://hackmd.io/_uploads/S1zbFo8eC.png" alt="image"></p><h4 id="最小生成樹（Minimum-Cost-Spanning-Tree）"><a href="#最小生成樹（Minimum-Cost-Spanning-Tree）" class="headerlink" title="最小生成樹（Minimum Cost Spanning Tree）"></a>最小生成樹（Minimum Cost Spanning Tree）</h4><p>顧名思義，最小生成樹就是最小的生成樹，這邊的最小指的是「連接所有節點所需的花費（所有邊的花費總和）最小」。</p><p>以下為兩個常見且易懂的貪婪演算法，來尋找圖中的最小生成樹：</p><h5 id="Kruskal’s-algorithm"><a href="#Kruskal’s-algorithm" class="headerlink" title="Kruskal’s algorithm"></a>Kruskal’s algorithm</h5><p>不斷從所有邊裡面選花費最小的邊，並判斷加入此邊可否連通兩個不同的 Component，直到所有的節點都被相連。（以所有邊作為每輪檢查的對象）</p><h5 id="Prim’s-Algorithm"><a href="#Prim’s-Algorithm" class="headerlink" title="Prim’s Algorithm"></a>Prim’s Algorithm</h5><p>選定一個起點，挑選與其連接的邊中，花費最小且可連接兩個不同 Component 的相連，再把新連接的所有邊加入下一輪的檢查。其精神與 Dijkstra’s Algorithm 有幾分類似。（以目前相連的點包含的所有邊，作為每輪檢查的對象）</p><blockquote><p>備註：也有所謂的最大生成樹，概念一模一樣</p></blockquote><h4 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h4><ul><li><a href="https://leetcode.com/problems/min-cost-to-connect-all-points/description">1584. Min Cost to Connect All Points</a></li></ul><hr><h3 id="有向無環圖（Directed-Acyclic-Graph）與拓樸排序（Topological-Sorting）"><a href="#有向無環圖（Directed-Acyclic-Graph）與拓樸排序（Topological-Sorting）" class="headerlink" title="有向無環圖（Directed Acyclic Graph）與拓樸排序（Topological Sorting）"></a>有向無環圖（Directed Acyclic Graph）與拓樸排序（Topological Sorting）</h3><ul><li><a href="https://web.ntnu.edu.tw/~algo/DirectedAcyclicGraph.html">演算法筆記：DAG</a></li></ul><p>有向無環圖（Directed Acyclic Graph）又稱 DAG，顧名思義，是有方向且不包含環的 Graph。</p><p>拓樸排序（Topological Sorting）是一種將 DAG 中的所有節點排序的方式，使得每條有向邊的排序符合其方向性（舉例來說：u-&gt;v-&gt;w 的拓樸排序為 [u, v, w]）。因為 DAG 之中不會有環，故只要是 DAG 則必能找到一個拓樸排序。</p><p><img src="https://hackmd.io/_uploads/B1txFj8gR.png" alt="image"></p><p>以下介紹一個在 DAG 中尋找拓樸排序的方法：</p><h4 id="Kahn’s-Algorithm"><a href="#Kahn’s-Algorithm" class="headerlink" title="Kahn’s Algorithm"></a>Kahn’s Algorithm</h4><p>透過找出圖中的 in-degree 為零的節點，逐步移除這些節點，並同時更新圖的 in-degree，從而達到拓樸排序。</p><ul><li>若所有節點皆能被移除，則移除順序即為拓樸排序</li><li>若無法移除所有節點，則代表圖中有環（因此此圖不會是 DAG）</li></ul><h4 id="Leetcode-2"><a href="#Leetcode-2" class="headerlink" title="Leetcode"></a>Leetcode</h4><ul><li><a href="https://leetcode.com/problems/course-schedule/description/">207. Course Schedule</a></li><li><a href="https://leetcode.com/problems/course-schedule-ii/description/">210. Course Schedule II</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (8) 字串比對、位元運算、雙重指標</title>
      <link href="/2025/06/10/dsa-tutorial-8/"/>
      <url>/2025/06/10/dsa-tutorial-8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h2 id="字串比對（String-Matching）"><a href="#字串比對（String-Matching）" class="headerlink" title="字串比對（String Matching）"></a>字串比對（String Matching）</h2><h3 id="KMP-演算法"><a href="#KMP-演算法" class="headerlink" title="KMP 演算法"></a>KMP 演算法</h3><p><img src="https://hackmd.io/_uploads/ry2SjfO4C.png" alt="image"></p><p>KMP 演算法是一種用於字串搜尋的高效方法。透過建立部分配對表（最長的相同前後綴），可以快速定位搜尋字串中的可能配對位置，減少不必要的重複比較，從而加速搜尋過程。</p><p>KMP 演算法其實相對複雜且較難實作，我個人認為有大概理解概念就好，實際上也很少遇到需要直接實作該演算法的情境。</p><ul><li><a href="https://yeefun.github.io/kmp-algorithm-for-beginners/">初學者學 KMP 演算法</a><blockquote><p>補充：<a href="https://medium.com/@c.s.fangyolk/kmp-%E6%BC%94%E7%AE%97%E6%B3%95-%E5%BE%9E%E8%87%AA%E5%AD%B8%E5%88%B0%E6%94%BE%E6%A3%84-1-7f71e65839a0">KMP algorithm，從自學到放棄 (1)</a><br>補充：<a href="https://medium.com/@c.s.fangyolk/kmp-%E6%BC%94%E7%AE%97%E6%B3%95-%E5%BE%9E%E8%87%AA%E5%AD%B8%E5%88%B0%E6%94%BE%E6%A3%84-2-94dda22f80b2">KMP algorithm，從自學到放棄 (2)</a><br>補充：<a href="https://web.ntnu.edu.tw/~algo/Substring.html">演算法筆記：substring</a><br>補充：<a href="https://cmps-people.ok.ubc.ca/ylucet/DS/KnuthMorrisPratt.html">KMP Visualization</a></p></blockquote></li></ul><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. Find the Index of the First Occurrence in a String</a></li></ul><h2 id="位元運算（Bit-Manipulation）"><a href="#位元運算（Bit-Manipulation）" class="headerlink" title="位元運算（Bit Manipulation）"></a>位元運算（Bit Manipulation）</h2><p><img src="https://hackmd.io/_uploads/HyHM0lpLR.png" alt="image"></p><p>Bit manipulation 是在電腦中用「位元」（bit）來進行操作的技巧，這種技巧常在程式設計競賽或像 Leetcode 這樣的題目中出現。位元是電腦中最基本的單位，由 0 或 1 組成，這跟開關一樣，只有開或關的狀態。這些 0 與 1 會再經由<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二進位制</a>與<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8">二補數</a>的方式，組成所有的其他數字。常見的位元操作有：AND, OR, XOR, NOT, Shift 等等，參考以下：<br><img src="https://hackmd.io/_uploads/HkgbJHIDR.png" alt="image"></p><ul><li><a href="https://hackmd.io/@apcser/H14FONT4n?utm_source=preview-mode&utm_medium=rec">Python 的位元運算</a></li></ul><h3 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/power-of-two/description/">231. Power of Two</a></li><li><a href="https://leetcode.com/problems/missing-number/description/">268. Missing Number</a></li><li><a href="https://leetcode.com/problems/minimum-bit-flips-to-convert-number/description/">2220. Minimum Bit Flips to Convert Number</a></li></ul><h2 id="雙重指標（Two-Pointers）"><a href="#雙重指標（Two-Pointers）" class="headerlink" title="雙重指標（Two Pointers）"></a>雙重指標（Two Pointers）</h2><p><img src="https://hackmd.io/_uploads/BkqW-uvkyl.png" alt="image"><br>常用於陣列當中，用兩個指標指著不同的位置，與滑動視窗（Sliding Window）有異曲同工之妙，兩者基本上是相同技巧。</p><h3 id="快慢指標（Fast-Slow-Pointers）"><a href="#快慢指標（Fast-Slow-Pointers）" class="headerlink" title="快慢指標（Fast &amp; Slow Pointers）"></a>快慢指標（Fast &amp; Slow Pointers）</h3><p>此種技巧為雙重指標的特殊版本，使用一快一慢的指標（一次走不同步數 or 一個先走一個後走），常用在 Linked List 當中。</p><p>這樣可以幹嘛呢？我們來看看以下的例子：</p><h4 id="尋找中點"><a href="#尋找中點" class="headerlink" title="尋找中點"></a>尋找中點</h4><p><img src="https://hackmd.io/_uploads/H1c7bdv1Jl.png" alt="image"></p><h4 id="判斷-Cycle-是否存在-Linked-List-中"><a href="#判斷-Cycle-是否存在-Linked-List-中" class="headerlink" title="判斷 Cycle 是否存在 Linked List 中"></a>判斷 Cycle 是否存在 Linked List 中</h4><p><img src="https://hackmd.io/_uploads/HkLZzOPJJg.png" alt="image"><br><img src="https://hackmd.io/_uploads/Byf5Wdv11e.png" alt="image"></p><h4 id="尋找倒數第-K-個節點"><a href="#尋找倒數第-K-個節點" class="headerlink" title="尋找倒數第 K 個節點"></a>尋找倒數第 K 個節點</h4><p><img src="https://hackmd.io/_uploads/ry3NMVU8yx.png" alt="image"></p><ul><li><a href="https://medium.com/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98%E7%B3%BB%E5%88%97-two-pointer-%E8%88%87sliding-window-8742f45f3f55">演算法筆記系列 — Two Pointer 與Sliding Window</a></li></ul><h3 id="Leetcode-2"><a href="#Leetcode-2" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/sort-colors/">75. Sort Colors</a></li><li><a href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></li><li><a href="https://leetcode.com/problems/middle-of-the-linked-list/">876. Middle of the Linked List</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (7) - 分治法、動態規劃、前綴和</title>
      <link href="/2025/06/10/dsa-tutorial-7/"/>
      <url>/2025/06/10/dsa-tutorial-7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h2 id="分治法（Divide-and-Conquer）"><a href="#分治法（Divide-and-Conquer）" class="headerlink" title="分治法（Divide-and-Conquer）"></a>分治法（Divide-and-Conquer）</h2><p><img src="https://hackmd.io/_uploads/r1NtDxTUR.png" alt="image"></p><p>Divide-and-Conquer又稱為分治法。其中 Divide 指的是將一個較大的問題不斷切割成小問題。而 Conquer 是當最後切割成的小問題簡單到可以直接解決，就可以組合成大問題的答案。在程式語言中時常都會用到分治法的觀念，並結合遞迴的概念求解。</p><blockquote><p>Source: <a href="https://hackmd.io/@rd2865OAQZSLjri24DYcow/HkmNAB4aO">分而治之法與遞迴關係</a></p></blockquote><p>還記得之前教過的 Merge Sort 嗎？（合併排序法：將陣列不斷細分，再將細分後的結果兩兩合併。）其實 Merge Sort 的精神本質上就是 Divide-and-Conquer！</p><ul><li><a href="https://jumperc2p.github.io/InformisTry/posts/ithome-triathlon/dicon-ms/">【舌尖上的演算法】Day15 – Divide and Conquer - Merge Sort</a></li></ul><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><!-- - [105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/)- [106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/) --><ul><li><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/">108. Convert Sorted Array to Binary Search Tree</a></li><li><a href="https://leetcode.com/problems/sort-list/description/">148. Sort List</a></li></ul><h2 id="動態規劃（Dynamic-Programming）"><a href="#動態規劃（Dynamic-Programming）" class="headerlink" title="動態規劃（Dynamic Programming）"></a>動態規劃（Dynamic Programming）</h2><p><img src="https://hackmd.io/_uploads/SkqV4HbSR.png" alt="image"></p><p><strong>Dynamic Programming &#x3D; Divide-and-Conquer + Memoization</strong></p><p>動態規劃是一種解決問題的方法，它將大問題拆解成小問題（Divide-and-Conquer），並記錄每個小問題的解答（Memoization），以便後續使用。這樣做能夠節省計算時間，讓我們更有效地解決問題，針對某些「透過前面答案來計算後面答案的問題」特別有用。</p><ul><li>推薦閱讀：<a href="https://web.ntnu.edu.tw/~algo/DynamicProgramming.html">演算法筆記：DP</a></li></ul><h3 id="Recursion-v-s-Dynamic-Programming"><a href="#Recursion-v-s-Dynamic-Programming" class="headerlink" title="Recursion v.s. Dynamic Programming?"></a>Recursion v.s. Dynamic Programming?</h3><p>我們來看看這題（Leetcode <a href="https://leetcode.com/problems/fibonacci-number/description/">509. Fibonacci Number</a>）：</p><ul><li>費波納契數列<br>  給定輸入整數n，輸出第 n 項費波納契數列<br>  舉例：n &#x3D; 8，輸出為 21 (1 1 2 3 5 8 13 21)</li></ul><p>Recursion 寫法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Recursion</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci_recursive</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fibonacci_recursive(n - <span class="number">1</span>) + fibonacci_recursive(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>Dynamic Programming 寫法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dynamic Programming</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci_dp</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        fib = [<span class="number">0</span>, <span class="number">1</span>] + [-<span class="number">1</span>] * (n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> fib[n]</span><br></pre></td></tr></table></figure><h4 id="時間複雜度分析"><a href="#時間複雜度分析" class="headerlink" title="時間複雜度分析"></a>時間複雜度分析</h4><p>接著我們來測量一下他們的速度差異：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;遞迴方法耗時: %.6f 秒&quot;</span>%(timeit.timeit(<span class="keyword">lambda</span>: fibonacci_recursive(<span class="number">30</span>),number=<span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;動態規劃方法耗時: %.6f 秒&quot;</span>%(timeit.timeit(<span class="keyword">lambda</span>: fibonacci_dp(<span class="number">30</span>),number=<span class="number">1</span>)))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">遞迴方法耗時: 1.373473 秒</span><br><span class="line">動態規劃方法耗時: 0.000012 秒</span><br></pre></td></tr></table></figure><p>為什麼會差這麼多呢？我們來分析看看兩種方法的時間複雜度：</p><ul><li><p>遞迴版本<br>時間複雜度：$O(2^n)$。對於每個 fibonacci_recursive(n)，它會呼叫 fibonacci_recursive(n-1) 和 fibonacci_recursive(n-2)，這種重複計算會導致呼叫函數的次數呈指數級數增長，因此時間複雜度為 $O(2^n)$。</p></li><li><p>動態規劃版本<br>時間複雜度：$O(n)$。它只需要計算一次每個費氏數列的值，並將結果存入列表中。迴圈從 2 執行到 n，所以時間複雜度為 $O(n)$。</p></li></ul><p>對於較小的 n，遞迴可能更簡單易懂，並且兩者的速度可能相差不大。但是當 n 較大時，遞迴所需的時間會嚴重惡化，相較之下動態規劃會有更好的效能表現。</p><p>看到上述兩者的時間複雜度差異之大，是不是發現動態規劃的強大了？</p><h3 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h3><!-- - [62. Unique Paths](https://leetcode.com/problems/unique-paths/description/) --><ul><li><a href="(https://leetcode.com/problems/unique-paths-ii/description/)">63. Unique Paths II</a></li><li><a href="https://leetcode.com/problems/minimum-path-sum/description/">64. Minimum Path Sum</a></li><li><a href="https://leetcode.com/problems/climbing-stairs/description/">70. Climbing Stairs</a></li><li><a href="https://leetcode.com/problems/house-robber/description/">198. House Robber</a></li></ul><!-- ### 動態規劃經典問題：背包問題（Knapsack Problem） --><blockquote><p>延伸閱讀：<a href="https://web.ntnu.edu.tw/~algo/KnapsackProblem.html">演算法筆記：Knapsack Problem</a></p></blockquote><h2 id="前綴和（Prefix-Sum）"><a href="#前綴和（Prefix-Sum）" class="headerlink" title="前綴和（Prefix Sum）"></a>前綴和（Prefix Sum）</h2><p><img src="https://hackmd.io/_uploads/HJHhReT8R.png" alt="image"><br>前綴和是一種用來快速計算數列中某一段連續元素的總和的技巧。它的概念是先建立一個新的數列，其中每個元素代表原數列從開頭到該位置的和。這樣一來，當我們需要計算某段範圍的總和時，只要用前綴和數列中對應位置的值相減，就能快速得出答案。</p><p>舉例來說，假設有一個數列 <code>A=[2, 3, 5, 7]</code>，我們可以建立前綴和數列 <code>P=[0, 2, 5, 10, 17]</code>。如果想知道從第2到第4個元素的總和（即 <code>A[2] + A[3] + A[4]</code>），只要計算 <code>P[4] − P[1]</code>，就可以得到總和 15。建立數列的過程中可以搭配動態規劃的技巧一起使用。</p><ul><li><a href="https://huangmayor0905.github.io/cs/algo/prefix-sum/">【演算法】前綴和（Prefix Sum）</a></li></ul><h3 id="Leetcode-2"><a href="#Leetcode-2" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/find-pivot-index/description/">724. Find Pivot Index</a></li><li><a href="https://leetcode.com/problems/sum-of-all-odd-length-subarrays/description/">1588. Sum of All Odd Length Subarrays</a></li></ul><blockquote><p>延伸閱讀：<a href="https://hackmd.io/@bangyewu/rJRpH9dhh">Python-LeetCode 581 第四招 前綴和 Prefix Sum</a><br>延伸閱讀：<a href="https://hackmd.io/@wiwiho/CPN-segment-tree">線段樹</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (6) - 暴力法、貪婪演算法、回溯法</title>
      <link href="/2025/06/10/dsa-tutorial-6/"/>
      <url>/2025/06/10/dsa-tutorial-6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h1 id="其他演算法與常見解題技巧"><a href="#其他演算法與常見解題技巧" class="headerlink" title="其他演算法與常見解題技巧"></a>其他演算法與常見解題技巧</h1><p>演算法（Algorithm）是在有限的步驟之內，提供明確的法則，求出問題正確答案的程序。它可以是一種方法、法則或者程序，讓資料可按照預先設計的方式處理。</p><ul><li><a href="https://hackmd.io/@howkii-studio/Bkf-2DQiw/https%3A%2F%2Fhackmd.io%2F%40howkii-studio%2Falgorithm">認識演算法</a></li><li>推薦補充閱讀：<a href="https://web.ntnu.edu.tw/~algo/">演算法筆記</a><ul><li><a href="https://web.ntnu.edu.tw/~algo/AlgorithmDesign.html">Algorithm Design</a></li></ul></li></ul><h2 id="暴力法（Brute-Force）"><a href="#暴力法（Brute-Force）" class="headerlink" title="暴力法（Brute Force）"></a>暴力法（Brute Force）</h2><p>暴力法（Brute Force）是一種基本的解題策略，透過系統地嘗試所有可能的解決方案來找出答案。它的原理很簡單：列舉所有可能性，不斷嘗試，直到找到符合要求的解。</p><p>這種方法的優點是實現簡單，且保證能找到存在的解。但它的效率通常較低，特別是在處理大規模問題時，因此暴力法常用於簡單問題或作為其他算法的比較基準。</p><p>以下補充幾個以前教過，但其實都跟暴力法有關的演算法。</p><blockquote><p>補充：<a href="https://jumperc2p.github.io/InformisTry/posts/ithome-triathlon/brute_force_selection_sort/">【舌尖上的演算法】Day6 – Brute Force - Selection Sort</a><br>補充：<a href="https://jumperc2p.github.io/InformisTry/posts/ithome-triathlon/brute_force_bubble_sort/">【舌尖上的演算法】Day7 – Brute Force - Bubble Sort</a><br>補充：<a href="https://jumperc2p.github.io/InformisTry/posts/ithome-triathlon/brute_force_knapsack/">【舌尖上的演算法】Day8 – Brute Force - Knapsack</a><br>補充：<a href="https://jumperc2p.github.io/InformisTry/posts/ithome-triathlon/brute_force_dfs_bfs/">【舌尖上的演算法】Day9 – Brute Force - DFS &amp; BFS</a></p></blockquote><h2 id="貪婪演算法（Greedy-Method）"><a href="#貪婪演算法（Greedy-Method）" class="headerlink" title="貪婪演算法（Greedy Method）"></a>貪婪演算法（Greedy Method）</h2><p><img src="https://hackmd.io/_uploads/SkFiTx6U0.png" alt="image"></p><p>貪婪演算法（Greedy Method）是一種在每一步都做出當前最佳選擇的問題解決策略。它通過在每個決策點選擇局部最優解，希望最終能達到整體最優解。</p><p>貪婪演算法的主要特點：</p><ol><li>在每一步選擇當前看起來最好的選項</li><li>一旦做出選擇，就不會回頭重新考慮</li><li>期望這些局部最優選擇能導致整體最優解</li></ol><p>這種演算法通常簡單高效，適用於某些特定問題，然而它並不總是能得到最佳解決方案。貪婪演算法的優勢在於易於實現和速度快，但可能會錯過需要前瞻性思考或回溯的更優解。</p><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/assign-cookies/description/">455. Assign Cookies</a></li><li><a href="https://leetcode.com/problems/bag-of-tokens/description/">948. Bag of Tokens</a></li></ul><!-- - [2037. Minimum Number of Moves to Seat Everyone](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/description/) --><h2 id="回溯法（Backtracking）"><a href="#回溯法（Backtracking）" class="headerlink" title="回溯法（Backtracking）"></a>回溯法（Backtracking）</h2><p><img src="https://hackmd.io/_uploads/Bkad6xpLC.png" alt="image"></p><p>回溯法（Backtracking）也是暴力法的一種，特別適用於需要窮舉所有可能性的情況。</p><p>回溯法的基本思想是:</p><ol><li>從一個可能的起點開始。</li><li>按照問題要求，逐步向前探索。</li><li>如果發現當前路徑無法得到有效解，就退回到上一步。</li><li>在上一步選擇一個不同的方向繼續探索。</li><li>重複這個過程，直到找到解或者探索完所有可能性。</li></ol><p>回溯法的優點是能夠系統地搜索所有可能性，缺點是在最壞情況下可能需要很長的運行時間。這種方法像是在迷宮中探路：如果碰到死路，就退回到上一個路口，選擇另一條路繼續前進。</p><ul><li><a href="https://medium.com/appworks-school/%E9%80%B2%E5%85%A5%E9%81%9E%E8%BF%B4-recursion-%E7%9A%84%E4%B8%96%E7%95%8C-%E4%B8%89-d2fd70b5b171">一次看懂遞迴 (Recursion) 的思維模式（三）- 窮舉可能性（Backtracking）</a></li></ul><h3 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/">17. Letter Combinations of a Phone Number</a></li><li><a href="https://leetcode.com/problems/permutations/description/">46. Permutations</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (5) - 雜湊表、字典樹、並查集</title>
      <link href="/2025/06/10/dsa-tutorial-5/"/>
      <url>/2025/06/10/dsa-tutorial-5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h2 id="雜湊表（Hash-Table）"><a href="#雜湊表（Hash-Table）" class="headerlink" title="雜湊表（Hash Table）"></a>雜湊表（Hash Table）</h2><p><img src="https://hackmd.io/_uploads/r1cQCHKMa.png"></p><h3 id="雜湊函數的性質"><a href="#雜湊函數的性質" class="headerlink" title="雜湊函數的性質"></a>雜湊函數的性質</h3><p>雜湊函式是一種把輸入數據轉換成固定長度的字符串（雜湊值）的工具。它有以下特點：</p><ul><li>固定長度輸出：無論輸入數據有多長，輸出都是固定長度。</li><li>無法回推：從雜湊值無法反推出原始輸入（即單向性），保證了數據的不可逆性。</li><li>抗碰撞性：難以找到兩個不同的輸入有相同的雜湊值。</li><li>快速計算：能快速生成雜湊值。</li></ul><p><img src="https://hackmd.io/_uploads/ByQ3G5S7R.png" alt="image"><br><img src="https://hackmd.io/_uploads/S1vaz9S7A.png" alt="image"><br><img src="https://hackmd.io/_uploads/ByaTfqrXA.png" alt="image"></p><ul><li><a href="https://ithelp.ithome.com.tw/articles/10208884">[資料結構] 雜湊 (Hash)</a></li></ul><blockquote><p>Images are from <a href="https://homuchen.com/posts/what-is-hash-function-its-properties-and-usages/">什麼是Hash Function? 有什麼特性及用途?</a> </p></blockquote><h3 id="雜湊函數的應用"><a href="#雜湊函數的應用" class="headerlink" title="雜湊函數的應用"></a>雜湊函數的應用</h3><ul><li>資料完整性驗證：確保收到的資料是完整的，或確保文件未被篡改。</li><li>密碼儲存：儲存密碼的雜湊值，而不是明文密碼，提高安全性。常見的加密方式如 MD5、SHA-256 等等，若有興趣可以再研究密碼學。</li><li>資料結構：用於實現雜湊表，能夠快速存取資料。使用雜湊函數的常見資料結構包含集合（Set）、字典（Dictionary）等等。</li><li>數位簽章：保護資料完整性和驗證身份。</li></ul><blockquote><p>補充：<a href="https://zh.wikipedia.org/zh-tw/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">雜湊函數 - 維基百科</a></p></blockquote><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/group-anagrams/description/">49. Group Anagrams</a></li><li><a href="https://leetcode.com/problems/first-unique-character-in-a-string/description/">387. First Unique Character in a String</a></li><li><a href="https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/description/">2441. Largest Positive Integer That Exists With Its Negative</a></li></ul><!-- - [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/description/) --><h2 id="字典樹（Prefix-Tree-Trie）"><a href="#字典樹（Prefix-Tree-Trie）" class="headerlink" title="字典樹（Prefix Tree &#x2F; Trie）"></a>字典樹（Prefix Tree &#x2F; Trie）</h2><p><img src="https://hackmd.io/_uploads/BJdBwzXIR.png" alt="image"><br>以 N-ary Tree 的方式來表示一個字典，好處是當彼此有共同前綴（Common Prefix）時可以增加儲存與查找效率，常用於搜尋時的自動補字。</p><ul><li><a href="https://hackmd.io/@TienYi/trie">Trie（字典樹）</a></li></ul><p>實作上的話就跟正常的 N-ary Tree 差不多，可以使用 Dictionary 這種 key-value 的 Pair 來協助，同時要記得加註每個字結束的位置。以下為搭配<code>collections.defaultdict</code> 的 Trie 實作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        nested_ddict = <span class="keyword">lambda</span>: defaultdict(nested_ddict)</span><br><span class="line">        self.tree = nested_ddict()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        curr_tree = self.tree</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            curr_tree = curr_tree[c]</span><br><span class="line">        curr_tree[<span class="string">&#x27;END&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_search_tool</span>(<span class="params">self, dest: <span class="built_in">str</span></span>) -&gt; <span class="built_in">tuple</span>[<span class="built_in">bool</span>, defaultdict]:</span><br><span class="line">        curr_tree = self.tree</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> dest:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> curr_tree:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span>, defaultdict()</span><br><span class="line">            curr_tree = curr_tree[c]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>, curr_tree</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        status, curr_tree = self._search_tool(word)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> status:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="string">&#x27;END&#x27;</span> <span class="keyword">in</span> curr_tree <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startsWith</span>(<span class="params">self, prefix: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        status, curr_tree = self._search_tool(prefix)</span><br><span class="line">        <span class="keyword">return</span> status</span><br></pre></td></tr></table></figure><h3 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h3><!-- - [14. Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix/description/) --><ul><li><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">208. Implement Trie (Prefix Tree)</a></li></ul><!-- - [676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/description/) --><h2 id="並查集（Disjoint-Set-Union-Find）"><a href="#並查集（Disjoint-Set-Union-Find）" class="headerlink" title="並查集（Disjoint Set &#x2F; Union Find）"></a>並查集（Disjoint Set &#x2F; Union Find）</h2><p><img src="https://hackmd.io/_uploads/ry305yeWA.png" alt="image"><br>由多個彼此沒有交集的 Set 組成，常用在需要分組與合併的情境中。</p><ul><li><a href="https://haogroot.com/2021/01/29/union_find-leetcode/">Union-Find &#x2F; Disjoint-Set – 陪你刷題</a></li></ul><p>一個包含路徑壓縮，並以 rank (size of set) 來作為 union 依據的 Union-Find 資料結構，大概會是如下的形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UF</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, N</span>):</span><br><span class="line">        self.parent = <span class="built_in">list</span>(<span class="built_in">range</span>(N))</span><br><span class="line">        self.size = [<span class="number">1</span>] * N</span><br><span class="line">        self.count = N</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        rootX = self.find(x)</span><br><span class="line">        rootY = self.find(y)</span><br><span class="line">        <span class="keyword">if</span> rootX != rootY:</span><br><span class="line">            self.count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.size[rootX] &lt; self.size[rootY]:</span><br><span class="line">                self.parent[rootX] = rootY</span><br><span class="line">                self.size[rootY] += self.size[rootX]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.parent[rootY] = rootX</span><br><span class="line">                self.size[rootX] += self.size[rootY]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">while</span> self.parent[x] != x:</span><br><span class="line">            self.parent[x] = self.parent[self.parent[x]]</span><br><span class="line">            x = self.parent[x]</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h3 id="Leetcode-2"><a href="#Leetcode-2" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/number-of-islands/description/">200. Number of Islands</a></li><li><a href="https://leetcode.com/problems/number-of-provinces/description/">547. Number of Provinces</a></li><li><a href="https://leetcode.com/problems/find-if-path-exists-in-graph/description/">1971. Find if Path Exists in Graph</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (4) - 矩陣、堆積、優先佇列</title>
      <link href="/2025/06/10/dsa-tutorial-4/"/>
      <url>/2025/06/10/dsa-tutorial-4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h2 id="矩陣（Matrix）"><a href="#矩陣（Matrix）" class="headerlink" title="矩陣（Matrix）"></a>矩陣（Matrix）</h2><p><img src="https://hackmd.io/_uploads/SyxulaZA6.png" alt="image"></p><p>在介紹 Graph 的表示方法時，我們提到了兩種不同的表示方式，分別是鄰接串列（Adjacency List）與鄰接矩陣（Adjacency Matrix）。不過其實，矩陣本身也可以被當作一種資料結構來使用，舉凡像是迷宮、地圖等等具有 2D 性質的資料型態，都可以使用矩陣來表示。</p><p>Matrix 的相關操作其實都與 Graph 差不多，不外乎就是在 Matrix 中進行搜尋或遍歷，但因為我們可以以 $O(1)$ 的複雜度，直接取用 Matrix 內部中的任一元素（<code>matrix[row][col]</code>），所以 Matrix 在某些應用上具有較為快速的優勢。那接著就讓我們直接實戰演練吧！</p><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/number-of-islands/description/">200. Number of Islands</a></li><li><a href="https://leetcode.com/problems/rotting-oranges/description/">994. Rotting Oranges</a></li><li><a href="https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description/">1351. Count Negative Numbers in a Sorted Matrix</a></li></ul><h2 id="堆積（Heap）"><a href="#堆積（Heap）" class="headerlink" title="堆積（Heap）"></a>堆積（Heap）</h2><p><img src="https://hackmd.io/_uploads/BJqGCStzT.png"><br>一種具有特殊性質（Parent Node 大於或小於 Child Node）的 Complete Binary Tree。</p><h3 id="堆積排序法-Heap-Sort"><a href="#堆積排序法-Heap-Sort" class="headerlink" title="堆積排序法(Heap Sort)"></a>堆積排序法(Heap Sort)</h3><ul><li><a href="https://notepad.yehyeh.net/Content/Algorithm/Sort/Heap/Heap.php">[演算法(Algorithm)] 堆積排序法(Heap Sort)</a></li></ul><p>對陣列做 Heapify 變成 Max Heap，再不斷把最大值往後擺。</p><blockquote><p>練習：試著實作 Heap Sort 吧！</p></blockquote><h2 id="優先佇列（Priority-Queue）"><a href="#優先佇列（Priority-Queue）" class="headerlink" title="優先佇列（Priority Queue）"></a>優先佇列（Priority Queue）</h2><p><img src="https://hackmd.io/_uploads/S1CWOylZ0.png" alt="image"><br>具有優先權（Priority）來代表其進出順序的 Queue。</p><ul><li><a href="https://alrightchiu.github.io/SecondRound/priority-queueintrojian-jie.html">Priority Queue：Intro(簡介)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/priority-queuebinary-heap.html">Priority Queue：Binary Heap</a></li></ul><h3 id="Stack-Queue-v-s-Priority-Queue"><a href="#Stack-Queue-v-s-Priority-Queue" class="headerlink" title="Stack &#x2F; Queue v.s. Priority Queue?"></a>Stack &#x2F; Queue v.s. Priority Queue?</h3><p>Stack 與 Queue 其實可以被視作特殊狀況的 Priority Queue：</p><ul><li>Stack：加入 Priority Queue 的 Priority 是嚴格遞增的<ul><li>因此最後加入的元素 Priority 最高，會先被丟出 Stack</li></ul></li><li>Queue：加入 Priority Queue 的 Priority 是嚴格遞減的<ul><li>因此最先加入的元素 Priority 最高，會先被丟出 Queue</li></ul></li></ul><!-- In a stack, the priority of each inserted element is monotonically increasing; thus, the last element inserted is always the first retrieved. In a queue, the priority of each inserted element is monotonically decreasing; thus, the first element inserted is always the first retrieved. --><h3 id="Priority-Queue-v-s-Heap"><a href="#Priority-Queue-v-s-Heap" class="headerlink" title="Priority Queue v.s. Heap?"></a>Priority Queue v.s. Heap?</h3><ul><li>Priority Queue：一種<strong>抽象資料類別</strong>，著重的點是描述這個資料類別應該具有甚麼性質與操作方法，不直接討論實作方法。</li><li>Heap：一種<strong>資料結構</strong>，著重的點在以特定的結構儲存資料。</li></ul><p>因為他們具有類似的性質，所以用 Heap 的結構來實作 Priority Queue 這個資料類別，可以說是非常適合，也因此乍看之下他們好像是一樣的東西。但兩者概念上有些微不同，亦可以用其他方式來實做  Priority Queue。</p><blockquote><p>補充：<a href="https://stackoverflow.com/a/18993313/15894431">Difference between priority queue and a heap</a><br>補充：<a href="https://stackoverflow.com/questions/36991716/whats-the-difference-between-heapq-and-priorityqueue-in-python">What’s the difference between heapq and PriorityQueue in python?</a></p></blockquote><h2 id="Heap-Priority-Queue-in-Python-heapq"><a href="#Heap-Priority-Queue-in-Python-heapq" class="headerlink" title="Heap &#x2F; Priority Queue in Python: heapq"></a>Heap &#x2F; Priority Queue in Python: heapq</h2><ul><li><a href="https://docs.python.org/zh-tw/3.10/library/heapq.html">Python heapq</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heap = [<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">heapq.heapify(heap)</span><br><span class="line">heapq.heappush(heap, <span class="number">2</span>)</span><br><span class="line">_ = heapq.heappop(heap)</span><br><span class="line">_ = heapq.heappushpop(heap, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># Will not modify the heap (but inefficient)</span></span><br><span class="line">klargest = heapq.nlargest(k, heap)</span><br><span class="line">ksmallest = heapq.nsmallest(k, heap)</span><br><span class="line"><span class="comment"># Use heap as priority queue</span></span><br><span class="line">nodes = [(<span class="number">5</span>, <span class="string">&#x27;A&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>), (<span class="number">9</span>, <span class="string">&#x27;C&#x27;</span>)]</span><br><span class="line">heap = []</span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">    heapq.heappush(heap, (node[<span class="number">0</span>], node[<span class="number">1</span>])) <span class="comment"># (priority, value)</span></span><br></pre></td></tr></table></figure><h3 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/description/">703. Kth Largest Element in a Stream</a></li><li><a href="https://leetcode.com/problems/last-stone-weight/description/">1046. Last Stone Weight</a></li><li><a href="https://leetcode.com/problems/furthest-building-you-can-reach/description/">1642. Furthest Building You Can Reach</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (3) - 樹、圖</title>
      <link href="/2025/06/10/dsa-tutorial-3/"/>
      <url>/2025/06/10/dsa-tutorial-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h2 id="樹（Tree）"><a href="#樹（Tree）" class="headerlink" title="樹（Tree）"></a>樹（Tree）</h2><p><img src="https://hackmd.io/_uploads/S13npBFMp.png"><br>基本單位為 Node，且只有一個 Node 是 Root（無人指向的 Node），且不存在任何 Cycle。每個 Node 可以指向多個 Child。</p><ul><li><a href="https://alrightchiu.github.io/SecondRound/treeshu-introjian-jie.html">Tree(樹): Intro(簡介)</a></li></ul><h3 id="二元樹（Binary-Tree）"><a href="#二元樹（Binary-Tree）" class="headerlink" title="二元樹（Binary Tree）"></a>二元樹（Binary Tree）</h3><p><img src="https://hackmd.io/_uploads/SJQuAds7a.png" alt="image"><br>當樹中的每個 Node 都只有兩個 Child，即為 Binary Tree。</p><ul><li><a href="https://alrightchiu.github.io/SecondRound/binary-tree-introjian-jie.html">Binary Tree: Intro(簡介)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/binary-tree-traversalxun-fang.html">Binary Tree: Traversal(尋訪)</a><br>  以上面的 Binary Tree 為例：<ul><li>Pre-Order Traversal: ABDECFG</li><li>In-Order Traversal: DBEAFCG</li><li>Post-Order Traversal: DEBFGCA<br>  <img src="https://hackmd.io/_uploads/rJEw81ajp.png" alt="image"><blockquote><p>延伸閱讀：<a href="https://alrightchiu.github.io/SecondRound/binary-tree-jian-li-yi-ke-binary-tree.html">Binary Tree: 建立一棵Binary Tree</a></p></blockquote></li></ul></li></ul><h3 id="二元搜尋樹（Binary-Search-Tree）"><a href="#二元搜尋樹（Binary-Search-Tree）" class="headerlink" title="二元搜尋樹（Binary Search Tree）"></a>二元搜尋樹（Binary Search Tree）</h3><p><img src="https://hackmd.io/_uploads/rJ5d1tom6.png" alt="image"><br>若一個二元樹中，所有 Node 都滿足 Node.left.value &lt; Node.value &lt; Node.right.value，就稱為二元搜尋樹。二元搜尋樹有良好的排序特質，可以幫助我們找到想要的資料。</p><ul><li><a href="https://alrightchiu.github.io/SecondRound/binary-search-tree-introjian-jie.html">Binary Search Tree: Intro(簡介)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/binary-search-tree-searchsou-xun-zi-liao-insertxin-zeng-zi-liao.html">Binary Search Tree: Search(搜尋資料)、Insert(新增資料)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/binary-search-tree-sortpai-xu-deleteshan-chu-zi-liao.html">Binary Search Tree: Sort(排序)、Delete(刪除資料)</a><blockquote><p>注意：在 Binary Search Tree 上做 In-Order Traversal，即可得到排序好的資料！</p></blockquote></li></ul><h3 id="進階-紅黑樹（Red-Black-Tree）"><a href="#進階-紅黑樹（Red-Black-Tree）" class="headerlink" title="進階 - 紅黑樹（Red Black Tree）"></a>進階 - 紅黑樹（Red Black Tree）</h3><p>紅黑樹是一種進階的 BST（Binary Search Tree），透過將每個節點塗上紅色或黑色，並在新增或刪除資料時進行適當的結構調整（旋轉子樹），可以維持 BST 的高度不會相差太多，進而在搜尋時能有較好的效率。細節太過複雜這邊暫時跳過，之後有時間 or 有興趣再回來講。</p><p><img src="https://hackmd.io/_uploads/HyclMKj7p.png" alt="image"></p><ul><li><a href="https://alrightchiu.github.io/SecondRound/red-black-tree-introjian-jie.html">Red Black Tree: Intro(簡介)</a><blockquote><p>延伸閱讀：</p><ul><li><a href="https://alrightchiu.github.io/SecondRound/red-black-tree-rotationxuan-zhuan.html">Red Black Tree: Rotation(旋轉)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/red-black-tree-insertxin-zeng-zi-liao-yu-fixupxiu-zheng.html">Red Black Tree: Insert(新增資料)與Fixup(修正)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/red-black-tree-deleteshan-chu-zi-liao-yu-fixupxiu-zheng.html">Red Black Tree: Delete(刪除資料)與Fixup(修正)</a></li></ul></blockquote></li></ul><h3 id="進階-AVL-樹（AVL-Tree）"><a href="#進階-AVL-樹（AVL-Tree）" class="headerlink" title="進階 - AVL 樹（AVL Tree）"></a>進階 - AVL 樹（AVL Tree）</h3><p><img src="https://hackmd.io/_uploads/r1GAdTXt6.png" alt="image"><br>AVL Tree 是一種 Binary search tree 實做方式，大部分的實做方式與 BST 一樣，差異在於 AVL tree 在過程中會透過計算並調整樹的結構來讓樹維持平衡，而不會導致 BST 過度傾斜(不平衡），與紅黑樹的目標類似。細節太過複雜這邊暫時跳過，之後有時間 or 有興趣再回來講。</p><blockquote><p>延伸閱讀：<a href="https://josephjsf2.github.io/data/structure/and/algorithm/2019/06/22/avl-tree.html">資料結構與演算法：AVL Tree</a></p></blockquote><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><h4 id="Basic-Traversal-Search"><a href="#Basic-Traversal-Search" class="headerlink" title="Basic - Traversal &amp; Search"></a>Basic - Traversal &amp; Search</h4><p>Please try to use both recursion and stack&#x2F;queue to solve problem 102 and 144. (Hint: For 102(Level-Order) you should use <strong>Queue</strong>, for 144(Pre-Order) you should use <strong>Stack</strong>)</p><ul><li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/">94. Binary Tree Inorder Traversal</a></li><li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/">102. Binary Tree Level Order Traversal</a></li><li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/">144. Binary Tree Preorder Traversal</a></li><li><a href="https://leetcode.com/problems/binary-tree-postorder-traversal/description/">145. Binary Tree Postorder Traversal</a></li><li><a href="https://leetcode.com/problems/search-in-a-binary-search-tree/description/">700. Search in A Binary Search Tree</a></li></ul><h4 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h4><ul><li><a href="https://leetcode.com/problems/same-tree/description/">100. Same Tree</a></li><li><a href="https://leetcode.com/problems/invert-binary-tree/description/">226. Invert Binary Tree</a></li><li><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/">530. Minimum Absolute Difference in BST</a></li><li><a href="https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/">1026. Maximum Difference Between Node and Ancestor</a></li><li><a href="https://leetcode.com/problems/even-odd-tree/description">1609. Even Odd Tree</a></li></ul><h4 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h4><ul><li><a href="https://eniac00.github.io/btv/">BT Visualizer</a></li></ul><h2 id="圖（Graph）"><a href="#圖（Graph）" class="headerlink" title="圖（Graph）"></a>圖（Graph）</h2><p><img src="https://hackmd.io/_uploads/S1v-AHFM6.png"><br>圖比樹的限制更少，給定一群節點與相連的邊，即可稱為圖。邊可以分為有向與無向，節點之間的連結並沒有限制，也因此圖並不像樹有 root、parent、siblings、height 等等屬性，且有可能會有 cycle 的出現。</p><h3 id="Graph-Tree-的比較"><a href="#Graph-Tree-的比較" class="headerlink" title="Graph &amp; Tree 的比較"></a>Graph &amp; Tree 的比較</h3><p><img src="https://hackmd.io/_uploads/HkvhyNtf6.png"><br>Tree 可以被看成一種特殊的 Graph，就像 Binary Tree 是一種特殊的 Tree 一樣。</p><h3 id="Graph-的表示法"><a href="#Graph-的表示法" class="headerlink" title="Graph 的表示法"></a>Graph 的表示法</h3><p><img src="https://hackmd.io/_uploads/H1otPi8gA.png" alt="image"></p><ul><li><a href="https://alrightchiu.github.io/SecondRound/graph-introjian-jie.html">Graph: Intro(簡介)</a></li></ul><h3 id="Graph-的搜尋"><a href="#Graph-的搜尋" class="headerlink" title="Graph 的搜尋"></a>Graph 的搜尋</h3><p><img src="https://hackmd.io/_uploads/r1Ef-7Pnp.png" alt="image"><br>最常見、也最常使用的搜尋方法有兩種：BFS 與 DFS。兩者的差異在於搜尋的優先順序不同，並且分別可以使用 Queue 與 Stack 來實作。</p><h4 id="廣度優先搜尋（Breadth-First-Search-BFS）"><a href="#廣度優先搜尋（Breadth-First-Search-BFS）" class="headerlink" title="廣度優先搜尋（Breadth First Search, BFS）"></a>廣度優先搜尋（Breadth First Search, BFS）</h4><ul><li><a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/">Breadth First Search or BFS for a Graph</a></li></ul><h4 id="深度優先搜尋（Depth-First-Search-DFS）"><a href="#深度優先搜尋（Depth-First-Search-DFS）" class="headerlink" title="深度優先搜尋（Depth First Search, DFS）"></a>深度優先搜尋（Depth First Search, DFS）</h4><ul><li><a href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/">Depth First Search or DFS for a Graph</a></li></ul><h4 id="那-DFS-與-BFS-可以應用在-Tree-上嗎？"><a href="#那-DFS-與-BFS-可以應用在-Tree-上嗎？" class="headerlink" title="那 DFS 與 BFS 可以應用在 Tree 上嗎？"></a>那 DFS 與 BFS 可以應用在 Tree 上嗎？</h4><p>因為 Tree 也是 Graph 的一種，所以當然可以，而且非常常用！</p><blockquote><p>延伸閱讀：<a href="https://stackoverflow.com/a/57598470/15894431">DFS、BFS 與 Pre-Order、In-Order、Post-Order、Level-Order 的關係</a></p></blockquote><h3 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/clone-graph/description/">133. Clone Graph</a></li><li><a href="https://leetcode.com/problems/all-paths-from-source-to-target/description/">797. All Paths From Source to Target</a></li><li><a href="https://leetcode.com/problems/keys-and-rooms/">841. Keys and Rooms</a></li><li><a href="https://leetcode.com/problems/find-the-town-judge/description/">997. Find the Town Judge</a></li></ul><hr><h4 id="在圖中找環（Cycle）"><a href="#在圖中找環（Cycle）" class="headerlink" title="在圖中找環（Cycle）"></a>在圖中找環（Cycle）</h4><p>上面的兩個例子中，都使用 <code>visited</code> 來紀錄該節點是否被拜訪過。因此，在<strong>無向圖</strong>中，若我們下一個要拜訪的節點的 <code>visited</code> 為 <code>True</code>，那我們就可以知道該圖中有環的存在。那在<strong>有向圖</strong>中呢？以下圖來說：<br><img src="https://hackmd.io/_uploads/rkSj6pq0a.png" alt="image"><br>若我們在右邊的有向圖 b 中，用相同的 DFS 來尋找是否有環，假設第一次尋訪的路徑為 (1,2,4,5)，而第二次尋訪退回到 2 並往下尋訪 (3,4)，我們這時候會發現 <code>visited[4] == True</code>，並且判定該圖有環，但實際上是沒有的。那我們該怎麼做呢？</p><p>在往下看之前，先自己想想看喔！</p><hr><p>答案：使用三個不同的值來表示每個節點不同的尋訪狀態（黑、白、灰）。黑色代表已經完成搜尋，白色代表還沒搜尋過，灰色代表正在這條 path 上搜尋，等搜尋完成後就會改為黑色。因此，若我們搜尋時遇到灰色節點，就可以知道該圖存在 cycle！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Determine if a directed graph is acyclic</span></span><br><span class="line"><span class="comment"># True: Acyclic; False: Cyclic</span></span><br><span class="line">graph = ... <span class="comment"># adjacency list representation</span></span><br><span class="line">N = <span class="built_in">len</span>(graph)</span><br><span class="line">visited = [<span class="number">0</span>] * N</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">checkNoCycle</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> visited[node] == -<span class="number">1</span>: <span class="comment"># gray, currently visiting</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> visited[node] == <span class="number">1</span>: <span class="comment"># black, done visiting</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># white, not visited yet (visited[node] == 0)</span></span><br><span class="line">        visited[node] = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dfs(neighbor):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        visited[node] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(node)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>補充：<a href="https://cs.stackexchange.com/questions/9676/the-purpose-of-grey-node-in-graph-depth-first-search">The purpose of grey node in graph depth-first search</a></p></blockquote><h3 id="連通分量（Connected-Components）"><a href="#連通分量（Connected-Components）" class="headerlink" title="連通分量（Connected Components）"></a>連通分量（Connected Components）</h3><p><img src="https://hackmd.io/_uploads/r1EGVkc-A.png" alt="image"><br><img src="https://hackmd.io/_uploads/BkStEJ9WR.png" alt="ConnectedComponent4"></p><ul><li><a href="https://web.ntnu.edu.tw/~algo/ConnectedComponent.html">Connected Component - 演算法筆記</a></li><li><a href="https://www.cnblogs.com/RioTian/p/14026585.html">Strongly Connected Components - Kosaraju 演算法</a></li></ul><blockquote><p>補充：<a href="https://www.geeksforgeeks.org/connected-components-in-an-undirected-graph/">Connected Components in an Undirected Graph</a><br>補充：<a href="https://www.geeksforgeeks.org/strongly-connected-components/">Strongly Connected Components</a><br>補充：<a href="https://hackmd.io/@erichung0906/HkjZBH_IK">Tarjan 演算法與 Kosaraju 演算法</a></p></blockquote><h3 id="Leetcode-2"><a href="#Leetcode-2" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/course-schedule/description/">207. Course Schedule</a></li><li><a href="https://leetcode.com/problems/find-if-path-exists-in-graph/description/">1971. Find if Path Exists in Graph</a></li></ul><blockquote><p>延伸閱讀：</p><ul><li><a href="https://alrightchiu.github.io/SecondRound/graph-breadth-first-searchbfsguang-du-you-xian-sou-xun.html">Graph: Breadth-First Search(BFS，廣度優先搜尋)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/graph-depth-first-searchdfsshen-du-you-xian-sou-xun.html">Graph: Depth-First Search(DFS，深度優先搜尋)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/graph-li-yong-dfshe-bfsxun-zhao-connected-component.html">Graph: 利用DFS和BFS尋找Connected Component</a></li><li><a href="https://alrightchiu.github.io/SecondRound/graph-li-yong-dfsxun-zhao-strongly-connected-componentscc.html">Graph: 利用DFS尋找Strongly Connected Component(SCC)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/graph-li-yong-dfsxun-zhao-dagde-topological-sorttuo-pu-pai-xu.html">Graph: 利用DFS尋找DAG的Topological Sort(拓撲排序)</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (2) - 陣列、鏈結串列、堆疊、佇列</title>
      <link href="/2025/06/10/dsa-tutorial-2/"/>
      <url>/2025/06/10/dsa-tutorial-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><h1 id="資料結構（Data-Structure）"><a href="#資料結構（Data-Structure）" class="headerlink" title="資料結構（Data Structure）"></a>資料結構（Data Structure）</h1><p>資料結構是一種設計、組織、儲存資料的方式，以實現最佳性能和效率。這些結構包含不同形式，像是陣列、鍊結列表、樹、圖等等。選擇適當的資料結構對於解決特定的問題至關重要，不同的資料結構可以用於不同的應用，並且可以極大地影響程序的運行時間和記憶體使用。</p><h2 id="陣列（Array）"><a href="#陣列（Array）" class="headerlink" title="陣列（Array）"></a>陣列（Array）</h2><p><img src="https://hackmd.io/_uploads/SJJ_pSKMa.png"><br>可隨機存取的一串連續記憶體位址。</p><ul><li><a href="https://notfalse.net/15/array-intro">陣列 (Array) 簡介</a><blockquote><p>補充：<a href="https://michaeliscoding.com/lists-are-arrays-in-python/">List Are Arrays in Python</a></p></blockquote></li></ul><h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array</a></li><li><a href="https://leetcode.com/problems/remove-element/description/">27. Remove Element</a></li></ul><h2 id="鏈結串列（Linked-List）"><a href="#鏈結串列（Linked-List）" class="headerlink" title="鏈結串列（Linked List）"></a>鏈結串列（Linked List）</h2><p><img src="https://hackmd.io/_uploads/HkbKTHFG6.png"><br>元素間彼此串聯在一起，形成一條鍊子的資料結構。<br><img src="https://hackmd.io/_uploads/SkxzAOjQp.png" alt="image"><br>也可以是上圖雙向連結的形式。</p><ul><li><a href="https://alrightchiu.github.io/SecondRound/linked-list-introjian-jie.html">Linked List：Intro(簡介)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/linked-list-xin-zeng-zi-liao-shan-chu-zi-liao-fan-zhuan.html">Linked List：新增資料、刪除資料、反轉</a></li></ul><h3 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul><li><a href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a></li><li><a href="https://leetcode.com/problems/swap-nodes-in-pairs/">24. Swap Nodes in Pairs</a></li><li><a href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List</a></li></ul><h2 id="堆疊（Stack-Last-In-First-Out-LIFO）"><a href="#堆疊（Stack-Last-In-First-Out-LIFO）" class="headerlink" title="堆疊（Stack, Last-In-First-Out, LIFO）"></a>堆疊（Stack, Last-In-First-Out, LIFO）</h2><p><img src="https://hackmd.io/_uploads/BkdcTSFMp.png"><br>單向進出，後進先出的資料結構，如同把東西堆疊起來。</p><ul><li><a href="https://alrightchiu.github.io/SecondRound/stack-introjian-jie.html">Stack: Intro(簡介)</a></li><li><a href="https://alrightchiu.github.io/SecondRound/stack-yi-arrayyu-linked-listshi-zuo.html">Stack: 以Array與Linked list實作</a></li><li><a href="https://alrightchiu.github.io/SecondRound/stack-neng-gou-zai-o1qu-de-zui-xiao-zhi-de-minstack.html">Special Application: Min Stack</a></li></ul><h2 id="佇列（Queue-First-In-First-Out-FIFO）"><a href="#佇列（Queue-First-In-First-Out-FIFO）" class="headerlink" title="佇列（Queue, First-In-First-Out, FIFO）"></a>佇列（Queue, First-In-First-Out, FIFO）</h2><p><img src="https://hackmd.io/_uploads/H1tjpHFM6.png"><br>單向進出，先進先出的資料結構，如同在排隊一般。</p><ul><li><a href="https://alrightchiu.github.io/SecondRound/queue-introjian-jie-bing-yi-linked-listshi-zuo.html">Queue: Intro(簡介)，並以Linked list實作</a></li><li><a href="https://alrightchiu.github.io/SecondRound/queue-yi-arrayshi-zuo-queue.html">Queue: 以Array實作Queue</a></li></ul><h2 id="Stack-Queue-in-Python-Collections-deque"><a href="#Stack-Queue-in-Python-Collections-deque" class="headerlink" title="Stack &amp; Queue in Python: Collections.deque()"></a>Stack &amp; Queue in Python: Collections.deque()</h2><p>Deque（發音類似 Deck）為 Double-Ended Queue 的縮寫，顧名思義，Deque 是一個支援雙向存取的 Queue，也就是說，你可以從頭跟尾插入或移除元素。</p><ul><li><a href="https://docs.python.org/zh-tw/3/library/collections.html#collections.deque">官方說明文件</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">D = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">D.append(<span class="number">4</span>)</span><br><span class="line">D.appendleft(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(D[<span class="number">2</span>], D)</span><br><span class="line"><span class="built_in">print</span>(D.pop(), D)</span><br><span class="line"><span class="built_in">print</span>(D.popleft(), D)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">2 deque([0,1,2,3,4])</span><br><span class="line">4 deque([0,1,2,3])</span><br><span class="line">0 deque([1,2,3])</span><br></pre></td></tr></table></figure><p>Q：那他與 Stack 跟 Queue 有甚麼關係呢？</p><blockquote><p>A：<br>Stack: 只使用 D.append() 與 D.pop() 的 deque<br>Queue: 只使用 D.append() 與 D.popleft() 的 deque</p><p>其實只要符合 Stack 跟 Queue 的性質都可以。<br>因此以下使用方式也對，但較不建議使用：<br>Stack: 只使用 D.appendleft() 與 D.popleft() 的 deque<br>Queue: 只使用 D.appendleft() 與 D.pop() 的 deque</p></blockquote><p>以下為使用 collections.deque 來實作 stack 與 queue 的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="comment"># For Stack, you can only use the following operations</span></span><br><span class="line">S = deque()</span><br><span class="line"><span class="comment"># push from a stack:</span></span><br><span class="line">S.append(val)</span><br><span class="line"><span class="comment"># pop from a stack:</span></span><br><span class="line">val = S.pop()</span><br><span class="line"><span class="comment"># peek from a stack:</span></span><br><span class="line">top = S[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># check size of a stack:</span></span><br><span class="line">size = <span class="built_in">len</span>(S)</span><br><span class="line"><span class="comment"># check stack is empty:</span></span><br><span class="line">isEmpty = (size == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =========================================</span></span><br><span class="line"><span class="comment"># For Queue, you can only use the following operations</span></span><br><span class="line">Q = deque()</span><br><span class="line"><span class="comment"># push from a queue: </span></span><br><span class="line">Q.append(val)</span><br><span class="line"><span class="comment"># pop from a queue:</span></span><br><span class="line">val = Q.popleft()</span><br><span class="line"><span class="comment"># peek from a queue:</span></span><br><span class="line">top = Q[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># check size of a queue:</span></span><br><span class="line">size = <span class="built_in">len</span>(Q)</span><br><span class="line"><span class="comment"># check queue is empty:</span></span><br><span class="line">isEmpty = (size == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>另外也可以參考 Python 官方對 <a href="https://docs.python.org/zh-tw/3/tutorial/datastructures.html#using-lists-as-stacks">將 List 作為 Stack &#x2F; Queue 使用</a> 的說明。</p><p>介紹完 collections.deque() 以後，讓我們來實際練習一下 Leetcode 的題目吧！</p><h3 id="Leetcode-2"><a href="#Leetcode-2" class="headerlink" title="Leetcode"></a>Leetcode</h3><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><ul><li><a href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses</a></li><li><a href="https://leetcode.com/problems/min-stack/description/">155. Min Stack</a></li><li><a href="https://leetcode.com/problems/implement-queue-using-stacks/">232. Implement Queue using Stacks</a></li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul><li><a href="https://leetcode.com/problems/implement-stack-using-queues/">225. Implement Stack using Queues</a></li><li><a href="https://leetcode.com/problems/flatten-nested-list-iterator/">341. Flatten Nested List Iterator</a></li><li><a href="https://leetcode.com/problems/first-unique-character-in-a-string/">387. First Unique Character in a String</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>資料結構與演算法教學系列文 (1) - 概述、排序、搜尋、時間複雜度</title>
      <link href="/2025/06/10/dsa-tutorial-1/"/>
      <url>/2025/06/10/dsa-tutorial-1/</url>
      
        <content type="html"><![CDATA[<p>哈囉！久違又來更新教學文系列了，這次的主題是在學完基礎程式設計後，一定也需要會的東西：資料結構與演算法。若你對程式設計還不太熟悉，或是想回去複習一下 Python 或 C++，可以參考我下面的系列文：</p><ul><li><a href="https://jackchen890311.github.io/categories/Python-%E6%95%99%E5%AD%B8/">Python 教學</a> </li><li><a href="https://jackchen890311.github.io/categories/C-%E6%95%99%E5%AD%B8/">C++ 教學</a></li></ul><p>這個系列文應該會很長，因為 DSA（i.e. Data Structure and Algorithm）這個主題是在是涵蓋太多東西了，甚至我寫的內容也沒有到很完整。這次的來源一樣是拿來做家教講義，文字部分不會太詳盡，有需要更詳盡的內容歡迎聯絡我，如果我有空就可以幫你上課 XD。</p><p>最後就是轉載請記得標註來源，這裡面的內容都是作者本人收集的心血！</p><p><a href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p><p><img src="https://hackmd.io/_uploads/Sy7FTNHea.png"></p><h1 id="入門介紹"><a href="#入門介紹" class="headerlink" title="入門介紹"></a>入門介紹</h1><ul><li><a href="https://google.github.io/styleguide/pyguide.html">Google Coding Style</a></li><li><a href="https://jason-chen-1992.weebly.com/home/-whats-algorithm">甚麼是演算法？</a></li><li><a href="https://hackmd.io/@Aquamay/H1nxBOLcO/https%3A%2F%2Fhackmd.io%2F%40Aquamay%2Frk1C8ni5d">甚麼是資料結構？</a></li></ul><p>來複習一下學習地圖，以臺大資工系必修為例：<br><img src="https://i.imgur.com/Y2AdRO3.png"><br>以臺大資管系必修為例：<br><img src="https://i.imgur.com/aC9lfrs.png"></p><p>而在演算法與資料結構的世界裡面，大概又可以分為以下幾種類別。在我們之後的課程中，會逐漸的介紹每個名詞以及其對應概念：<br><img src="https://hackmd.io/_uploads/BkmCHf7UR.png" alt="image"></p><p>相關連結：</p><ul><li><a href="https://blog.algomaster.io/p/how-i-mastered-data-structures-and-algorithms">How to master DSA</a></li><li><a href="https://labuladong.online/algo/home/">labuladong 的算法筆記</a></li><li><a href="https://alrightchiu.github.io/SecondRound/mu-lu-yan-suan-fa-yu-zi-liao-jie-gou.html">演算法與資料結構</a></li></ul><h1 id="競賽相關"><a href="#競賽相關" class="headerlink" title="競賽相關"></a>競賽相關</h1><p>適合國 &#x2F; 高中生參加的相關競賽有以下：</p><ul><li><a href="https://bebras.csie.ntnu.edu.tw/">Bebras 國際運算思維挑戰（簡單）</a></li><li><a href="https://apcs.csie.ntnu.edu.tw/">APCS（個人）</a></li><li><a href="https://issc.csroc.org.tw/">ISSC（團體）</a></li><li><a href="https://tpmso.org/toi/">TOI（資訊奧林匹亞，較難）</a></li></ul><p>建議可以向學校老師或相關社團與補習班詢問更多細節。</p><h3 id="APCS-Practice"><a href="#APCS-Practice" class="headerlink" title="APCS Practice"></a>APCS Practice</h3><ul><li><a href="https://apcs.csie.ntnu.edu.tw/index.php/info/">應試相關資訊</a><ul><li>建議每項都要讀過，特別是環境 &#x2F; 作答系統 &#x2F; 考場規則</li></ul></li></ul><h4 id="實作題"><a href="#實作題" class="headerlink" title="實作題"></a>實作題</h4><ul><li><a href="https://zerojudge.tw/Problems?tag=2025%E5%B9%B41%E6%9C%88">2025&#x2F;01 APCS</a> and <a href="https://hackmd.io/@bangyewu/rJlvXNP81g">Solution</a></li><li><a href="https://zerojudge.tw/Problems?tag=2024%E5%B9%B410%E6%9C%88">2024&#x2F;10 APCS</a> and <a href="https://hackmd.io/@bangyewu/rJ5yJqEe1x">Solution</a></li><li><a href="https://zerojudge.tw/Problems?tag=2024%E5%B9%B46%E6%9C%88">2024&#x2F;06 APCS</a> and <a href="https://hackmd.io/cn9ndy19RbKHOJKBRx4aEA">Solution</a></li><li><a href="https://zerojudge.tw/Problems?tag=2024%E5%B9%B41%E6%9C%88">2024&#x2F;01 APCS</a> and <a href="https://hackmd.io/@bangyewu/SkKxG8Oua">Solution</a></li><li><a href="https://zerojudge.tw/Problems?tag=2023%E5%B9%B410%E6%9C%88">2023&#x2F;10 APCS</a> and <a href="https://hackmd.io/@bangyewu/SkxXo4QGa">Solution</a></li><li><a href="https://zerojudge.tw/Problems?tag=2023%E5%B9%B46%E6%9C%88">2023&#x2F;06 APCS</a> and <a href="https://hackmd.io/@bangyewu/B13lefwMp">Solution</a></li><li><a href="https://zerojudge.tw/Problems?tag=APCS">All APCS Problems</a> and <a href="https://hackmd.io/@bangyewu/B13lefwMp">Solution</a> and <a href="https://yuihuang.com/apcs/">Solution 2</a></li></ul><h4 id="觀念題"><a href="#觀念題" class="headerlink" title="觀念題"></a>觀念題</h4><ul><li><a href="https://hackmd.io/@howkii-studio/apcs_overview/https%3A%2F%2Fhackmd.io%2F%40howkii-studio%2Fapcs_exercise_cs">APCS 觀念題分析系列</a></li><li><a href="https://hackmd.io/@apcser/B1N5GYEto">APCS 觀念題資源分享</a></li></ul><h4 id="相關資源"><a href="#相關資源" class="headerlink" title="相關資源"></a>相關資源</h4><ul><li>推薦：<a href="https://drive.google.com/file/d/1hX7q3wVKkLuoMhEEm7uuLjq4BuhZAEgn/view?usp=drive_link">AP325 - 從 APCS 實作題檢測三級到五級（C++）</a><ul><li><a href="https://hackmd.io/@bangyewu/Hy2kbYLI6/%2Fg2kqHh5_Q4eQnz-mfNu3Kw">AP325（Python）</a></li></ul></li><li><a href="https://www.facebook.com/groups/359446638362710/">FB Group - APCS 實作題檢測</a></li><li><a href="https://www.youtube.com/playlist?list=PLpmg1QLbgMuRQXHRkX9iDHyAVIW1D6OJF">PyAp45 Playlist - Python on APCS 四五級分</a></li></ul><h1 id="排序演算法（Sorting-Algorithms）"><a href="#排序演算法（Sorting-Algorithms）" class="headerlink" title="排序演算法（Sorting Algorithms）"></a>排序演算法（Sorting Algorithms）</h1><p><img src="https://hackmd.io/_uploads/Hk0Xhj8x0.png" alt="image"></p><p>排序演算法是一種將一組資料按照特定規則重新排列的方法。</p><p>常見的排序方法有：</p><ul><li>選擇排序法(Selection Sort)<br>每次挑最大或最小的，依序移動到對應的位置。</li><li>插入排序法(Insertion Sort)<br>照順序每次拿一個，並插入正確的位置。</li><li>氣泡排序法(Bubble Sort)<br>就像有個氣泡，兩兩比對後留下大的，每次都把最大的帶到最後面。</li><li>合併排序法(Merge Sort)<br>將陣列不斷細分，再將細分後的結果兩兩合併。</li><li>快速排序法(Quick Sort)<br>選定一個 Pivot，將比他小的丟左邊比他大的丟右邊，再針對左右兩部分進行一次相同的事情。</li></ul><p>練習：試著實作以上五種常見的 Sorting 方法吧！</p><blockquote><p><strong>推薦參考</strong>：<a href="http://notepad.yehyeh.net/Content/Algorithm/Sort/Sort.php">介紹排序演算法的網站</a><br><strong>推薦參考</strong>：<a href="https://magiclen.org/sorting-algorithm/">寫程式的基本功：排序演算法</a><br>補充：<a href="https://officeguide.cc/python-sort-sorted-tutorial-examples/">Python 中的 sorting</a>、<a href="https://shengyu7697.github.io/std-sort/">C++ 中的 sorting</a><br>補充：<a href="https://jason18153.medium.com/%E6%9C%80%E8%B2%BC%E8%BF%91%E7%8F%BE%E5%AF%A6%E7%9A%84%E6%8E%92%E5%BA%8F%E6%BC%94%E7%AE%97%E6%B3%95-timsort-a75da75b65a2">最貼近現實的排序演算法 - Timsort</a></p></blockquote><p>補充：還有一些很奇怪的排序方法，看了會覺得很傻眼又好笑。如果有興趣可以參考 <a href="https://www.youtube.com/watch?v=ktgxMtWMflU">10 Forbidden Sorting Algorithms</a> ，舉幾個例子像是：</p><ul><li>Bogo 排序法（Bogo Sort）<br>一直隨機重新排序，直到剛好符合大小順序。（猴子打字機定理）</li><li>史達林排序法（Stalin’s Sort）<br>遇到大小順序不對的就直接刪掉。（所以最後的 list 有可能比原本的短）</li></ul><h1 id="搜尋演算法（Search-Algorithms）"><a href="#搜尋演算法（Search-Algorithms）" class="headerlink" title="搜尋演算法（Search Algorithms）"></a>搜尋演算法（Search Algorithms）</h1><p><img src="https://hackmd.io/_uploads/HyNn3iIl0.png" alt="image"></p><p>搜尋演算法是一種用來在資料集中尋找特定項目的方法或步驟。</p><h2 id="適用於未排序或已排序的資料"><a href="#適用於未排序或已排序的資料" class="headerlink" title="適用於未排序或已排序的資料"></a>適用於未排序或已排序的資料</h2><h3 id="線性搜尋（Linear-Search）"><a href="#線性搜尋（Linear-Search）" class="headerlink" title="線性搜尋（Linear Search）"></a>線性搜尋（Linear Search）</h3><p>直接一項一項搜尋，直到找到要的東西為止。<br>最基本的搜尋方式，時間複雜度為 $O(N)$。</p><h2 id="僅適用於排序的資料"><a href="#僅適用於排序的資料" class="headerlink" title="僅適用於排序的資料"></a>僅適用於排序的資料</h2><p>以下的搜尋演算法，會利用資料<strong>已經排序過</strong>的性質，來加速搜尋的過程。</p><h3 id="二分搜尋（Binary-Search）"><a href="#二分搜尋（Binary-Search）" class="headerlink" title="二分搜尋（Binary Search）"></a>二分搜尋（Binary Search）</h3><p>很重要的搜尋演算法！將資料中間的與目標相比，若目標較大則往右再做一次搜尋，目標較小則往左，直到找到為止，可以參考 <a href="https://magiclen.org/binary-search/">二分搜尋法教學</a> 與 <a href="https://medium.com/appworks-school/binary-search-%E9%82%A3%E4%BA%9B%E8%97%8F%E5%9C%A8%E7%B4%B0%E7%AF%80%E8%A3%A1%E7%9A%84%E9%AD%94%E9%AC%BC-%E4%B8%80-%E5%9F%BA%E7%A4%8E%E4%BB%8B%E7%B4%B9-dd2cd804aee1">二分搜尋法的一些細節</a>。</p><h4 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode:"></a>Leetcode:</h4><ul><li><a href="https://leetcode.com/problems/search-insert-position/">35. Search Insert Position</a></li><li><a href="https://leetcode.com/problems/sqrtx/">69. Sqrt(x)</a></li><li><a href="https://leetcode.com/problems/first-bad-version">278. First Bad Version</a></li></ul><h3 id="指數搜尋（Exponential-Search）"><a href="#指數搜尋（Exponential-Search）" class="headerlink" title="指數搜尋（Exponential Search）"></a>指數搜尋（Exponential Search）</h3><p>與二分搜尋類似，只是使用 2^N 作為搜尋的 index。</p><h3 id="插補搜尋（Interpolation-Search）"><a href="#插補搜尋（Interpolation-Search）" class="headerlink" title="插補搜尋（Interpolation Search）"></a>插補搜尋（Interpolation Search）</h3><p>用線性插值的概念，來加速尋找的過程。</p><blockquote><p><strong>推薦參考</strong>：<a href="https://magiclen.org/search-algorithm/">寫程式的基本功：搜尋演算法</a></p></blockquote><h1 id="時間複雜度（Time-Complexity）"><a href="#時間複雜度（Time-Complexity）" class="headerlink" title="時間複雜度（Time Complexity）"></a>時間複雜度（Time Complexity）</h1><p>時間複雜度是衡量演算法執行效率的一個重要指標，表示隨著輸入規模增加，算法執行所需時間的增長速度。</p><p>常用的符號有：</p><ul><li>O-Notation：Big-O（Worst Case，最差）</li><li>Θ-Notation：Big-Theta（Average Case，平均）</li><li>Ω−Notation：Big-Omega（Best Case，最佳）</li></ul><p>一般來說，我們最關心的是最差狀況下的時間複雜度（Big-O），關於詳細的數學推導可以參見補充。一些常見的時間複雜度與其例子為：</p><ul><li>$O(1)$：陣列讀取</li><li>$O(n)$：簡易搜尋</li><li>$O(log n)$：二分搜尋</li><li>$O(nlogn)$：合併排序</li><li>$O(n^2)$：選擇排序</li><li>$O(2^n)$：費波那契數列（遞迴版本）</li></ul><p><img src="https://hackmd.io/_uploads/rk2-JzHlp.png"></p><p>我們來看看這些例子是如何被計算出來的：</p><ul><li><a href="https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E5%BE%9E%E6%99%82%E9%96%93%E8%A4%87%E9%9B%9C%E5%BA%A6%E8%AA%8D%E8%AD%98%E5%B8%B8%E8%A6%8B%E6%BC%94%E7%AE%97%E6%B3%95-%E4%B8%80-b46fece65ba5">初學者學演算法｜從時間複雜度認識常見演算法</a></li><li><a href="https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F%E6%B3%95%E9%80%B2%E9%9A%8E-%E5%90%88%E4%BD%B5%E6%8E%92%E5%BA%8F%E6%B3%95-6252651c6f7e">初學者學演算法｜排序法進階：合併排序法</a></li><li><a href="https://medium.com/appworks-school/%E5%88%9D%E5%AD%B8%E8%80%85%E5%AD%B8%E6%BC%94%E7%AE%97%E6%B3%95-%E5%BE%9E%E8%B2%BB%E6%B0%8F%E6%95%B8%E5%88%97%E8%AA%8D%E8%AD%98%E4%BD%95%E8%AC%82%E9%81%9E%E8%BF%B4-dea15d2808a3">初學者學演算法｜從費氏數列認識何謂遞迴</a></li></ul><blockquote><p>補充：<a href="http://alrightchiu.github.io/SecondRound/complexityasymptotic-notationjian-jin-fu-hao.html">複雜度與漸進符號之數學</a><br>補充：<a href="https://jason-chen-1992.weebly.com/home/time-space-complexity">時間複雜度與空間複雜度</a></p></blockquote><h2 id="補充：Complexity-Cheat-Sheet"><a href="#補充：Complexity-Cheat-Sheet" class="headerlink" title="補充：Complexity Cheat Sheet"></a>補充：Complexity Cheat Sheet</h2><p>若不知道圖中的資料結構是什麼的話，可以先往下看。<br><img src="https://hackmd.io/_uploads/BkfMZStGp.png"><br><img src="https://hackmd.io/_uploads/BJ50lHYGp.png"></p>]]></content>
      
      
      <categories>
          
          <category> DSA 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tutorial </tag>
            
            <tag> Data Structure </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Make your shell great again! 來安裝 Oh My Zsh 吧！</title>
      <link href="/2025/05/28/installing-ohmyzsh/"/>
      <url>/2025/05/28/installing-ohmyzsh/</url>
      
        <content type="html"><![CDATA[<p>身為一個資工人，總是少不了每天跟 Shell 打交道，自從大二上過 OS 以後，什麼 <code>ls</code>、<code>cd</code>、<del><code>sudo rm -rf /*</code></del>，根本就是跟喝水一樣每天都會碰到（絕對不要試最後一個，後果自負 XD）。大多 OS 預設的 Shell 功能通常都不多，僅僅只能算是堪用而已，因此常常會遇到一些麻煩的狀況，像是你要進到很深的資料夾就要一直瘋狂 <code>cd</code>，或是要一直 <code>ls</code> 看這邊到底有什麼檔案等等。某天偶然聽到別人介紹 <a href="https://ohmyz.sh/">Oh My Zsh</a>，感覺非常好用，就乾脆自己來玩玩看。（延伸閱讀：<a href="https://ithelp.ithome.com.tw/articles/10216912">什麼是 Shell？</a>）</p><h1 id="安裝方法"><a href="#安裝方法" class="headerlink" title="安裝方法"></a>安裝方法</h1><p>我主要綜合以下三篇文章的教學：</p><ul><li><a href="https://gist.github.com/n1snt/454b879b8f0b7995740ae04c5fb5b7df">Oh my ZSH with plugins</a></li><li><a href="https://www.kwchang0831.dev/dev-env/ubuntu/oh-my-zsh">Ubuntu 安裝 Zsh + Oh My Zsh + Powerlevel10k 與各種插件</a></li><li><a href="https://holychung.medium.com/%E5%88%86%E4%BA%AB-oh-my-zsh-powerlevel10k-%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%A5%BD%E7%9C%8B%E5%A5%BD%E7%94%A8%E7%9A%84-command-line-%E7%92%B0%E5%A2%83-f66846117921">【分享】Oh My Zsh + powerlevel10k 快速打造好看好用的 command line 環境</a></li></ul><p>首先，如果你的作業系統不是 Mac，那通常預設 Shell 會是 Bash。可以透過以下 command 安裝 Zsh 並設置預設 Shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line">chsh -s $(<span class="built_in">which</span> zsh)</span><br></pre></td></tr></table></figure><p>然後重新登入應該就可以了。</p><p>接著安裝 Oh My Zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>到這裡應該就完成基本的 Oh My Zsh 安裝了。</p><h1 id="擴充套件"><a href="#擴充套件" class="headerlink" title="擴充套件"></a>擴充套件</h1><p>到目前為止我們只安裝了 Oh My Zsh，但其相關擴充套件才是 Oh My Zsh 的精華所在。Oh My Zsh 完全開源，因此很多相應套件油然而生，我個人有安裝的套件如下：</p><ul><li>zsh-z</li><li>zsh-autosuggestions</li><li>zsh-syntax-highlighting</li><li>fast-syntax-highlighting</li><li>zsh-autocomplete</li></ul><p>使用以下 Command 安裝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/agkozak/zsh-z <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-z</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autosuggestions</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-syntax-highlighting</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zdharma-continuum/fast-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/plugins/fast-syntax-highlighting</span><br><span class="line">git <span class="built_in">clone</span> --depth 1 -- https://github.com/marlonrichert/zsh-autocomplete.git <span class="variable">$ZSH_CUSTOM</span>/plugins/zsh-autocomplete</span><br></pre></td></tr></table></figure><p>這些操作是把相關的 Github Repo clone 到你電腦裡。</p><p>最後打開 Zsh 的 config file：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>若不熟悉 <code>vim</code> 可以使用其他程式開啟。找到 <code>plugins=(git)</code> 並取代成 <code>plugins=(git z zsh-autosuggestions zsh-syntax-highlighting fast-syntax-highlighting zsh-autocomplete)</code>，關掉 Terminal 重新打開就完成了。</p><h1 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h1><p>關於主題配置可以參考<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/themes">官方說明</a>，或是這裡有<a href="https://github.com/Holychung/My_Terminal_Theme">別人的教學</a>，但我自己最後還是選用預設的主題，因為我覺得簡潔就很漂亮了。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>Shell 其實是門高深的學問，除了文中提及的 Bash 與 Zsh 之外，另外還有很多 Shell 像是 Fish 等等，本篇就不再多做贅述。總之，有了 Oh My Zsh 後，我覺得我的開發體驗又有變更好了，像是 <code>z</code> 可以輕鬆的跳來跳去，還有許多 autocomplete 的功能等等，只能說開源社群的力量太強大了！</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
            <tag> Zsh </tag>
            
            <tag> Oh My Zsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>突然想寫的生活近況更新</title>
      <link href="/2025/04/01/life_update_2025_04/"/>
      <url>/2025/04/01/life_update_2025_04/</url>
      
        <content type="html"><![CDATA[<p>嗨，好久不見！</p><p>最近特別忙碌，好一陣子沒有來更新了。趁著前幾天在新電腦上重新架好 <a href="https://jackchen890311.github.io/2023/01/19/build-my-blog/">hexo</a> 的環境，順便來隨意更新一下生活近況。（舊電腦實在太炸，已經用五六年了，鍵盤還一直壞，忍不住換了新筆電，M4 Pro 真香～）</p><p>繼上次更新在聊<a href="https://jackchen890311.github.io/2024/06/28/summer-intern-2024/">尋找實習</a>後，這半年（2024&#x2F;07～2025&#x2F;03）發生了許多蠻值得記錄的事情，就且聽我娓娓道來吧。</p><h1 id="關於工作"><a href="#關於工作" class="headerlink" title="關於工作"></a>關於工作</h1><p>我於七月加入 Appier 擔任 ML Scientist Intern，到目前為止都還在實習。每週工作三到四天，可以一半遠端的工作模式也讓我有較多彈性，細節也許我之後會再發一篇文單獨來談，總體而言我還是蠻滿意這個經歷的。</p><p>另外，我依然有在接家教，但現在學生數量降到一個，每週大概一到兩次，準備起來是蠻輕鬆的，除了學生很常請假，和會佔用一點時間以外，整體也是挺不錯的。</p><p>最後，我也陸陸續續準備面試了一些正職的面試（真的好累……），之後也會有一篇文章跟大家分享，總之目前是拿到了還算喜歡的 offer，但也會偶爾持續尋找面試看看其他機會。</p><h1 id="關於學校"><a href="#關於學校" class="headerlink" title="關於學校"></a>關於學校</h1><p>碩二是研究最繁忙的時候，但不見棺材不掉淚的我，還是選了一堂可怕但實用的課：李允中教授的軟體工程設計。這堂課我聽了好多學長姐都是淚推：超累但很有用。而我修完的的心得也差不多，就是每週要花很多時間，但會學到很多東西、對未來工作很有幫助的課。</p><p>我的感想是，這個主題（設計模式）是很有趣的主題，但不是一夕之間可以掌握的，需要大量練習跟實作經驗。雖然上完我不後悔，但我真的是因為這堂課累得半死，而且我自認也沒有投入 100％ 心力（還要上班家教面試研究…完全沒力…）。如果有人有興趣的話，我先推薦這本<a href="https://github.com/jizongFox/E-book/blob/master/%5B%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(Java)%5D.%E5%90%B4%E5%BC%BA.%E6%89%AB%E6%8F%8F%E7%89%88.pdf">大話設計模式</a>，看完的話大概可以對這堂課的內容有一些基本掌握。</p><p>至於我自己的碩論，老實說目前進度我覺得還有點落後，雖然大方向有了，但還沒有很完整的方法，還在努力的不斷嘗試當中。前幾天去聽了口試說明會，希望這學期可以順利口試畢業才行……。</p><h1 id="關於生活"><a href="#關於生活" class="headerlink" title="關於生活"></a>關於生活</h1><p>生活中的休閒還是與之前差不多，有空會去健身打球追影集，或找朋友打麻將，很偶爾也會玩個電腦遊戲等等。</p><p>最近一直有想重啟閱讀習慣，畢竟我之前買了一堆書都還沒看，也有在想要不要轉戰電子書平台會比較方便，但我實在是時間不夠，還在思考要怎麼辦。持續有一直在做的，是看人家寫的書摘，我都看<a href="https://readingoutpost.com/">閱讀前哨站</a>的電子報，讓我這種懶又忙的人可以快速讀完一本書，推薦給大家。</p><p>這半年剛好有一些機會去了不同國家玩，算是出國頻率比較頻繁的一段期間。</p><ul><li>2024&#x2F;08：韓國釜山  </li><li>2024&#x2F;10：義大利米蘭、羅馬（ECCV）  </li><li>2025&#x2F;02：日本大阪、京都、神戶、奈良</li></ul><p>也許是因為碩班壓力大，每個學期結束好像都得出國玩一下？（2023&#x2F;12 也有去香港玩）總之還蠻幸福的，而且我一直都很喜歡到處旅遊，希望未來可以去更多地方探索。</p><p>另外，在 2025 年初我也交了人生第一個女朋友（講起來有點害羞，但還是想跟大家分享）。只能說人與人相遇真的是緣分，2024 年底才剛認識，還是朋友的朋友牽線，幾個月後就在一起了。因為是第一段感情，我也還在跌跌撞撞地學習中，謝謝我女友很包容我，也願意帶著我學習摸索，目前都過得很充實很快樂！</p><h1 id="結語-關於時間"><a href="#結語-關於時間" class="headerlink" title="結語 - 關於時間"></a>結語 - 關於時間</h1><p>好了，以上大概就是我的近況，與大家分享。</p><p>最近（或一直以來）的煩惱就是：時間不夠用！<br>每天有限的時間就那麼多，加上我是一個需要自己時間跟休息耍廢的人，又有很多想做的事情，完 全 是 時 間 不 夠！</p><p>我每週上班三天、家教一兩個早上、學校開會三到五小時、偶爾還有面試、還要看很多 paper 跟跑實驗、安排時間休息、約會等等，有時候其實壓力蠻大的。雖然說我盡量還是讓自己 chill 一點，但偶爾總是會有事情做不完的焦慮感（主要是很擔心畢業能不能順利，畢竟現在研究還沒有說很順利或很完整）。</p><p>這幾天剛好清明連假，賺到兩天不用上班，除了繼續努力跑實驗之外，我也再重新思考了一下。我目前好像大多心力都花在上班、畢業、女友身上；但對於一些會有長期回報的事情，像是看書、健身、學新技能或外語等等，我幾乎沒有花什麼心力在上面，或者是說沒有多餘的心力花在上面。我不確定到底是哪個環節的問題，但我總是有一種 overwhelmed 的感覺，希望畢業或其他的壓力減輕以後，我可以回來正視這個問題。</p><p>這些也是我需要慢慢學習的課題吧，透過寫這篇文章，除了紀錄我最近的生活之外，也是一個機會讓我反思自我。雖然可能短期還是會這麼混亂，但感覺一切都有在逐漸往好的方向前進（吧）。希望看到這裡的你，也能熱愛生活，一起努力變好！</p>]]></content>
      
      
      <categories>
          
          <category> 生活隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Master </tag>
            
            <tag> Life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 年科技業暑期實習面試心得（Google, Gamania, Appier）</title>
      <link href="/2024/06/28/summer-intern-2024/"/>
      <url>/2024/06/28/summer-intern-2024/</url>
      
        <content type="html"><![CDATA[<p>一年又過去啦～又到了要找暑期實習的時間了，如果還沒看過去年的暑期實習面試心得文可以 <a href="https://jackchen890311.github.io/2023/05/24/summer-intern-2023/">點我</a> 觀看。今年我的策略一樣是只找大公司 &amp; 有興趣的職位，因為順利的話畢業也許可以直接拿 Return Offer，就不用再找工作了。另外我主要是找暑期，以 SWE、AI &amp; ML 相關的職缺為主。（雖然我最後去的是長期實習 XD）</p><h1 id="面試紀錄"><a href="#面試紀錄" class="headerlink" title="面試紀錄"></a>面試紀錄</h1><ul><li>投遞履歷：18 家公司</li><li>面試邀請：3 家公司</li><li>Offer Get：1 家公司</li></ul><p>最後去 Appier 做 Machine Learning Scientist Intern，我也只有拿到這個 Offer。</p><h2 id="Google-SWE-Intern"><a href="#Google-SWE-Intern" class="headerlink" title="Google - SWE Intern"></a>Google - SWE Intern</h2><h3 id="第一關（1-29-1-30）-Online-Coding-Interview-x-2"><a href="#第一關（1-29-1-30）-Online-Coding-Interview-x-2" class="headerlink" title="第一關（1&#x2F;29 &amp; 1&#x2F;30）- Online Coding Interview x 2"></a>第一關（1&#x2F;29 &amp; 1&#x2F;30）- Online Coding Interview x 2</h3><p>一月初投的，中間兩三周都沒收到任何消息，還以為涼去，結果到快月底了才收到面試邀請，還好我一月都算有在加減刷題，話雖如此但面試前幾天還是緊張到靠北。題外話，我原本選一中一英，但莫名其妙變成二中，不知道該開心還是該難過，因為我也不知道到底語言會不會影響評分 @@。</p><p>以下因為 Google 有要求不能洩漏題目，所以我不會講到題目細節，只會提到大概的方向。其實考題完全不難，是很基本的資料結構（Tree, Matrix, Array 等等），暖身題也都只是基本的遍歷，看來真的是很考驗你基本功夠不夠穩，以及你夠不夠有自信。</p><h4 id="Removal-Sequence-of-a-Tree（1-29）"><a href="#Removal-Sequence-of-a-Tree（1-29）" class="headerlink" title="Removal Sequence of a Tree（1&#x2F;29）"></a>Removal Sequence of a Tree（1&#x2F;29）</h4><!-- 給定一個 Tree (Binary or N-ary)，找到一個 removal sequence，並滿足以下條件：- 優先刪除葉節點，刪除時要將 TreeNode 的 Link 斷開- 若某節點被刪除，則下一次優先刪除其父節點- 若某節點被刪除，則下一次優先刪除非父節點，除非只剩下父節點可以刪除（Follow-up）- 最後回傳其刪除順序 --><!-- 其實很仁慈～第一題我算蠻快就解出來了，就是基本的 DFS 而已。但第二題不知為啥我卡了蠻久，就是沒想到用 node height 就可以輕鬆解決，而且我好像還把 height 跟 depth 的概念講混了，我先哭死。不過後來在面試官提點之後，有在時間內做出來，但 complexity analysis 我講得很不確定，基本功真的不夠紮實嗚嗚嗚，感覺這種題目高手來應該是秒殺。 --><p>題目：給定一個 Tree (Binary or N-ary)，找到一個符合不同特定條件的 Removal Sequence</p><p>其實很仁慈～第一題我算蠻快就解出來了，就是基本的 Traversal 而已。但第二題不知為啥我卡了蠻久，就是沒想到用 Node Height 就可以輕鬆解決，而且我好像還把 Height 跟 Depth 的概念講混了，我先哭死。不過後來在面試官提點之後，有在時間內做出來，但 Complexity Analysis 我講得很不確定，基本功真的不夠紮實嗚嗚嗚，感覺這種題目高手來應該是秒殺。</p><h4 id="Matrix-Traversal（1-30）"><a href="#Matrix-Traversal（1-30）" class="headerlink" title="Matrix Traversal（1&#x2F;30）"></a>Matrix Traversal（1&#x2F;30）</h4><!-- 給定一個 N x N matrix, starting point 與 termination point：- 0 代表水，1 代表陸地，只能走上下左右- 找出是否能從 S 走到 T，並回傳 True / False- 加入一個條件 C (代表貓)，找出所有從 S（老鼠起點）到 T（老鼠終點）的路徑中，與貓的最短距離最大的路徑（Follow-up）- 與貓的距離定義為該點走到貓的距離，若中間有水阻隔就要繞路 --><!-- 也是很仁慈，但我覺得我也沒有發揮好，第一題 Traversal 的部分寫完了被問有沒有辦法加速，結果我想了半天還沒有加速到，還浪費一堆時間。（其實我寫的應該對了，但面試官一這樣問我就開始自我懷疑 @@，所以壓縮到第二題的時間）第二題也是與貓的距離一開始沒確認好遇到水要繞路，所以稍微拖到，最後第二題就沒寫完，但概念都有講清楚，就是 BFS + DFS 加一些小細節這樣。面完感覺高手也是可以輕鬆秒殺的，我還卡成這樣大概是沒希望 QQ。 --><p>題目：給定一個 Matrix，判斷是否能從起點走到終點，以及符合某條件下的最佳路徑</p><p>也是很仁慈，但我覺得我也沒有發揮好，第一題 Traversal 的部分寫完了被問有沒有辦法加速，結果我想了半天還沒有加速到，還浪費一堆時間（其實我寫的應該對了，但面試官一這樣問我就開始自我懷疑 @@，所以壓縮到第二題的時間）。第二題也是一開始沒確認好細節，所以稍微拖到，最後第二題就沒寫完，但概念都有講清楚，就是 Traverse 兩次加一些小細節這樣。面完感覺高手也是可以輕鬆秒殺的，我還卡成這樣大概是沒希望。</p><p>結果：過年後感謝信，哭了。後續有寄信去問面試表現，得到的回覆是：「其中一關很棒，但另一關在一開始對算法的使用不夠熟悉，如果不用提示會更好，所以沒有繼續往下進行。」人資人還是蠻不錯的，還有鼓勵我繼續加油，不過說實話我不知道是哪場不夠好（我猜是第一場），只好以後繼續加油增進基礎功。</p><!-- ## Yahoo - Research Scientist Intern這個職位剛好實驗室的學長前年有待過，他強烈推薦我去，因為他說風氣很不錯，加上可以自由研究你想研究的東西，甚至也許會對碩論有幫助，總之就是個不錯的職位這樣。也是一月初投，但他們好像一月底才會統一開始審這樣。結果：直接感謝信，幹其實我不懂為啥，有可能[去年面 DevOps 面太爛](https://jackchen890311.github.io/2023/05/24/summer-intern-2023/#Yahoo-DevOps-Intern)所以進黑名單了吧，雞巴。## Microsoft - SWE Intern在 LinkedIn 上收到邀請，仔細一看竟然是 Summer Internship，所以就直接丟了。印象中微軟似乎是第一年開暑期實習，以往都是整年的甚麼未來生涯體驗計畫，也因此我過往都沒有丟（大二好像丟過，但那時候還沒雙到資管系，雖然我覺得我面的不錯但還是感謝信）。不得不說微軟流程設計得不錯，大概十分鐘不到就可以填完資料送出申請了，非常方便。結果：又一個直接感謝信，我真的茫了，完全不懂為啥，而且效率超快，大概只過了三四天，莫名其妙。有在 LinkedIn 上詢問人資，但沒理我，然後過幾天又發另一個不相關的缺的邀請給我，整個問號。 --><p>後面兩個都是後來才紀錄的，所以可能不會到很詳細。</p><h2 id="Gamania-AI-Researcher"><a href="#Gamania-AI-Researcher" class="headerlink" title="Gamania - AI Researcher"></a>Gamania - AI Researcher</h2><p>其實原本沒有發現遊戲橘子有開缺，會投這個主要是實驗室的學長介紹，就給他履歷請他幫我內推了。遊戲橘子內部業務除了遊戲之外，也有跨足媒體、娛樂等等產業，因此他們的 AI Team 主要就是在分析這些資料，跟其遊戲本業倒不太相關。</p><h3 id="第一關（4-26）-Team"><a href="#第一關（4-26）-Team" class="headerlink" title="第一關（4&#x2F;26） - Team"></a>第一關（4&#x2F;26） - Team</h3><p>第一關主要是個人經歷關以及公司介紹，沒有技術關。面試我的看起來是未來的同事，前面花十多分鐘講完我的經歷，他只追問了一點點，就開始介紹公司了。我當下就有種感覺是根本都沒問到重點或細節，就直接結束了，不太確定是對我沒興趣還是怎樣，但後來幾天又收到二面邀請，想說也許還是有機會。</p><h3 id="第二關（5-3）-HR"><a href="#第二關（5-3）-HR" class="headerlink" title="第二關（5&#x2F;3） - HR"></a>第二關（5&#x2F;3） - HR</h3><p>他們的 HR 看起來蠻幹練的，看起來對自己的工作很熟悉，講解的也都很清楚。基本上這關就跟平常遇到的 HR 關差不多，問一些個人特質、經歷等等，所以也沒有太多好說的。最後 HR 還說如果有問題可以用 LinkedIn 聯絡他，當下覺得蠻有機會。</p><p>結果：很遺憾的，收到了感謝信。後來去問當初內推我的學長，他說雖然我的個人特質看起來不錯，但他們想找經歷更相關的，可能我在這塊的經驗相對較少吧，有點可惜。題外話，遊戲橘子的公司在內湖，離我家大概就是 5-10 分鐘車程，我每次家教完回家也都會經過，超近！</p><h2 id="Appier-ML-Engineer-Scientist"><a href="#Appier-ML-Engineer-Scientist" class="headerlink" title="Appier - ML Engineer Scientist"></a>Appier - ML Engineer Scientist</h2><p>4&#x2F;30 突然收到面試邀請，蠻驚喜的，因為這個時間已經有點晚了，不過他也不是暑期實習就是了。我其實也有投 Appier 的暑期實習，甚至在面這個職位中途收到感謝信，害我以為這個職位也告吹，結果仔細看發感謝信的是暑期職位，不是這個缺。雖然面試過程拖了快兩個月，但很幸運最後也拿到 Offer，Onboard Date 也差不多就是七月初，算是沒有偏離我原本的目標太遠（除了開學後要繼續工作以外，希望我不會忙到翻掉嗚嗚）。</p><h3 id="第一關（5-7）-Tech"><a href="#第一關（5-7）-Tech" class="headerlink" title="第一關（5&#x2F;7） - Tech"></a>第一關（5&#x2F;7） - Tech</h3><p>第一關應該是由同事來面，也是我認為最扎實的一關。整個面試過程大約快一小時，最一開始是兩題 Coding Test，主要是實作兩個常見的 Loss 與他們的 Gradient，會給你他們的公式，並且不限語言或使用套件，只有說算 Gradient 的時候不要 Call Loss.backward()。Coding 部分還算友善，接著是一題模擬題，要你設計一個 Ranking Algorithm，會給你相關的 User Logs，方法上沒有限制。這題我講了幾個不同的方式，他叫我挑一個講細節一點，所以我就把最近在看的 Contrastive Learning 做延伸，應用在他的題目裡。這部分問蠻細的，會問你 Loss 設計，還有延伸情境題，好在我認為我講的還可以，講完之後今天面試差不多就到這邊。</p><h3 id="第二關（5-14）-Manager"><a href="#第二關（5-14）-Manager" class="headerlink" title="第二關（5&#x2F;14） - Manager"></a>第二關（5&#x2F;14） - Manager</h3><p>後來收到二面邀請，這次應該是團隊主管。聊什麼內容我有點忘記了，但印象中大概是圍繞在個人相關經歷，針對他有興趣的去問細節，好像還有問最近研究方向之類的，總之都是在純聊天，好在後來也順利進到下一關。</p><h3 id="第三關（5-20）-CTO"><a href="#第三關（5-20）-CTO" class="headerlink" title="第三關（5&#x2F;20） - CTO"></a>第三關（5&#x2F;20） - CTO</h3><p>實習要面到 CTO 其實我蠻意外的，不過他排的時間只有不到半小時，所以我猜想應該就是簡單聊天？實際到當天面試，CTO 開場第一句話就問我說：「你是許老師的學生喔？」，讓我有點驚喜，後來才知道原來他也跟我同個 Lab，世界真小。後來跟他聊了幾句之後，便針對我目前的研究來問，問了一些技術細節，差不多就結束了。結束前想說機會難得，問他對於目前市場的看法，就再跟他多聊了十多分鐘。CTO 人蠻好的，很願意跟我分享他的看法，聊天過程也很愉快。</p><h3 id="第四關（6-22）-CEO"><a href="#第四關（6-22）-CEO" class="headerlink" title="第四關（6&#x2F;22） - CEO"></a>第四關（6&#x2F;22） - CEO</h3><p>原本想說面到 CTO，面的過程看起來也沒啥問題，應該是十拿九穩等著收 Offer 了。加上 HR 過幾天後又跟我約電話，我跟學長討論後，他說他覺得應該是要談 offer 細節，但殊不知他是要跟我約四面 CEO 的時間。四面啊！！！我這輩子還沒面過四面，更何況只是實習，不過看來 Appier 似乎近期作風都是這樣，後來也有聽說其他實習或正職也要面到 CEO。</p><p>另外，大家應該可以發現三面跟四面之間隔了一個月，那是因為 CEO 忙到只有週末的少數可以面試，加上他們人資或祕書又很拖，週五晚上才在問週六早上能不能面試，也沒有先確定我所有的 Availability，總之一路來回拉扯了快一個月，好不容易才敲定一個時間面試，為此我還特地請了半小時家教的假，真的是十分折騰，還好人資都還有在幫忙我處理，也是很感謝他。</p><p>CEO 基本上也是純聊天而已，就跟他聊聊個人經歷、以往實習內容、最近研究、為什麼想來 Appier 這樣。過程中可以看出他思路還蠻快的，但還是會很有耐心聽你講完。聊完沒問題後，他口頭跟我說到這個階段會有 Offer 了，也讓我總算放下了心中的大石頭，然後就速速的結束的此次面試，整個時長不到十五分鐘，看來他應該是真的很忙。</p><p>結果：Offer Get（6&#x2F;25）。Onboard 日期訂在兩週後（7&#x2F;8），直到六月底才拿到 Offer，也算是一種極限操作了，還好投這麼多間，總算有一間順利的走完全部過程。</p><h2 id="其他投遞公司與職位"><a href="#其他投遞公司與職位" class="headerlink" title="其他投遞公司與職位"></a>其他投遞公司與職位</h2><p>因為丟的公司很多，加上也很多沒有後續，所以就不一間一間細講了，但還是把我有投的公司放在這裡給大家參考。</p><ul><li>Yahoo: Research Scientist Intern &amp; Data Science Intern</li><li>Microsoft: SWE Intern</li><li>Wistron: SWE &#x2F; AI Intern</li><li>Realtek: SWE &#x2F; FWE &#x2F; AI Intern</li><li>PicCollage: ML Intern</li><li>Dell: SWE Intern</li><li>MediaTek: SWE &#x2F; FWE &#x2F; AI Intern</li><li>Trend: SWE &amp; Test Intern</li><li>Quid: ML Intern</li><li>NVIDIA: Applied Simulation Research Intern</li><li>Garmin: DS &#x2F; DE &#x2F; SWE Intern</li><li>Qualcomm: ML &#x2F; Web Intern</li><li>Acer: AI Intern</li><li>Cadence: SWE Intern</li><li>Synopsys: SWE Intern</li></ul><p>整理完發現我也投太多，然後也一堆沒有收到後續，好難過 QQ。其實我原本今年不打算寫這篇文章的，因為如果全都沒上好像有點丟臉，還好最後有拿到一個 Offer，也因此才有這篇文章的產出。</p><p>再一個題外話，去年在 TSMC 實習的單位主管 T （詳情請看<a href="https://jackchen890311.github.io/2023/09/11/intern-at-TSMC/">這篇</a>文章）有問我要不要回去他底下再當一次實習生，這次是在竹科，直接在他底下實習。雖然稍微有點心動，但我沒有很想在一間公司實習兩次，加上我對該部門的工作內容已經大概都知道了，實習的目的比較像是探索不同的職位 &#x2F; 公司與自己的契合度，所以我後來就婉拒了他的邀約。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>每次要找工作都很痛苦呀…近幾年景氣不是太好，海投的結果常常是杳無音訊，希望最後拿到 Offer 的這個實習職位可以順利轉正，這樣我畢業就不用再重找工作了。也謝謝你閱讀到這邊，希望我少少的幾個面試經驗對你有幫助，也祝我們在未來找工作的路上都順順利利！若還有什麼問題，都歡迎再聯絡我詢問喔～</p>]]></content>
      
      
      <categories>
          
          <category> 工作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Internship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 教學系列文 (2) - 類別、延伸議題</title>
      <link href="/2023/12/02/cpp-tutorial-2/"/>
      <url>/2023/12/02/cpp-tutorial-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/C7kIxIuJQImM_x64fhuM_A?view">HackMD 完整版請點我</a></p><h2 id="類別（Class）"><a href="#類別（Class）" class="headerlink" title="類別（Class）"></a>類別（Class）</h2><p>作為物件導向的程式語言，C++ 的 class 相關語法可以說是非常重要與常用，在大型專案的開發一定少不了他的身影，且多樣又彈性的語法支援，可以說是將物件導向的概念發揮到了極致。此處我們簡述一些常見的相關語法與概念，過於高深或少見的語法我們會先略過。</p><ul><li>基本語法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> wheels;</span><br><span class="line">        string plateID;</span><br><span class="line">        string driver;</span><br><span class="line">        <span class="type">bool</span> engine;</span><br><span class="line">        <span class="type">int</span> meters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Car</span>(string plateID, string driver);</span><br><span class="line">        ~<span class="built_in">Car</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">turnOnEngine</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">checkEngine</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">(<span class="type">int</span> distance)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">turnOffEngine</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">whoisDriving</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">getMeters</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Car::<span class="built_in">Car</span>(string plateID, string driver) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;wheels = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;plateID = plateID;</span><br><span class="line">    <span class="keyword">this</span>-&gt;driver = driver;</span><br><span class="line">    <span class="keyword">this</span>-&gt;engine = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;meters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">turnOnEngine</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car::~<span class="built_in">Car</span>() &#123;</span><br><span class="line">    <span class="comment">// This is a Destructor</span></span><br><span class="line">    <span class="comment">// You can and you should delete dynamically allocated memory here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Car::turnOnEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">checkEngine</span>()) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;engine = <span class="literal">true</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Engine Started!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Car::checkEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Car::drive</span><span class="params">(<span class="type">int</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (engine) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;meters += distance;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Drive &quot;</span> &lt;&lt; distance &lt;&lt; <span class="string">&quot; kilometers.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Engine is not turned on.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Car::turnOffEngine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;engine = <span class="literal">false</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Engine has been turned off.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Car::whoisDriving</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;driver &lt;&lt; <span class="string">&quot; is driving the car.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Car::getMeters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;meters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>從上面的例子中，我們可以發現幾點與 Python 較不同的地方：</p><ul><li>甚麼是 private、public？</li><li>Constructor 與 Desturctor 在哪裡？</li><li>self 變成 this 了？</li><li>為何所有 function 前面都有 Car::？</li></ul><p>別擔心，我們一樣一樣來看。</p><h3 id="Private、Public、Protected"><a href="#Private、Public、Protected" class="headerlink" title="Private、Public、Protected"></a>Private、Public、Protected</h3><p>在C++中，private、public 和 protected 是用來定義類別中成員的可存取性（accessibility）的關鍵字，它們決定了這些成員在類別的內部和外部的可見性和可存取性。</p><ul><li>Private：僅限類別內部成員存取，不可透過外部存取（像是從外面寫 c.wheels 就是非法操作會報錯，必須透過額外的 getter 與 setter 才能對其進行操作），不會被繼承</li><li>Protected：與 Private 類似，唯一不同是會被繼承</li><li>Public：可以任意從外部取用，無任何限制</li></ul><p>簡而言之，如果目前還沒有複雜的繼承需求，就簡單使用 public 與 private 區分即可！不想讓別人操作到的就用 private，沒差的就用 public！</p><blockquote><p><a href="https://www.wongwonggoods.com/all-posts/cplusplus/cpp-concept/c-public-protected-private/">參考：C++ public, protected, private 總和比較整理</a><br><a href="https://blog.csdn.net/a3192048/article/details/82191795">延伸：C++ public、protected、private 和 friend</a></p></blockquote><h4 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="Getter &amp; Setter"></a>Getter &amp; Setter</h4><p>為了要存取與修改 Private member variable，我們會使用 Getter &amp; Setter 來幫助我們。</p><ul><li>Getter<ul><li>用於獲取變數的值</li><li>通常公開的方法，通常以 get 為前綴，後接要獲取的屬性名稱</li></ul></li><li>Setter<ul><li>用於設定變數的值</li><li>通常公開的方法，通常以 set 為前綴，後接要設定的屬性名稱，並會接受參數以更新屬性的值</li></ul></li></ul><p>一個簡單的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;myvalue = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>延伸問題：既然如此，為何不乾脆直接改成 Public 就好？<br>參考解答：因為透過 Getter &amp; Setter，我們可以更好的控制 Private Member Variable 的獲取與修改，進而避免不想要或意外的情況產生</p></blockquote><h4 id="封裝（Encapsulation）"><a href="#封裝（Encapsulation）" class="headerlink" title="封裝（Encapsulation）"></a>封裝（Encapsulation）</h4><p>上述的 Getter &amp; Setter，其實就是實現了物件導向程式設計（OOP）中「封裝」的概念。（<a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw#OOP-%E4%B8%89%E5%A4%A7%E7%B2%BE%E9%9A%A8---%E5%B0%81%E8%A3%9D%E3%80%81%E7%B9%BC%E6%89%BF%E3%80%81%E5%A4%9A%E5%9E%8B%EF%BC%88%E8%A3%9C%E5%85%85%EF%BC%89">複習：OOP 三大精隨</a>）</p><p>將物件的內部狀態和行為隱藏在物件內部，只公開必要的方法給外界使用。封裝可以保護物件免於外界的非法存取，並且讓物件更容易維護和修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string private_name; <span class="comment">// This cannot be accessed from the outside</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string public_name; <span class="comment">// This can be accessed from the outside</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> string&amp; name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;private_name = name; <span class="comment">// Setter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Constructor-Destructor"><a href="#Constructor-Destructor" class="headerlink" title="Constructor &amp; Destructor"></a>Constructor &amp; Destructor</h3><p>constructor(建構函式) 與 destructor(解構函式) 是 class 中的兩種特別函式，當主程式中產生某 class 的物件時，該 class 的建構函式即會自動執行；而當物件生命周期結束，則在物件消滅前會自動執行解構函式。</p><p>其相應語法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Car::<span class="built_in">Car</span>(string plateID, string driver) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;wheels = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;plateID = plateID;</span><br><span class="line">    <span class="keyword">this</span>-&gt;driver = driver;</span><br><span class="line">    <span class="keyword">this</span>-&gt;engine = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;meters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">turnOnEngine</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car::~<span class="built_in">Car</span>() &#123;</span><br><span class="line">    <span class="comment">// This is a Destructor</span></span><br><span class="line">    <span class="comment">// You can and you should delete dynamically allocated memory here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>參考：<a href="http://cpp2015.blogspot.com/2015/07/constructor-destructor.html">Constructor &amp; Destructor</a></p></blockquote><h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>C++ 中的 this 就與 Python 中的 self 相同意思，但不同於 Python 的是，我們不需要將 this 寫在 member function 的第一個參數位置，就能夠直接使用。</p><ul><li><code>self.</code> (python) &lt;-&gt; <code>this-&gt;</code> (C++)</li></ul><p>事實上，當我們創建一個類別指標，並讓該指標指向一個實體物件後，也可以使用 <code>-&gt;</code> 來存取該物件的屬性或方法，如下所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Car mycar;</span><br><span class="line">Car* carPtr = &amp;mycar;</span><br><span class="line">cout &lt;&lt; mycar.driver &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; carPtr-&gt;driver &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="成員函式的宣告與定義（Car-）"><a href="#成員函式的宣告與定義（Car-）" class="headerlink" title="成員函式的宣告與定義（Car::）"></a>成員函式的宣告與定義（Car::）</h3><p>一般來說，我們會將函數的實作（Implementation）與函數宣告（Declaration）寫在一起，像是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Test&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>()&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ~<span class="built_in">Test</span>()&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Destructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不過此種寫法的壞處是，當我們成員函式太多時，整個 Class 會變得很常難以閱讀，因此我們也可以把實作部分（Implementation）拉出來寫，但為了要避免混淆，必須加上該函式的範籌說明（Test::）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class Test&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Test</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">        ~<span class="built_in">Test</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test::<span class="built_in">Test</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Constructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test::hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">Test::~<span class="built_in">Test</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Destructor!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="More-on-Class：繼承與多型"><a href="#More-on-Class：繼承與多型" class="headerlink" title="More on Class：繼承與多型"></a>More on Class：繼承與多型</h2><p>可參考之前講過的 <a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw#OOP-%E4%B8%89%E5%A4%A7%E7%B2%BE%E9%9A%A8---%E5%B0%81%E8%A3%9D%E3%80%81%E7%B9%BC%E6%89%BF%E3%80%81%E5%A4%9A%E5%9E%8B%EF%BC%88%E8%A3%9C%E5%85%85%EF%BC%89">OOP 三大精隨</a>。</p><h3 id="繼承（Inheritance）"><a href="#繼承（Inheritance）" class="headerlink" title="繼承（Inheritance）"></a>繼承（Inheritance）</h3><p>子類別可以繼承父類別的屬性和方法，並且可以擴展或覆寫父類別的行為。繼承可以提高程式碼重複使用性，並且可以讓類別之間建立階層關係，方便對類別進行分類和管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        string name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">walk</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;walking&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;eating&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Dog</span>(<span class="type">const</span> string&amp; name) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name + <span class="string">&quot; the dog&quot;</span>;</span><br><span class="line">        &#125; <span class="comment">// Constructor will not be inherited</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">A</span><span class="params">(<span class="string">&quot;A&quot;</span>)</span></span>;</span><br><span class="line">    A.<span class="built_in">walk</span>();</span><br><span class="line">    A.<span class="built_in">eat</span>();</span><br><span class="line">    cout &lt;&lt; A.name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">walking</span><br><span class="line">eating</span><br><span class="line">A the dog</span><br></pre></td></tr></table></figure><h4 id="繼承方法"><a href="#繼承方法" class="headerlink" title="繼承方法"></a>繼承方法</h4><p>上述的繼承使用 <code>class Dog : public Animal</code> 這行，這邊有個 keyword <code>public</code> 出現，這個 keyword 代表這邊使用的方法為 <code>public</code> 繼承方法，依照不同的繼承方法與不同的父類別可見度，會產生如下的表格：</p><p><img src="https://hackmd.io/_uploads/ByFcnXoya.png"></p><p>這表格我認為參考就好，不用記下來，搞不清楚的話就都用 <code>public</code> 繼承方法即可。</p><h3 id="多型（Polymorphism）"><a href="#多型（Polymorphism）" class="headerlink" title="多型（Polymorphism）"></a>多型（Polymorphism）</h3><p>同樣的方法名稱可以在不同的類別中有不同的實現方式，這稱為多型。多型可以讓程式碼更加靈活，並且可以讓不同的物件對相同的方法有不同的行為。多型可以通過繼承和介面實現，是物件導向設計中非常重要的概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        string name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Animal</span>(<span class="type">const</span> string&amp; name) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">walk</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;walking&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;eating&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Dog</span>(<span class="type">const</span> string&amp; name) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name + <span class="string">&quot; the dog&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is using foot to walk&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is eating bone&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Duck</span>(<span class="type">const</span> string&amp; name) &#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;name = name + <span class="string">&quot; the duck&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">walk</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is using two feet to walk&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            cout &lt;&lt; name &lt;&lt; <span class="string">&quot; is eating worm&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">A</span><span class="params">(<span class="string">&quot;A&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Duck <span class="title">B</span><span class="params">(<span class="string">&quot;B&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    A.<span class="built_in">eat</span>();</span><br><span class="line">    B.<span class="built_in">eat</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">A is eating bone</span><br><span class="line">B is eating worm</span><br></pre></td></tr></table></figure><h3 id="相關補充"><a href="#相關補充" class="headerlink" title="相關補充"></a>相關補充</h3><p>老實說我覺得這邊都太複雜了，但為了課程完整性還是簡單提及，除非你是 C++ 老手，不然根本不可能記得，所以我的建議是先了解概念，有需要再回來查。</p><ul><li><a href="https://shengyu7697.github.io/cpp-virtual/">C++ virtual 的兩種用法</a></li><li><a href="https://note.artchiu.org/2021/04/01/c%E4%B8%AD%E7%9A%84overload%E3%80%81override%E5%92%8Coverwrite/">C++ 中的 Overload、Override 和 Overwrite</a></li><li><a href="https://shengyu7697.github.io/cpp-const/">C++ const 的三種用法與範例</a></li></ul><h2 id="延伸主題：Call-by-value-address-reference-assignment"><a href="#延伸主題：Call-by-value-address-reference-assignment" class="headerlink" title="延伸主題：Call by value &#x2F; address &#x2F; reference &#x2F; assignment"></a>延伸主題：Call by value &#x2F; address &#x2F; reference &#x2F; assignment</h2><ul><li><a href="https://www.wongwonggoods.com/all-posts/cplusplus/cpp-concept/cpp-value-address-pointer-reference/">C++ call by value, call by address (pointer), call by reference </a></li><li><a href="https://medium.com/starbugs/python-%E4%B8%80%E6%AC%A1%E6%90%9E%E6%87%82-pass-by-value-pass-by-reference-%E8%88%87-pass-by-sharing-1873a2c6ac46">Python 是 Pass By Value, Pass by Reference, 還是 Pass by Sharing？</a></li></ul><h2 id="延伸主題：C-STL"><a href="#延伸主題：C-STL" class="headerlink" title="延伸主題：C++ STL"></a>延伸主題：C++ STL</h2><ul><li><a href="https://4yu.dev/post/STL/">C++ STL 全</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 教學系列文 (1) - 基本語法速覽、指標</title>
      <link href="/2023/12/02/cpp-tutorial-1/"/>
      <url>/2023/12/02/cpp-tutorial-1/</url>
      
        <content type="html"><![CDATA[<p>哈囉！許久沒有更新了，因為碩班真的是好忙呀嗚嗚，等我寒假或是比較有空的時候，會再開始更新一些東西。這次來發 C++ 的教學文章，延續之前的 Python 教學系列文，在教完 Python 之後，學生說想學 C++，身為好老師的我就又做了一份講義給他，抱持著造福社會的精神，就順便分享到我的網站上。（題外話：這個學生上個月剛教滿一年，也是我目前接最久的家教，甚至打這篇文章的現在也在幫他上課哈哈。之後還有一些其他主題的教學文，整理完以後我再發上來。）</p><p>此系列文只有兩篇，建立在你已經會寫基本的 Python，或是看完我的 Python 教學系列文的基礎上撰寫，所以如果還沒看過的可以點 <a href="https://jackchen890311.github.io/categories/Python-%E6%95%99%E5%AD%B8/">這邊</a> 來看。那因為已經有一個程式語言的概念了，所以我會著重在 C++ 與 Python 不同的地方，那些差不多的語法（if-else, for, while…） 我會在最前面速速帶過，有不懂的話建議回去參照對應的 Python 教學文部分，或是我提供的參考連結。一樣要提的是，我原本是做講義用，文字部分不會太詳盡，有需要更詳盡的內容歡迎聯絡我，如果我有空就可以幫你上課 XD，最後就是轉載請記得標註來源！</p><p><a href="https://hackmd.io/C7kIxIuJQImM_x64fhuM_A?view">HackMD 完整版請點我</a></p><h2 id="基本語法"><a href="#基本語法" class="headerlink" title="基本語法"></a>基本語法</h2><ul><li>參見 <a href="https://cpp.enmingw32.dev/">C++ 語言自學手冊</a>，此不贅述</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Your program starts here</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Variable Types</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> b = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    <span class="type">float</span> c = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">3.1415</span>;</span><br><span class="line">    <span class="type">bool</span> e = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Basic Input &amp; Output</span></span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Control Flow</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a is 0\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a is greater than 0\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a is less than 0\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = 1&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a = 2&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a != 1 &amp;&amp; a != 2&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Loops</span></span><br><span class="line">    <span class="comment">// Both have continue &amp; break</span></span><br><span class="line">    <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Loop &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; N):&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Loop &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Your program ends here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指標（Pointers）"><a href="#指標（Pointers）" class="headerlink" title="指標（Pointers）"></a>指標（Pointers）</h2><p>指標是一個強大的工具，用於指向變數，或直接操作記憶體位置，也是 Python 中沒有的一種變數類別，但卻是個很重要的概念。指標能夠讓我們間接引用變數和物件，並在動態記憶體配置和資料結構中皆發揮了重要的作用。透過指標我們可以訪問和修改記憶體中的數據，提供更高的靈活性和效能。然而，正確使用指標很重要，因為錯誤的操作可能導致記憶體問題，像是存取到未分配的空間等等。</p><p>先介紹兩個運算子：</p><ul><li>&amp;：Address-of Operator, 取址運算子，用以取出變數所在之記憶體位址</li><li>*：Dereference Operator, 取值運算子，用以取出變數所指向位置之值</li></ul><blockquote><p>&amp; 與 * 可以互相抵銷，另外 * 同時也是乘法運算元，要小心喔！</p></blockquote><p>搭配以上兩者之使用，我們便可以使用指標：</p><ul><li>創建指標並指向變數（我們通常將 int* 直接視為一個變數類別）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* aPtr = <span class="literal">nullptr</span>; <span class="comment">// or int *aPtr = nullptr;</span></span><br><span class="line">aPtr = &amp;a;</span><br><span class="line">*aPtr = <span class="number">20</span>; <span class="comment">// we can change the value of a variable by pointer</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any type can be pointed at, for example:</span></span><br><span class="line"><span class="type">int</span>** aPtrPtr = &amp;aPtr;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="comment">// Implementation of Class Car</span></span><br><span class="line">&#125;</span><br><span class="line">Car c;</span><br><span class="line">Car* cPtr = &amp;c;</span><br></pre></td></tr></table></figure><ul><li>指標、變數、* 與 &amp; 的關係</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* aPtr = &amp;a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value of a = &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value of aPtr = &quot;</span> &lt;&lt; aPtr &lt;&lt; endl; <span class="comment">//0x123450</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;address of a = &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//0x123450</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;address of aPtr = &quot;</span> &lt;&lt; &amp;aPtr &lt;&lt; endl; <span class="comment">//0x543210</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value of the variable pointed by aPtr = &quot;</span> &lt;&lt; *aPtr &lt;&lt; endl; <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><!-- ![](https://hackmd.io/_uploads/Sy31aVCS2.png) --><ul><li>動態記憶體配置（DMA）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for integer</span></span><br><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">*ptr = <span class="number">0</span></span><br><span class="line"><span class="comment">// Remember to do this at the end, to avoid memory leak!</span></span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for integer array</span></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;</span><br><span class="line">    ptr[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Remember to do this at the end, to aviod memory leak!</span></span><br><span class="line"><span class="keyword">delete</span> [] ptr;</span><br><span class="line">ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">Don&#x27;t do this, this is for static memory allocation</span></span><br><span class="line"><span class="comment">int N = 10;</span></span><br><span class="line"><span class="comment">int arr[N];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>延伸閱讀：<a href="https://qr.ae/pyFiAo">Why must we use pointer during dynamic memory allocation in C++?</a></p></blockquote><ul><li><p>應用：swap() 實作</p><ul><li>錯誤示範（Recap：區域變數與全域變數）</li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">badSwap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正確示範（注意呼叫時要傳入 int* ！）</li></ul>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodSwap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指標的概念圖<br><img src="https://hackmd.io/_uploads/S11bK4Arh.png"></p></li></ul><blockquote><p>延伸閱讀：<a href="https://husking-studio.com/cpp-pointer-tutorial/">圖解說明指標概念</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>極短篇：碩班第一個月之心得</title>
      <link href="/2023/09/28/short-master-1st-month/"/>
      <url>/2023/09/28/short-master-1st-month/</url>
      
        <content type="html"><![CDATA[<p>距離開學大約經過一個月，昨天突然有感而發，於是就有了這篇簡短的心得文。</p><p>大學做專題的時候，盧老師曾經講過：「做研究要靠興趣支撐」，之前還沒多想，但這句話最近常常浮現在我腦海裡，直到最近大概可以略為體會那種感覺。</p><p>這一個月大概是我人生中學習動力特別高的一段時期。上次有這種感覺是大一初學程式時，那種接觸新領域，思考如何寫 code 叫電腦解決問題的快樂。近期的種種也讓我再次感受到，學習可以很有趣，還有以興趣為支持的重要性。（赫然發現能主修自己有興趣的學科，也是一件很難能可貴的事情，特別是在台灣。很感謝大一的我有做出困難的決定，繼續努力往資訊領域深耕！）</p><p>雖然目前還遠遠稱不上是在作研究，但是不論是看到最新的研究成果，或是在看以前的 paper，總是會發現一些酷酷的東西，而這些酷酷的東西總是讓我覺得很好玩，也很興奮，很期待未來 AI 的發展會走到何處。</p><p>不免俗的還是要說，真的很幸運可以進入資工所念研，每天想到這件事情都還是很快樂，也很感謝在這邊遇到的各位強者，偶爾也會有「不愧是台大，一堆怪物」的感覺在腦中浮現。雖然我現在還處在一團亂的狀態（還是不太會看 paper、不太知道該做啥、還在思考如何整理知識、速度似乎有點慢等等），但我到目前為止都很享受碩班的生活，接下來我也會繼續認真努力加油，還請各位前輩多多包涵弱弱的我。</p><p>最後用之前看到的書摘做結：脆弱的東西因為外力而受到傷害，反脆弱的東西因為外力而得到好處。不拒絕正視自己的不足，才能從錯誤中學習並且成長。</p>]]></content>
      
      
      <categories>
          
          <category> 極短篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Master </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 TSMC 實習的日子 - 2023 夏，台南</title>
      <link href="/2023/09/11/intern-at-TSMC/"/>
      <url>/2023/09/11/intern-at-TSMC/</url>
      
        <content type="html"><![CDATA[<p>繼上篇文章 <a href="https://jackchen890311.github.io/2023/05/24/summer-intern-2023/">2023 年科技業暑期實習面試心得</a> 講述我尋找暑期實習的過程後，這篇文章要來講的是我這兩個月在 TSMC 實習的心得感想。我實習的地方在台南的南科台積十四 B 廠（F14P5），實習單位是廠務數位發展部（FACDD）底下的自動化課，對於土生土長的台北人來說，雖然遠到靠北，但也是個體驗台南生活的好機會，所以會順便分享一些在台南生活的所見所聞。</p><h1 id="六月：行前準備、專案說明"><a href="#六月：行前準備、專案說明" class="headerlink" title="六月：行前準備、專案說明"></a>六月：行前準備、專案說明</h1><p>我大概五月底收到 Offer，考慮了幾天後就答應了，主要是也沒有其他選擇，加上除了台南很遠之外，對公司跟工作內容都算可以接受。接著六月陸陸續續有收到台積電的信，像是要先繳交資料、做體檢、或是未來的 buddy 有先來聯絡我，跟我說明專案情況等等。此時我大部分的時間都在享受最後自由的時光，再利用一些空閒時間稍微看一些關於 IR 影像處理的介紹，還有處理一些雜事，像是準備行李、前公司的專案、刷題、看課外書等等，畢竟之後七八月每天工作、九月後每天研究、畢業後又要繼續工作，能像現在這麼清閒的日子應該是不多了。</p><h1 id="宿舍開箱：華園三期宿舍"><a href="#宿舍開箱：華園三期宿舍" class="headerlink" title="宿舍開箱：華園三期宿舍"></a>宿舍開箱：華園三期宿舍</h1><p>來台積實習的好處就是，公司有提供免費的宿舍與上下班接駁車，只能說大公司的福利真的很讚。台積電的宿舍似乎都是雙人房，設備很基本，就是該有的都有但也沒到太好，但至少整體裝潢蠻新的。我住的華園三期宿舍位在南科裡面，可以說是非常偏僻，除了入口對面有 7-11 與幾家假日不開的餐廳，以及走路 10 多分鐘有個摩斯之外，附近啥都沒有，最近的火車站要走路 20 分鐘，假日也沒什麼公車或接駁車，瞬間有種來到鄉下的感覺，好山好水好無聊。</p><p><img src="/img/post/2023_09/dorm_toilet.jpg" alt="宿舍廁所，有乾濕分離，空間算大"><br><img src="/img/post/2023_09/dorm_desk.jpg" alt="宿舍書桌，那個電視怎麼不用壁掛的，真的超卡位"><br><img src="/img/post/2023_09/dorm_bed.jpg" alt="宿舍床位，離室友有一點點太近"><br><img src="/img/post/2023_09/dorm_window.jpg" alt="宿舍窗景，中庭天氣好時蠻漂亮的"></p><h1 id="Day-1-2：一連串的線上課程、第一次入廠，好興奮！"><a href="#Day-1-2：一連串的線上課程、第一次入廠，好興奮！" class="headerlink" title="Day 1 &amp; 2：一連串的線上課程、第一次入廠，好興奮！"></a>Day 1 &amp; 2：一連串的線上課程、第一次入廠，好興奮！</h1><p>第一天採線上報到，只要在家裡連線聽課程即可，雖然是很方便，但不得不說內容有點乏味，有些東西無聊又一直重複，加上連續七八個小時的課程真的是讓人難以持續專心。課程內容就是簡介台積電的公司歷史與核心價值、介紹實習計畫、相關資源與一些該注意的規則等等。其實我也不知道為何可以講那麼久，但每堂課都講一兩個小時，全部講完就差不多天黑了。</p><p>第二天就是正式報到，在拿完新人包之後，我就跟著我的 Buddy 一起行動（以下簡稱 J）。J 人還蠻好的，都很願意解答我的各種問題。上午主要在參觀工廠，就是有各種很吵很大很貴的機台的地方，因為我之後的工作會碰到巡廠機器人，所以先來大致了解一下；接著就是參觀員工餐廳，還有在路易莎討論跟測試設備。下午回辦公室整理位子、聽線上課程的同時跟 J 討論專案架構，後來被他抓去吃下午茶，第一天就結束了。今天對我來說整個就是開眼界，第一次進到這麼大的公司，到處走走看看真的蠻好玩的！</p><h1 id="七月：理想很豐滿、現實很骨感"><a href="#七月：理想很豐滿、現實很骨感" class="headerlink" title="七月：理想很豐滿、現實很骨感"></a>七月：理想很豐滿、現實很骨感</h1><p>在進來前總是想著這兩個月可以遇到很多很厲害的前輩，可以學到很多大公司才會用的技術與制度等等，結果這個夢大概兩周就破滅了。前情提要一下，當初 <a href="https://jackchen890311.github.io/2023/05/24/summer-intern-2023/#FACDD-AI-x2F-ML-Engineer-Intern">面試</a> 時是由新竹的小主管帶頭面試的（以下簡稱 T），他人很好，也感覺得出他很厲害，也是因為跟他談話很愉快，儘管後來發現是在台南給別人帶，我還是沒有太多顧慮就接受 Offer。</p><p>結果進來才發現與我想像中的大不同，帶我就是上面提到的 Buddy J，是個資歷一年多的新人工程師，對於技術的了解較淺，再加上分配給我的專案（異常分析）定義不清楚，也沒有實際的異常資料可以看就說要做，J 自己也不是太了解，所以我前幾周做得很痛苦，進度也一直沒有太好。也感覺與其說是進來學東西，反倒像是進來做東西幫他們解決問題，似乎跟正職的差異不大。</p><p>此外，這個部門似乎是做 PM 的角色，但不知道為啥卻找實習生進來做 RD 的工作，所以幾乎也學不太到太多技術面的新東西。又因為公司內各種限制，使得我的開發可以說是難上加難，我還得自己花時間解決，因為 J 不做開發所以可能也不熟悉。再加上因為同事間的專案都蠻獨立的，所以也沒什麼機會一起工作或聊天，週會也就是大家輪流報自己的進度給大主管聽，然後通常一報就是兩小時的各種瑣碎小事情，聽不懂之外也十分無聊。</p><p>原本想說就算了待過兩個月就好，結果後來大概月中與 T 以及他手下的實習生（對，還有另一個）一起開會，才發現他們的專案規劃、架構、方法、限制等等都一清二楚，我心裡就暗想：幹，為啥他這麼爽，專案都給得清清楚楚，還可以在很厲害的 T 底下做事情，反觀我在這邊都不知道自己在幹嘛，整個專案都十分模糊也不知道有沒有進展，而七月就在這樣迷迷糊糊也沒啥事情好幹的過程中就結束了。（中間還花了一兩周在等待資料，對，開始做了資料還沒來，因為到後來才決定要去拿）</p><h1 id="八月：趕工趕工大趕工-又沒有事情做了"><a href="#八月：趕工趕工大趕工-又沒有事情做了" class="headerlink" title="八月：趕工趕工大趕工 + 又沒有事情做了"></a>八月：趕工趕工大趕工 + 又沒有事情做了</h1><p>結果前面無所事事的狀態，在八月初迎來了大轉折。原本預計要做出來的東西實在是太簡單，花了我幾天到一周就弄完了，內容上基本也沒啥技術可言，因此在跟新竹的小主管 T 討論過後，決定再針對原本的題目做延伸，並且因為這方面他比較熟悉，所以我接下來的半個月（因為最後競賽的初選在月中，非常的趕，等於你幾乎只有一個月可以做，不知道他們在想啥）主要都會由 T 來帶領。</p><p>這件事對我而言是蠻開心的，因為有機會可以跟 T 緊密合作，並從他身上學習，正是我在七月一進來時的目標之一。T 也確實很厲害，過程中帶給了我不少東西，唯一可惜的地方就是時間真的太少，從八月初開始確定要做來算的話，我們能做的時間只有兩周，根本是完全不夠的。最後，迫於競賽時間壓力，所以我只好瘋狂趕工，上班都沒休息偶爾還會小小加班那種，最後才勉強搞出一個還算可以看的報告。但我個人認為這樣其實是不好的，為了趕工基本上我沒有甚麼反思的空間，就是一直在開發跟回報沒什麼在思考，這樣對於我的學習與成長其實有害。</p><p>總之到月中的競賽發表之後（我沒上最後的競賽，哭哭），我基本上又沒什麼事情可以做了，而帶我的 J 也說看我前面太忙，後面就不再排太多事情給我了，讓我把專案簡單收尾即可，剩下時間就讓我自己安排或看我有沒有想做甚麼。所以我八月中到底除了把原本的專案收尾之外，其他時間就自己看看 paper、到其他廠逛大街、參加一些部門會議、進無塵室晃等等，真的又是沒幹嘛混過半個月，但到這個時候其實我也不想幹嘛了，整個基本上就是心已半死在等離職這樣。</p><p><img src="/img/post/2023_09/F14P5.jpg" alt="F14P5 廠外照片，其實廠區附近應該都不太能拍照，但我還是拍到了"></p><h1 id="台南生活：各種美食吃好吃滿"><a href="#台南生活：各種美食吃好吃滿" class="headerlink" title="台南生活：各種美食吃好吃滿"></a>台南生活：各種美食吃好吃滿</h1><p>平日下班基本上回到宿舍已經六點多，加上上班一整天已經沒啥力氣跑去市區走跳，頂多就是去附近的善化或新市吃個晚餐，所以我大部分去台南市區都是在假日時，搭火車 or 借騎室友的機車去。能在台南生活兩個月確實是個蠻難得的體驗，台南身為台灣的古都，處處充滿著歷史及文化的色彩，加上美味又實惠的在地小吃，以及離市區不遠又能看夕陽的海岸線，真的是讓人都想在這短暫定居了。</p><p><img src="/img/post/2023_09/beef.jpg" alt="來台南就是牛肉湯 &amp; 炒牛肉吃好吃滿！"><br><img src="/img/post/2023_09/ice.jpg" alt="最近很有名的蜷尾家，好吃但好排 QQ"><br><img src="/img/post/2023_09/dan.jpg" alt="南霸天丹丹，平價又好吃"><br><img src="/img/post/2023_09/ramen_tainan.jpg" alt="聽說是台南最好吃的拉麵 - 寶來軒"><br><img src="/img/post/2023_09/street.jpg" alt="神農街街景"></p><h1 id="一些有趣的小知識"><a href="#一些有趣的小知識" class="headerlink" title="一些有趣的小知識"></a>一些有趣的小知識</h1><ul><li>入廠不能帶具有儲存或資料交換的個人裝置，不過台積配發的手機還蠻新的，與一般的智慧型手機很像，可以連 Facebook、Instagram、Youtube 等等，但只能下載特定 App，對於拍照等功能有較嚴格的規定。</li><li>公司電腦也會擋來檔去，但如果連到不允許的網站也不會怎樣，就只是不讓你進去而已。</li><li>很多安檢門與閘門，跟機場很像，到哪都要刷識別證，買東西也可以刷識別證結帳（有餐補），因此識別證很重要！</li><li>餐補很大方，一天補助四餐但有時間限制，午晚餐一餐各是 50 元，加上內部的食物都很便宜，許多商店還有額外折扣，像小七就是直接 85 折。</li><li>這邊雖然很偏僻，但有實習生接駁車、台積環廠車、南科園區車等等，所以平日還算 ok；只不過假日啥都沒有只能靠自己，推薦還是要有機車，否則就是 u bike + 火車 + 雙腳移動。還好我室友人很好願意讓我蹭車，不然我沒把車運下來真的是一個錯誤的決定。</li><li>不同部門差異很大，我的部門很新才成立一兩年，似乎是個蠻爽的部門，大部分時間都超準時下班，中午有一小時半的午休，甚至來得及去其他廠晃晃吃飯再回來，不過偶爾也會加個小班就是了。</li><li>實習生也可以參加各種公司活動或福利，像是線上講座、家庭日、T Gym 等等，也有各種實習生專屬活動，像是必修講座、學院參訪、NTC 參訪、還有最終競賽（但完全我的廠跟部門沒有交流認識環節，很難認識同事跟室友以外的人，像我附近只有我一個實習生真的超級孤單 QQ）。</li></ul><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>雖然實習過程中有各種想法、意見與不滿，但我還是沒有後悔來台南 TSMC 實習的這個決定（畢竟不來就是去研華做資料清洗師 or 在家耍廢打電動 XD）。這兩個月對我而言是個難得的機會，得以一窺台灣數一數二的大企業，以及其公司內部風氣、制度等等，也去了無塵室、廠務區、新訓中心、各廠餐廳等等各種新奇有趣的地方，更透過這次的機會收穫了一些厲害的人脈（但還是不多因為被 HR 丟包，氣氣氣）。但我必須很老實的說，經過這次實習體驗，我想我未來應該是不會太想回到台積電上班了，儘管薪水確實是不賴，但裡面的風氣還是相對傳統以及保守，相較之下我更喜歡自由、開放、活潑的環境。而這也是實習的好處之一，可以透過兩個月的時間來親身感受公司的風氣與氛圍，就更能做出比較不會後悔的決定，還是會推薦大家有機會可以來實習看看。</p>]]></content>
      
      
      <categories>
          
          <category> 工作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internship </tag>
            
            <tag> TSMC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>極短篇：The Oatmeal Problem 與 No Man&#39;s Sky</title>
      <link href="/2023/07/31/short-no-man-sky/"/>
      <url>/2023/07/31/short-no-man-sky/</url>
      
        <content type="html"><![CDATA[<p>新的系列開始囉！這個系列我打算分享我打在 <a href="https://www.facebook.com/jack.chen.89311">臉書</a> 上的文章，可能就是一些極短篇，可以在 3 - 5 分鐘內讀完的那種。內容就不一定，但大多應該會是我覺得很酷的東西，應該比較偏向資工或 AI 方面的科普吧，主要就以分享或探討為主。</p><p><img src="/img/post/2023_07/nomanssky_game.jpg" alt="Gameplay from The Game: No Man&#39;s Sky"></p><p>今天要分享的是在看 Paper 時偶然看到覺得很有趣的一個問題：The oatmeal problem。The oatmeal problem 指的是在 procedural generation 或任何 generative process 裡面會遇到的一個問題，當你大量生成看似不同但本質上沒有太大差異的 content 時，對於使用者來說其實是沒有甚麼意義的。舉個例子來說，若我今天生成 10000 碗燕麥粥，碗中的燕麥都以隨機的方式擺放，雖然數學上來說他們都是不同且獨一無二的，但對使用者來說他們就只是一堆燕麥粥，並沒有甚麼差異。因此在 creative generation 中，如何讓使用者不會感到單調無趣，是個需要考慮的問題。</p><p>有感觸的原因是這款遊戲我本人幾個月前才買，結果玩沒多久就覺得膩了便棄坑。當初看到 No man’s sky 打著「程式生成的超大遊戲地圖」還有宇宙主題就覺得很酷，但玩到後來就覺得，好像怎麼玩都差不多，不論去到甚麼地方地圖都可以預測，也不會帶給我太多的新鮮感。這個案例中，我（使用者）對遊戲中大量重複產生卻了無新意的各個星系地圖（燕麥粥）感到乏味。</p><p>在最近 generative AI 很熱門的時代，若未來要將此技術應用於文創或娛樂產業，也許如何讓使用者不會對 generative content 產生疲乏，的確是一個需要考量的問題。</p><p>Reference: <a href="https://www.challies.com/articles/no-mans-sky-and-10000-bowls-of-plain-oatmeal/?fbclid=IwAR2V6z6e_prQQhtV7vR9PcH08RX6jRMFuD-WTC9B3_z95YW3V3SB7bythZA">https://www.challies.com/articles/no-mans-sky-and-10000-bowls-of-plain-oatmeal/?fbclid=IwAR2V6z6e_prQQhtV7vR9PcH08RX6jRMFuD-WTC9B3_z95YW3V3SB7bythZA</a></p>]]></content>
      
      
      <categories>
          
          <category> 極短篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game </tag>
            
            <tag> Generative </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023 年科技業暑期實習面試心得</title>
      <link href="/2023/05/24/summer-intern-2023/"/>
      <url>/2023/05/24/summer-intern-2023/</url>
      
        <content type="html"><![CDATA[<p>在正式進入研究所前的暑假，有人會拿來大玩特玩、有人要先進實驗室做準備、而我則是選擇將這兩個月投入實習。主要是因為自己還沒有甚麼大公司實習的經驗，加上也希望早日體驗不同的工作內容，在未來選擇第一份工作時會比較有方向。我在今年一到四月陸陸續續投了十幾家公司，皆以大公司暑期實習為主，職位包含 Software Engineer、Data Scientist 等等，也因為我只投暑期實習，加上不想再去新創，因此公司選擇上有一定的限制。這篇文章就簡單分享我的面試過程與心得，然後我很爛大家就看看笑笑就好。另外，聽很多人說今年的缺比去年少很多，也比較難拿到面試機會與 Offer，不知道這種狀況何時才會好轉。</p><h1 id="面試紀錄"><a href="#面試紀錄" class="headerlink" title="面試紀錄"></a>面試紀錄</h1><p>以下粗略地按照投遞時間排序。</p><ul><li>投遞履歷：15 家公司</li><li>面試邀請：6 家公司 13 個職位</li><li>Offer Get：2 家公司 2 個職位</li></ul><p>最後決定去 TSMC 的廠務數位發展部擔任暑期實習生。</p><h2 id="Google-SWE-Intern"><a href="#Google-SWE-Intern" class="headerlink" title="Google - SWE Intern"></a>Google - SWE Intern</h2><p>結果：直接感謝信，枉費我還有請人內推……</p><h2 id="Yahoo-DevOps-Intern"><a href="#Yahoo-DevOps-Intern" class="headerlink" title="Yahoo - DevOps Intern"></a>Yahoo - DevOps Intern</h2><h4 id="第一關（3-10）-線上技術面談"><a href="#第一關（3-10）-線上技術面談" class="headerlink" title="第一關（3&#x2F;10）- 線上技術面談"></a>第一關（3&#x2F;10）- 線上技術面談</h4><p>面試前瘋狂刷 Leetcode，結果完全不是 Coding Interview，而是技術相關問答，再加上還用英文，我幾乎是完全死亡。而且我對 DevOps 真的是不太了解，有次跟同事聊到他說 DevOps 比較偏向佈署相關，與開發的相關性較小，那時候沒當一回事，所以也沒特別準備相關知識，結果就是他問的問題大概有 1&#x2F;3 我都說 I don’t know。問題內容包含 Linux 基礎命令與一些硬體相關問題，像是查看電腦設備訊息、監控電腦現在狀態、磁碟機分割處理、偵錯與除錯方式、開機順序等等。面完就覺得應該涼了，不過他一開始有說暑假要是學生，但我不是，不確定是不是因為這樣所以直接沒後續，但我猜回答太爛的機率應該比較大。（早知道當初把 SWE 志願序排前面…）</p><p>結果：雙雙感謝信，不意外因為 DevOps 真的面太爛，SWE 沒面過就感謝信了。</p><h2 id="Qualcomm-Computer-Vision-Intern"><a href="#Qualcomm-Computer-Vision-Intern" class="headerlink" title="Qualcomm - Computer Vision Intern"></a>Qualcomm - Computer Vision Intern</h2><p>結果：無聲卡。</p><h2 id="TSMC-DNA-Program"><a href="#TSMC-DNA-Program" class="headerlink" title="TSMC - DNA Program"></a>TSMC - DNA Program</h2><p>台積電的模式好像是履歷會分派給各部門，由各部門自己約面談，每個部門的方式也不一樣。</p><h3 id="DMKD-SWE-Intern"><a href="#DMKD-SWE-Intern" class="headerlink" title="DMKD SWE Intern"></a>DMKD SWE Intern</h3><h4 id="第一關（4-7）-線上主管面談"><a href="#第一關（4-7）-線上主管面談" class="headerlink" title="第一關（4&#x2F;7）- 線上主管面談"></a>第一關（4&#x2F;7）- 線上主管面談</h4><p>我收到的這個部門其實我也不太熟，聽說還不錯，但反正是 SWE 就去面了。面試人員有兩個主管，看起來一個偏電一個偏資（我亂猜的），問的問題很基本，沒什麼技術問題，比較像是在聊天跟了解我的經歷，也可能因為我偏電的領域經歷不多，所以沒什麼問，但他有提到我要自己再加強這塊。被問到的有自我介紹、簡單生涯問題、機器學習用過甚麼模型、挑模型注重的點等等，剩下時間都在介紹部門跟讓我提問。主管說這個部門主要在協助其他部門，做 Automation 或將 Design Rule 從自然語言轉成特定程式語言等等，可能會碰到一些 EDA Tools，也有可能會使用到機器學習技術，所以他挑的都是有機器學習相關背景的。最後他跟我透漏他只挑了三個人面試，會從中選一個，大概兩周後會告知我結果，瞬間覺得錄取機會上升不少！（但我覺得我面的沒有太好嗚嗚，要再加油）</p><p>結果：主動寄信詢問結果，對方回信表示希望先找快畢業的故婉拒。其實面試時就有提到，他們希望找畢業會進去他們部門的，但我不知道還有沒有其他原因影響 QQ。</p><h3 id="RD-Process-Engineer-Intern"><a href="#RD-Process-Engineer-Intern" class="headerlink" title="RD Process Engineer Intern"></a>RD Process Engineer Intern</h3><h4 id="第一關（4-21）-線上主管面談"><a href="#第一關（4-21）-線上主管面談" class="headerlink" title="第一關（4&#x2F;21）- 線上主管面談"></a>第一關（4&#x2F;21）- 線上主管面談</h4><p>收到這個面試邀請時覺得很怪，因為職稱一看就是製程相關， Qualification 也些希望是化工、材料、物理相關領域，不過 Responsibility 是寫 ML 啦，所以應該是要作製程的 ML，想了一下還是面面看。這次的主管前面比較嚴肅，除了生涯基本問題、ML 相關經歷與背景外（他有問關於工程的背景，我講說我修過電路學，還有上過一些工程相關的課程等等），也有描述他們目前遇到的情況，問我要如何使用 ML 技術來解決。主要是給定製程參數與 TEM 切片，如何判定是否有 defect，我回答可以分別用兩個模型分開處理數值與圖片資料，再把結果結合來判斷，或是嘗試看看用 Multi-modal 的模型架構來試試看。從面試官給的反饋來看他應該不太懂 ML（後面他說他做蝕刻），不過他說裡面有已經在做的工程師啦，不用擔心沒人帶，工作內容應該主要就只有 ML。</p><p>接著我問了一下部門相關的問題，他說他們是在製程的最前段，也就是研發新製程的部分，後面還有 Development 跟 FAB 等等團隊，所以如果進去，感覺可以一窺 TSMC 的最新技術？（雖然我應該也看不懂哈哈）最後他有問說我面的其他部門還有偏好；跟可以不可以提早進去，像是五六月之類的。提早進去這部分，殺的我有點措手不及，跟他說最早大概五月中下（我的自由兩個月又要泡湯了嗎…），可以之後再討論看看，感覺整體面下來還算有機會，但不知道競爭的人多不多，預計三個禮拜內會收到結果。</p><p>結果：無聲卡。</p><h3 id="FACDD-AI-ML-Engineer-Intern"><a href="#FACDD-AI-ML-Engineer-Intern" class="headerlink" title="FACDD AI&#x2F;ML Engineer Intern"></a>FACDD AI&#x2F;ML Engineer Intern</h3><h4 id="第一關（5-3）-線上主管面談"><a href="#第一關（5-3）-線上主管面談" class="headerlink" title="第一關（5&#x2F;3）- 線上主管面談"></a>第一關（5&#x2F;3）- 線上主管面談</h4><p>這個部門是台積的智慧數位發展部門，主要好像也是類似協助內部的部門單位。這次面試我就有簡單準備個人簡歷投影片了，效果看起來還算不錯，至少我講的時候有東西看，讓我比較心安。這次的流程是主管先介紹部門跟工作內容，聽起來主要也是開發其他單位需要的模型，他有舉個例子像是智慧監控溫度與調整冰機等等，但是就單純訓練跟開發模型而已，其他部分會交由 IT 包成可以使用的服務，所以算是夾在 User 跟 IT 之間的部門。正職的實際工作內容可能有 70% 在跟 User 討論並確立架構與方法可行性，30% 才是在實際開發；實習生的話差不多是反過來，以開發為主，加上時間也不長，前後扣掉應該也剩一到一個半月。後面就交由我自我介紹，並且他們會中間打斷問有興趣的問題。我感覺他們是真的對我經歷蠻感興趣的，對於每個專案都有問方法以及我扮演的角色，還有確認我的各種技能樹等等（有點心虛，有些碰過但都快忘記的也說有碰過大概會，不知道我的大概跟他認為的大概一不一樣），同時面試官也會跟我聊很多延伸話題，最後也有一個面試官說我的經歷是他們面試過七個人中算是最不錯的，我也是最後一個面的，開勳。（主要面試官蠻健談的，但我也講了很多話，所以 1 小時 50 分鐘面試完整個快虛脫，但感覺聊得不錯）除了針對經歷問之外，也會問一些生涯、個性、職涯相關問題，面試官也表示可以老實講，不用因為是面試有所保留，講完他也會給我一些他的想法，整體面起來感覺蠻愉快的，面試官們感覺也都很厲害，好像還有幾個是博士。</p><p>FACDD 面完過兩三天收到後續測驗的邀請以及人資關，雖然不確定是哪個部門發的（後來確定應該是 FACDD），但還是很開心！</p><h4 id="第二關（5-9）-竹科英文-適性測驗"><a href="#第二關（5-9）-竹科英文-適性測驗" class="headerlink" title="第二關（5&#x2F;9）- 竹科英文 &amp; 適性測驗"></a>第二關（5&#x2F;9）- 竹科英文 &amp; 適性測驗</h4><p>這天起了個大早前往新竹，結果路上小災難不斷，先是北車找不到機車位只好花錢停很遠；要買票時又剛好錯過上一班客運；到了清大站想說看起來離台積七廠很近，直接騎 ubike 過去應該可以，結果差點沒被新竹的接連上坡搞死，還好今天天氣很涼爽，不然我真的熱死在路邊。我時間留的還夠，省去吃午飯的時間後大約 13：10 抵達，距離兩點面試還不久，但我也就不吃東西先進去等了。七廠入口還蠻氣派的，很有大企業的感覺，還有專人接待，不愧是護國神山啊！一進去就先收手機跟確認身分，然後在旁邊等叫人，我大概等了 10 ~ 20 分鐘左右，跟其他五個人一起進去電腦教室做測驗。作測驗前 HR 會解釋測驗做法，還有一本小說明，另外我事前有用英檢證明抵免，所以只要做適性測驗就好，不確定標準但有英檢相關證照的話都可以問問看，考試內容聽說就跟多益差不多。</p><p>其實適性測驗沒啥困難的，基本上就誠實作答就好，但也要想一下他們可能覺得怎樣的答案會比較好，然後如果你生性悲觀或是最近特別憂鬱的話，不要表現得太明顯 XD。另外之前有看到網路上說，看到「喜歡服從上司命令」類似這種的直接給他選超級符合就對了，我是不知道這來源的真實性啦，不過如果真的這樣的話那這測驗應該改叫奴性測驗（或是這真的是奴性測驗？）。時間限制是 30 分鐘，我大概花 20 分鐘，我這輪有一個女生大概 5 分鐘就交卷閃人。接著都做完後，他還叫我填一張詭異的單子，內容是在問說你可不可以長時間久站、忍受噪音跟搬重物、有沒有色盲等等的，我心想 WTF 我不是面 AI&#x2F;ML 相關的缺嗎，沒可能還要充當設備輪班用吧？再三確認後他還是讓我填，我就…好吧乖乖填。</p><p>在填的時候順便偷聽到旁邊 HR 在跟其他人講話，結果居然聽到隔壁英文考試沒過，HR 問她要不要複習一下再補考一次，重點是還接連兩個人都沒過，還有一個真的有帶講義直接就地開始念。我整個大問號，心想哇勒竟然真的會有人沒過，然後竟然還可以重考，再來還直接開念，整個是開了眼界，是真的考很難還是英文爛的都來台商了？後來我就填完那個詭異的問卷，拍拍屁股高歌離席了，結束今天來竹科的面試，剩下的時間我就在新竹亂晃亂吃，待到晚上才回台北，畢竟都跑一趟了順便晃晃也不錯。</p><h4 id="第三關（5-10）-線上-HR-面談"><a href="#第三關（5-10）-線上-HR-面談" class="headerlink" title="第三關（5&#x2F;10）- 線上 HR 面談"></a>第三關（5&#x2F;10）- 線上 HR 面談</h4><p>有聽說會跟之前寫的應徵人員問卷很相關，所以要記得複習一下寫的內容呀！（我之前好像寫得稍微隨興QQ）我覺得我這天狀態不是太好，特別是中間還收訊不好關掉攝影機，結果關掉後我反而更慌，感覺講出來的話都不夠有組織跟架構，希望不會影響到結果…。人資這邊主要分三關，個人資料核對、Behavioral Questions、相關提問，整體大約 40 分鐘。前面個人資料就照實回答應該沒什麼大問題，Behavioral Questions 這邊主要問最大的挫折、團隊合作中有遇到別人落後的狀況嗎、記不記得主管說的工作內容並簡述、其他面試的公司等等，還有了解一下你對 on call 跟調去中南部工作的看法，我老實回答說可以接受，但不希望太頻繁，不知道這樣會不會扣分？最後問了他台積喜歡具有創造力的人還是聽話的人 XD，他跟我說看職位，看來前面講的應該適用於作業員或設備。人資整體給人的感覺蠻好相處的，不太會刁難你，基本上自己不要太緊張就好，希望我表現得還可以嗚嗚嗚。最後他說還要等兩到三周才有通知，從三月初投遞到現在五月初了還沒結果，真是折磨…。</p><h3 id="後續確認與核對（5-15、5-16、5-19）-HR、面試官、未來同事"><a href="#後續確認與核對（5-15、5-16、5-19）-HR、面試官、未來同事" class="headerlink" title="後續確認與核對（5&#x2F;15、5&#x2F;16、5&#x2F;19）- HR、面試官、未來同事"></a>後續確認與核對（5&#x2F;15、5&#x2F;16、5&#x2F;19）- HR、面試官、未來同事</h3><p>5&#x2F;15 收到 HR 打來的電話，主要就是再跟我核對一次資料，以及確認我目前的意願，確認後就會往上呈報，審核完畢才會有聘書下來。這邊我遇到一個有點詭異的事情，詳見 <a href="https://www.dcard.tw/f/tech_job/p/242065581">這篇文章</a>，不過面試官隔天有打電話來說明狀況啦，也有順便提到是有錄取我，所以後續如果沒問題應該可以 Offer Get。5&#x2F;19 又收到一通電話，這次是未來的同事打來的，主要就是確認我知道狀況，還有讓我問一些工作問題，確認都 OK 而已。到這邊確認拿到 Offer 應該八九成了，不出意外的話。</p><p>結果：Offer Get（5&#x2F;24），最後也就去這個了，因為也沒別的可以選 XD。</p><h2 id="Kronos-SWE-Intern-Quantitative-trading"><a href="#Kronos-SWE-Intern-Quantitative-trading" class="headerlink" title="Kronos - SWE Intern (Quantitative trading)"></a>Kronos - SWE Intern (Quantitative trading)</h2><h4 id="第一關（4-4）-Codility-Online-Coding-Test"><a href="#第一關（4-4）-Codility-Online-Coding-Test" class="headerlink" title="第一關（4&#x2F;4）- Codility Online Coding Test"></a>第一關（4&#x2F;4）- Codility Online Coding Test</h4><p>時限 2.5 小時共 5 題，語言限定 C++ &#x2F; C++20，內容包含選擇題、Array、Graph、Bit 等等主題。</p><ol><li>選擇題：關於 C++ 的觀念題，包含 copy constructor、virtual destructor、memory allocation 等等。</li><li>Array - 最大遞減-遞增距離（Non-strictly Valley Array）：給定一個 Array A，尋找最大的先遞減後遞增子陣列，相等也算，回傳其長度。（我簡化過，反正就差不多這個意思）</li><li>Graph - 消除總回合：給定一無向圖，每回合會消除 Total Path 小於等於一條的節點，回傳直到沒有結點繼續消失的回合數。 </li><li>Array - 最大交錯總和：給定一個 Array A，可以刪除任意數量的元素，使得 A[0] - A[1] + A[2] - A[3]… 最大，並回傳最大值。</li><li>Bit - Base -2 adder：實作一個 -2 進位的加法器，給定兩個 0、1 組成的數字，回傳其相加結果。</li></ol><p>選擇不太確定正確率，但我最後除了第四題都有寫完，測資都有過，第四題因為 Graph 的題目跟 Vector 的操作實在是不熟，最後只有骨架大概完成，不過我覺得這樣已經還可以了，畢竟我真的很久沒寫 C++。</p><p>結果：感謝信，果然沒全對還是不夠吧…</p><h2 id="Mediatek-SWE-IT-Intern"><a href="#Mediatek-SWE-IT-Intern" class="headerlink" title="Mediatek - SWE &#x2F; IT Intern"></a>Mediatek - SWE &#x2F; IT Intern</h2><p>結果：無聲卡，我朋友有拿到 offer，我完全沒收到任何後續 QQ，有聽說今年只收碩一，不知真假。</p><h2 id="Appier-Engineer-Intern"><a href="#Appier-Engineer-Intern" class="headerlink" title="Appier - Engineer Intern"></a>Appier - Engineer Intern</h2><p>結果：感謝信，好難過。</p><h2 id="Wistron-SWE-Intern"><a href="#Wistron-SWE-Intern" class="headerlink" title="Wistron - SWE Intern"></a>Wistron - SWE Intern</h2><p>結果：無聲卡。</p><h2 id="Acer-RD-DS-Intern"><a href="#Acer-RD-DS-Intern" class="headerlink" title="Acer -  RD &#x2F; DS Intern"></a>Acer -  RD &#x2F; DS Intern</h2><p>結果：感謝信，真是傷心。</p><h2 id="Advantech-SWE-Intern"><a href="#Advantech-SWE-Intern" class="headerlink" title="Advantech - SWE Intern"></a>Advantech - SWE Intern</h2><p>有收到 SWE &amp; FWE 的邀請，總共面了三個職位，SWE 分 A、B 兩組，有很多議題可以做優先排序。在五月中又有收到 SWE_B 的 SWE&#x2F;FWE 面試邀請，但因為那時已經差不多收到台積電的 Offer 了就沒有接受。</p><h3 id="Firmware-R-D-Intern"><a href="#Firmware-R-D-Intern" class="headerlink" title="Firmware R&amp;D Intern"></a>Firmware R&amp;D Intern</h3><h4 id="第一關（4-20）-線上主管面談"><a href="#第一關（4-20）-線上主管面談" class="headerlink" title="第一關（4&#x2F;20）- 線上主管面談"></a>第一關（4&#x2F;20）- 線上主管面談</h4><p>其實這個職位我沒啥興趣，是人資打給我問我要不要，說可以面面看也沒差，所以我還是答應面試了。面試流程也只有自我介紹跟工作介紹，後面就是針對經歷或工作提問，我感覺他們似乎對我興趣不大（可能我專案都是 Python 居多），但我也對他們興趣不大，所以就…有點小尬。這份工作主要在研究 WIFI Mesh，從既有的標準上去改良其最佳路徑演算法，並且會花比較多時間研究 WIFI Mesh 的標準與架構等等，後面測試會在 Embedded Linux 上寫 C，不過主管說兩個月應該做不完。</p><p>結果：感謝信，微難過。</p><h3 id="SWE-B-Intern-GPT-3-Algorithm"><a href="#SWE-B-Intern-GPT-3-Algorithm" class="headerlink" title="SWE_B Intern (GPT-3 Algorithm)"></a>SWE_B Intern (GPT-3 Algorithm)</h3><h4 id="第一關（4-28-早上）-線上團體主管面談"><a href="#第一關（4-28-早上）-線上團體主管面談" class="headerlink" title="第一關（4&#x2F;28 早上）- 線上團體主管面談"></a>第一關（4&#x2F;28 早上）- 線上團體主管面談</h4><p>深刻感受到團體面試的冗長，1.5 小時有 3&#x2F;4 的時間都在聽別人講話，真累…。主要分為三部分，自我介紹與對實習的想法、相關技術開放式問答、給他們的問題，也沒問幾題就花了一個半小時。最前面的自我介紹每個人花大概五分鐘，怕可以發揮的地方不多，我有特別講的細一點，還有人做投影片講太細被打斷，講完後就是主管問有興趣的問題；技術問答只有兩題：預想會怎麼進行此專案（用 GPT4 打造客服 &#x2F; 內部除錯助手），ChatGPT 目前對你有甚麼影響與幫助，以舉手搶答方式回答，但也會讓每個人都講完。</p><p>整體面下來感覺還行，我都有給出我認為還行的答案，加上經歷應該算是有相關，也許有機會。其他幾位分別是碩一與大三，只有一位我感覺經歷稍微豐富一些，表現得也算比較積極。最後主管說前面面過兩次，所以大概就是 12 人取 2，等等看有沒有機會囉。然後工作地點在林口，早上七點有交通車，真他媽遠…。</p><p>結果：感謝信，真奇怪我覺得這場面的比下午好，但怎麼是下午 Offer Get 這場感謝信 @@。</p><h3 id="SWE-A-Intern-Full-Stack-Power-BI"><a href="#SWE-A-Intern-Full-Stack-Power-BI" class="headerlink" title="SWE_A Intern (Full-Stack&#x2F;Power-BI)"></a>SWE_A Intern (Full-Stack&#x2F;Power-BI)</h3><h4 id="第一關（4-28-下午）-線上團體主管面談"><a href="#第一關（4-28-下午）-線上團體主管面談" class="headerlink" title="第一關（4&#x2F;28 下午）- 線上團體主管面談"></a>第一關（4&#x2F;28 下午）- 線上團體主管面談</h4><p>早上面完下午又繼續，真的是很累人啊，值得欣慰的是還看到早上的熟面孔，他應該跟我一樣累。這場跟早上很類似：一樣有自我介紹與對實習想法、一題技術開放式問答、最後是由人資問兩個問題。技術問答是問開發儀表板需要注重的細節與原因；人資部分則是問最大的挫折、以及別人形容你的缺點，沒有搶答就照隨機順序回答。</p><p>這個我覺得沒有上午的面的好，因為有點小累，加上這組五個人三個都有做自介簡報，讓我深刻的檢討自己是不是也需要搞一個這種東西。不過工作內容似乎比較偏向資管，主要是整理資料與儀表板開發，說白了就是不斷清資料跟畫資料，還有跟使用者討論需求，老實說我的興趣沒有上午面的大，不過至少這個是在內湖，比較近。</p><p>結果：Offer Get，但我最後拒絕了，因為工作內容興趣不大，加上要一整年太長了。而且就我看起來，他們應該是想要找資料處理實習生的感覺，面試中也說好像不太會碰到後端，就是一直打造不同的儀表版。但薪水是蠻不錯的啦，如果做一整年應該可以賺不少。</p><h2 id="Innolux-NLP-Intern"><a href="#Innolux-NLP-Intern" class="headerlink" title="Innolux - NLP Intern"></a>Innolux - NLP Intern</h2><p>之前校招留資料，後來收到他們聯繫，有趣的是先被 SWE 聯繫了兩次，兩個人好像彼此還不知情。後來發生的事情有點無言，原本是先投 SWE 要面試，但 NLP 的後來才來信說對我經歷感興趣，問我要不要面，兩者只能選一個。接著我選了比較想做的 SWE 後，過幾天又收到 NLP 的電（ㄙㄠ）話（ㄖㄠˇ），跟我說 NLP 比較缺人，我的經歷比較符合，希望我去面 NLP 而不讓我去面 SWE，我只能勉強答應。然後他問我有沒有更多資料可以給他，我問他不是都在系統上了嗎？他說喔喔好那他再去確認，然後又問說可不可以跟我改時間，但我跟他說我那天要上班，是特地請假面試，他說好那他再幫我協調，總之人資感覺不太專業 @@。</p><h4 id="第一關（4-24）-線上主管面談"><a href="#第一關（4-24）-線上主管面談" class="headerlink" title="第一關（4&#x2F;24）- 線上主管面談"></a>第一關（4&#x2F;24）- 線上主管面談</h4><p>面試前半小時還發簡訊，十分鐘前一直打電話給我，時間就還沒到真的不知道在急啥。然後最後主管說他那邊只有一個缺，但很多人來面，SWE 的缺更多，我真的是越來越搞不懂人資在幹嘛了…（還是其實是他打發我？）面試過程大概是自我介紹、問基本經歷跟一些技術問題，而且來了三位面試官，針對我過往的專案問的都蠻詳細的，還有不斷追問細節怎麼做等等，可能也因為我 NLP 相關的專案算是不少。技術問題問了蠻多種類，從 NLP、CNN、我做的網站、資料庫、版本控制都問，真的是包山包海，也還好我大部分都算是回答得出一點東西。最後面了快一小時半才結束，後面問部門跟工作內容時才發現，作的內容跟 JD 也不一樣，會著重在導入一些 GPT 相關的技術等等，主要工作是模型訓練與開發流程，人資啊人資你這樣遲早飯碗會不見…</p><p>結果：無聲卡。</p><h2 id="UMC-Smart-Manufacturing-Intern"><a href="#UMC-Smart-Manufacturing-Intern" class="headerlink" title="UMC - Smart Manufacturing Intern"></a>UMC - Smart Manufacturing Intern</h2><p>結果：無聲卡。</p><h2 id="Synology-Product-Developer-Intern"><a href="#Synology-Product-Developer-Intern" class="headerlink" title="Synology - Product Developer Intern"></a>Synology - Product Developer Intern</h2><p>在 104 上收到 HR 聯繫，不過他的邀請是 SWE in Test，加上是全年的，所以我就問他有沒有暑期實習。過幾個小時他就直接打給我約這份暑期的一面了，還跟我說有白板題，怕死 QQ。後來查了一下，群輝似乎很熱門，看面試內容也不簡單，大概也是不好上，所以我去面試之前就覺得基本上應該是沒機會了，抱著練習面試的心態去學習。</p><h4 id="第一關（4-26）-實體面試（板橋總部）"><a href="#第一關（4-26）-實體面試（板橋總部）" class="headerlink" title="第一關（4&#x2F;26）- 實體面試（板橋總部）"></a>第一關（4&#x2F;26）- 實體面試（板橋總部）</h4><p>板橋真的離我好遠… 提早了一個半小時出門，忘記帶證件還麻煩 HR 跑一趟，好在她看起來人蠻好的，上去的路上跟他聊了幾句。面試總時長大約 1.5 小時，主要分成三個部分：個人簡歷相關、技術問答、還有最可怕的白板題。（聽別人說還有 HR 關，我沒有可能是因為時間不夠，不然應該就是當場直接涼去）</p><ul><li><p>個人簡歷：基本上就會追著你放在履歷上的東西問，像是工作、專案、學經歷等等，只要他們有興趣都會問。真的是問的蠻細的，有些技術我只是摸過不太熟，但因為專案有用到還是有放，就有被抓出來問，當下就…老實的跟他說明，看來放過多也是失策。</p></li><li><p>技術問答：我覺得這部分我沒有答得很好，有些基本功還需要再加強。主要考題是 OS、OOP 相關，OS 部分問了記憶體中的 stack &amp; heap、process &amp; thread，OOP 就是問三大概念，其他還有問 virtual function 是甚麼、TCP &amp; UDP 的差異、DFS &amp; BFS 等等，我有幾題沒有答出來，連 virtual function 都忘光光，感覺這麼基本應該要全都會才行，唉，但最近實在是沒啥精力去複習，直到面試前幾天才在抱佛腳，不應該呀…。</p></li><li><p>白板題：很幸運白板題有看過類似的，所以應該有給出還可以的可行解。題目難度體感介於 Leetcode Easy ~ Medium 之間，主要跟 array 有關，面試官會要求最後要寫成可執行的 code，我選用比較熟悉的 Python 避免語法忘記爆掉。完成後會要求你 Dry Run 一筆測資確定正確性，並請你分析複雜度。我在過程中不斷修修改改，好在最後總算靠自己的力量寫出來，沒有卡關太長或受到面試官質疑。接著還有一題 follow up，面試官說不用寫完，稍微講想法就好，我給了一個我知道比較糟的解法，還有一個比較好但還沒想完整的解法，然後大概是因為時間因素他就喊停，我比較好的解法沒有想完。</p></li></ul><p>後來他們說要出去討論，出去了十多分鐘，就叫我回家等通知了。整體面下來比我預想的好一點，工作內容感覺也蠻多樣有趣的，人生第一次白板題結果應該還可以，之後要努力刷題跟練習邊寫邊講，雖然面完我還是覺得不會上。然後過程中其實都沒聽到面試官的反饋或是想法，連在白板題也幾乎都是我自己一個人唱獨角戲，真是淒涼…。過一陣子回高中拜訪老師時，發現他以前教過的學生（我的學姊）在裡面工作，趕快叫他幫我說點好話 XD，世界真小。</p><p>結果：主動在 104 上詢問結果，詢問過後一周收到感謝信，蠻難過的，因為真的有點想去這家。有聽說同所的學長拿到 Offer，希望我明年也拿得到。</p><h2 id="Synopsys-EDA-Web-RD-Intern"><a href="#Synopsys-EDA-Web-RD-Intern" class="headerlink" title="Synopsys - EDA &#x2F; Web RD Intern"></a>Synopsys - EDA &#x2F; Web RD Intern</h2><p>原本以為要在學生才能申請，結果寄信問他說我可以（那你就不要寫在學生嘛…正常來說大四生碩一的暑假都不算在學生啊…），所以雖然有點晚了但還是有丟。</p><p>結果：收到信說會開始篩選，隔了很久後收到感謝信。</p><h2 id="ASUS"><a href="#ASUS" class="headerlink" title="ASUS"></a>ASUS</h2><p>收到他主動聯繫，忘記他是問哪個職位，但只有整年的，所以我回絕面試了。後來發現好像有暑期實習，但看到的時候已經截止了，哭哭。</p><p>結果：沒有投遞，也沒有接受面試邀請。</p><h2 id="Trend-Micro-SWE-Intern"><a href="#Trend-Micro-SWE-Intern" class="headerlink" title="Trend Micro - SWE Intern"></a>Trend Micro - SWE Intern</h2><p>五月中才投的，我也不知道我投幹嘛，人家 3&#x2F;20 就開始線上測驗了，只是我還沒等到好的 Offer，就順手投一下。這麼晚投應該是丟水溝了，反正我就按幾個鍵，沒啥損失，之前沒投好像是以為只有整年實習，還是甚麼原因我也忘了。結果過幾天收到他的線上 Coding Test 邀請，竟然還有機會嗎，完全沒想到。</p><h4 id="第一關（5-14）-Codility-Online-Coding-Test"><a href="#第一關（5-14）-Codility-Online-Coding-Test" class="headerlink" title="第一關（5&#x2F;14）- Codility Online Coding Test"></a>第一關（5&#x2F;14）- Codility Online Coding Test</h4><p>做之前先查了一下網路評價，發現有人說很簡單有人說很難，所以我也不知道到底是怎樣，後來發現可能是實習簡單正職難，總之我寫起來覺得還好。一共三題，語言可以選 C++、C、Java、Python 等等，還蠻多種可以挑的，三題分別跟 String 與 Array 相關，難度界在 Easy ~ Medium 之間，時限 2 小時。</p><ol><li>Remove BANANA - 檢查一字串可以被移除 “BANANA” 最多幾次，非常簡單。</li><li>Least move for unique array - 檢查一陣列至少需要幾次移動才能變成 unique array，一次移動定義為其中一個元素 +1 或 -1，元素範圍介於 1 ~ N，N 是該 Array 長度。</li><li>Circular Work - 給定一陣列為所需工時，計算所需總工作時長。工作方式為從頭開始，每小時該位置工時 -1 並換下一個位置，將所有位置所需完成之工時相加。（有點難描述，但我盡力了）</li></ol><p>整體來說不難，特別是第一題我十分鐘就寫完了。但我還是寫滿兩小時，花比較多時間在想第三題的寫法，因為我原本的寫法複雜度有點太高，後來用兩種寫法合併，應該可以比較有效率。</p><p>結果：無聲卡，不太明白為何。</p><h2 id="Corning-Engineering-Intern"><a href="#Corning-Engineering-Intern" class="headerlink" title="Corning - Engineering Intern"></a>Corning - Engineering Intern</h2><p>五月中在 104 上收到他主動聯繫，我原本沒投的原因是他的缺看起來都是材料、化工相關，根本沒看到資訊相關，但他還是發訊息給我了。詢問以後他說他們也有資料分析與建模相關的工作，先幫我安排了一個 Phone Interview，想說好吧就面面看也沒差。</p><h4 id="第一關（5-11）-Phone-Interview"><a href="#第一關（5-11）-Phone-Interview" class="headerlink" title="第一關（5&#x2F;11）- Phone Interview"></a>第一關（5&#x2F;11）- Phone Interview</h4><p>面試前查了一下，發現蠻多人有被要求英文自介，搞得我有點緊張，結果後來感覺這場根本沒啥面試感，只是 HR 想跟我告知有這個機會，如果有興趣可以再聯絡她安排後續這樣。整體流程約 20 分鐘，全中文，HR 人蠻好的，雖然她臨時有會要開跟我改了一次時間。整體流程就是自我介紹，聽她介紹一些相關的工作內容以及實習計畫特色：比較適合我的有竹科的研究取向跟中南科的應用取向，竹科的比較像研發、中南科的比較像智慧製造，兩者好像都跟 AI&#x2F;ML 相關之類的，然後跟我說後續有興趣再跟他說。主要的問題點是，他們都沒有提供宿舍，因此得自己去安排住宿，聽到這個我就有點卻步了，畢竟還要搞兩個月的短租的確很麻煩，我也沒有到超級無敵想進這間，所以考慮後可能不會繼續，因為我這時候感覺進到三面的 TSMC 還有點機會。</p><p>結果：沒有後續投遞。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>其實有點想做沒做過的工作，因為現在這份是做 AI，所以在投的時候盡量避免 AI，但還是收到不少相關職缺的邀請，也是沒關係啦，畢竟我這麼爛，再挑的話大概真的沒工作做了。另外老實說我也覺得我可以準備得更充分，不論是在職缺尋找或是面試準備上，這也是我需要再加油的地方，但走一步算一步，至少明年的這個時候我會比今年更有歷練。也很期待暑假在 TSMC 的實習生活，未來再回來跟大家分享！</p>]]></content>
      
      
      <categories>
          
          <category> 工作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interview </tag>
            
            <tag> Internship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>來玩玩 Instagram 的基本顯示 API 吧！</title>
      <link href="/2023/05/05/lets-play-ig-api/"/>
      <url>/2023/05/05/lets-play-ig-api/</url>
      
        <content type="html"><![CDATA[<h1 id="2025-更新：基本顯示-API-已被棄用"><a href="#2025-更新：基本顯示-API-已被棄用" class="headerlink" title="2025 更新：基本顯示 API 已被棄用"></a>2025 更新：基本顯示 API 已被棄用</h1><p><img src="/img/post/2023_05/deprecation.png" alt="Meta 的棄用公告"></p><p>這下頭痛了，原本研究的都沒用了，之後再來看看新的方法要如何操作……只能說我真的越來越討厭 Meta 了（<a href="https://developers.facebook.com/docs/instagram-platform/">來源</a>）。</p><hr><p>先來 <a href="https://jackchen890311.github.io/ramen/">這邊</a> 看看我把 Instagram 上的貼文整合到我的個人網站上的成果吧！</p><h1 id="為啥要爬-Instagram-API？"><a href="#為啥要爬-Instagram-API？" class="headerlink" title="為啥要爬 Instagram API？"></a>為啥要爬 Instagram API？</h1><p>會有這個念頭，是我之前某天突然想到，如果可以把我的 <a href="https://www.instagram.com/jacklovesramen/">拉麵帳號</a> 中的內容整合到我的個人網站上，那應該還不錯吧？不過，我一開始想的其實是做一個互動式地圖，並把我吃過的每間店標上去，讓使用者可以依地點挑選店家，還能馬上看到我的食評，感覺就很不錯。後來發現似乎不是很好做，那就留給未來吧 XD。這次我做的主要只是去爬取 Instagram 的 API，並把爬下來的內容作清理，再以我網站框架所要求的格式寫入上傳，其實沒什麼太技術的細節，但從結果來看應該可以說是有點樣子，之後也可以自動更新內容（但因為我的網站是使用靜態網站的框架，需要我手動上傳我更新的內容；如果是動態網站可以直接把呼叫 API 的部分寫在網站上，做動態的渲染等等），接著就來看看我怎麼做的吧！</p><h1 id="來看看-官方文檔-吧！"><a href="#來看看-官方文檔-吧！" class="headerlink" title="來看看 官方文檔 吧！"></a>來看看 <a href="https://developers.facebook.com/docs/instagram-basic-display-api/getting-started">官方文檔</a> 吧！</h1><p>若官方文檔太文謅謅看不太懂，也可以另外搜尋其他教學，像是 <a href="https://www.letswrite.tw/instagram-basic-display-api/">這篇</a> 也不錯。如同文檔上寫的，前置準備需要：</p><blockquote><ul><li>Facebook 開發人員帳號。  </li><li>含影音素材的 Instagram 帳號。  </li><li>您所擁有的公開網站。可以是一般的免費網站，像是 Github 網頁或 Heroku 網路應用程式，或您的實際網站。  </li><li>指令行工具，像是 Terminal 或可執行 cURL 要求的 Postman 等應用程式。</li></ul></blockquote><p>開發人員帳號就依照說明申請即可，指令行工具我推薦 <a href="https://www.postman.com/downloads/">Postman</a>，還蠻方便使用的，也可以避免編碼在 Terminal 上看不懂的問題。大部分都按照他的步驟設定即可，特別要提的是下圖中的幾個欄位，就填入你網站的網址就好，這個只是要讓他們知道是誰呼叫這個 API 請求，如果沒有網站可以用 Github Page 簡單搞一個，或是我猜隨便一個網站應該也沒差（此言論我不負責 XD）。</p><p><img src="/img/post/2023_05/api_website.png" alt="三個都放一樣就好，如果你知道這在幹嘛就自己改吧，我用不到沒研究 XD"></p><p>之後就一路按照他的步驟，邀請完後回到 IG 帳號確認邀請（因此你要爬的帳號要是自己的，或是有得到對方同意！如果想爬其他公開 IG 帳號就不能用 API，但可以用其他爬蟲方式），並在瀏覽器輸入以下網址按下同意，就可以獲取短期的 Access Code。其中 {app-id} 是你的 Instagram 應用程式編號，{redirect-uri} 可以用跟上面填寫的相同網站，是按下同意後會被重新導向的網址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://api.instagram.com/oauth/authorize</span><br><span class="line">  ?client_id=&#123;app-id&#125;</span><br><span class="line">  &amp;redirect_uri=&#123;redirect-uri&#125;</span><br><span class="line">  &amp;scope=user_profile,user_media</span><br><span class="line">  &amp;response_type=code</span><br></pre></td></tr></table></figure><p>按下確認後，你會被重新導向到上面設定的網站，在網址列應該會長得像如下的樣子，Code 後的參數就是你的 Access Code（不包含最後的 #_）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;redirect-uri&#125;?code=&#123;access_code&#125;#_</span><br></pre></td></tr></table></figure><p>接著，你需要再用 Access Code 換取 Access Token。開啟 Postman，使用 POST 方法發出以下請求。這邊的 {app-id} 跟 {app-secret} 是你的 Instagram 應用程式編號與密鑰，{code} 就是前面的 Access Code：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https://api.instagram.com/oauth/access_token</span><br><span class="line">  ?client_id=&#123;app-id&#125;</span><br><span class="line">  &amp;client_secret=&#123;app-secret&#125;</span><br><span class="line">  &amp;grant_type=authorization_code</span><br><span class="line">  &amp;redirect_uri=&#123;redirect-uri&#125;</span><br><span class="line">  &amp;code=&#123;code&#125;</span><br></pre></td></tr></table></figure><p>回傳結果就是 Access Token 啦：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;access_token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;IGQVJ...&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;user_id&quot;</span><span class="punctuation">:</span> <span class="number">17841405793187218</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>不過這個也是短期（1 小時）的，可以用他再發 HTTP 請求，來更換長期（60 天）的 Token，詳情參考 <a href="https://developers.facebook.com/docs/instagram-basic-display-api/guides/long-lived-access-tokens">這裡</a>。</p><p>或是其實這邊也可以獲取長期 Access Token，如果你是要跟我一樣爬下來處理，然後嫌前面太麻煩的話，也可以從這邊產生。不過這個一樣定期需要重新產生，目前還沒看到比較好的方式獲取永久 Token，有人知道的話歡迎跟我分享：</p><p><img src="/img/post/2023_05/api_token.png" alt="點右邊的 Generate 就好，記得要存下來，不然就要重新產生"></p><blockquote><p>題外話，看到上面的 {redirect-uri} 我才知道原來有 URI、URL、URN 這三種東西。想知道更多可以看 <a href="https://ithelp.ithome.com.tw/articles/10266610">這裡</a> 及其後續文章，有簡單的介紹。</p></blockquote><h1 id="有了-Token，如何拿到圖片與文章？"><a href="#有了-Token，如何拿到圖片與文章？" class="headerlink" title="有了 Token，如何拿到圖片與文章？"></a>有了 Token，<a href="https://developers.facebook.com/docs/instagram-basic-display-api/guides/getting-profiles-and-media">如何拿到圖片與文章？</a></h1><p>不囉嗦了，直接上 API 指令，可以參考 <a href="https://developers.facebook.com/docs/instagram-basic-display-api/reference/media#fields">API 說明文件</a>，{user_id} 為上面拿 Access Token 時一起回傳的結果，也可以換成每篇文章的 ID，{limit} 則為回傳數量，最多是 100 篇貼文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://graph.instagram.com/&#123;user_id&#125;/media</span><br><span class="line">  ?fields=&#123;fields&#125;</span><br><span class="line">  &amp;access_token=&#123;access_token&#125;</span><br><span class="line">  &amp;limit=&#123;limit&#125;</span><br></pre></td></tr></table></figure><p>回傳結果是 JSON 格式，當 limit &#x3D; 1 時如下，很貼心的幫你把往下取的方法也給你了：</p><p><img src="/img/post/2023_05/api_return.png" alt="在 Postman 中的回傳結果，會順便幫你轉編碼，讓你可以看得懂"></p><p>那因為我只需要文章內容、第一張圖片跟貼文連結，所以就只拿了這些，有需要其他的可以自己以逗號方式加入 {fields} 中，像我的話就是用 <code>?fields=id,caption,media_url,permalink</code> 這樣。</p><h1 id="我要怎麼處理-JSON-資料？"><a href="#我要怎麼處理-JSON-資料？" class="headerlink" title="我要怎麼處理 JSON 資料？"></a>我要怎麼處理 JSON 資料？</h1><p>這部分就簡單啦，看你後面想要怎麼用，像我就是用 Python 做，先用 requests 套件來發送 API，再把結果交給 json 套件幫我處理，最後透過字串處理與寫檔把他寫到 Markdown 檔案中，就可以呈現在 Hexo 框架中了。每個人想呈現與處理的方式不同，因此這部分就看個人喜好吧，如果你真的想參考我的程式碼可以看 <a href="https://github.com/JackChen890311/jackchen890311.github.io/tree/main/source/ramen/crawler.py">這裡</a>。</p><p><img src="/img/post/2023_05/ramen_layout.png" alt="我的排版結果，依照年份分類，這樣我一年改一次頁面就好"></p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>想做這個也是臨時起意，所以花了一個下午爬完資料 + 排完版，再半個下午產出這篇文章，算是比我想的還要快一些。但我真的很想把他做成地圖啊！可是目前這個爬法好像沒辦法爬位置資訊，就算可以好了，地圖這件事情我也需要再花時間研究，應該不是甚麼簡單的事情。至少現在有點樣子了，那個遠大的目標，就當作未來的 Side Project 吧～如果看完這篇文章，有甚麼想說的都可以留言告訴我喔！</p><h1 id="更新：圖片連結失效了？！"><a href="#更新：圖片連結失效了？！" class="headerlink" title="更新：圖片連結失效了？！"></a>更新：圖片連結失效了？！</h1><p>過了幾天再回來看，發現我所有的圖都不見了 QAQ，如下：<br><img src="/img/post/2023_05/ramen_broken.png" alt="我的圖呀 QQ"></p><p>後來發現用前面 API 的方法拿到的圖片連結只是暫時的，並不會永久存在。哎呀這下頭痛了，總不能把所有圖片都載下來吧？後來上網查了一下，發現 Instagram 還有提供常見的「內嵌功能」，從電腦版的網站就可以找到：<br><img src="/img/post/2023_05/ig_embedded.png" alt="從 Instagram 電腦版，貼文的右上角點進去選擇內嵌即可"></p><p>其他網站像是 Youtube，也會提供這種功能，基本上就是他會產出寫好的 HTML &amp; CSS &amp; JS原始碼，讓你可以貼到其他網站上使用，同時也能導回原始的頁面。（到頭來感覺前面都在做白工…）內嵌的效果如下：<br><img src="/img/post/2023_05/ramen_new_layout.png" alt="使用內嵌功能後的長相，下面的字是我另外加的"></p><p>所以最後我就把我原本的頁面全部替換成用內嵌的方式，並且也修改了我的程式碼，讓以後更新時也能以內嵌方式產生內容，結果到頭來根本就有現成的工具可以用嘛，我還在那邊 Call 人家 API XD。但總之就把我的心路歷程都記在這裡，給有需要的人參考。</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Instagram </tag>
            
            <tag> API </tag>
            
            <tag> Ramen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Ret[AI]ling Data 實習的日子</title>
      <link href="/2023/04/30/intern-at-retailing-data/"/>
      <url>/2023/04/30/intern-at-retailing-data/</url>
      
        <content type="html"><![CDATA[<p>四月底結束了我在 Ret[AI]ling Data 八個月的實習，也算是蠻長的一段時間，想說趁記憶猶新，隨意紀錄一下這段實習的點點滴滴，以便未來回顧。這篇文可能會很隨意，因為我就是把我想到的打下來 XD</p><h1 id="如何找到這間公司？"><a href="#如何找到這間公司？" class="headerlink" title="如何找到這間公司？"></a>如何找到這間公司？</h1><p>其實我開始找實習是去年七月底剛回臺灣時，原本的計畫是要再讀一年大五，把輔修的工科海洋系剩下的學分拿完。但人算不如天算，剩下不多的課程竟然衝堂，如果要修完就得再花一年，再問過教授跟教務處依然沒有辦法以後，只好忍痛放棄輔修學位，於是我就只剩一堂體育就能畢業。</p><p>但距離我預計念研究所還有一整年，那時候也壓根還沒開始申請，所以這一年等於沒其他事情。再加上因為經濟因素（出國把錢都花光了QQ），必須得賺錢養活自己，所以就決定乾脆專心工作，努力開始找實習與家教。其實原本這一年如果繼續輔修的話，也有實習的打算，但就可能沒這麼急，不過總之後來的種種事情，還有家裡因素，讓我決定趕快找個工作。八月時實習的職缺並不太多，加上我想找 AI、ML 等資訊領域的缺，又沒有相關工作經驗，找起來可以說是不太順利。雖然我那時投的不多，但這家公司也是我那陣子唯一收到的面試邀請，其他的都是感謝信或無聲卡坐收。</p><p>面試的時候主要分三關：技術筆試、HR、主管面試。技術筆試還算簡單，考了一些 ML 的基本概念以及 sorting，雖然我 sorting 沒複習都忘光光，但後來主管說我寫得比正職還好。HR 就常見的問題，我都臨場回答；主管面試只問了兩三題跟 NN 有關的基本題，還有說工作內容會需要做模型加速（那時候不懂這是啥），其他大部分時間就簡單聊天。</p><p>後來過了三到五天就收到 Offer，還蠻快的，那時候也沒有其他選擇，想說第一份資訊實習，做的也是有興趣的，雖然公司是新創，比較想去大公司，但也沒有其他更好的選擇了（但我確實決定的有點急，不過現在回去看也不會後悔當初的決定）。</p><p><img src="/img/post/2023_04/bigcode.jpg" alt="愛護眼睛運動，用超大螢幕 Coding，後面是小工作站"></p><h1 id="工作內容在做甚麼？"><a href="#工作內容在做甚麼？" class="headerlink" title="工作內容在做甚麼？"></a>工作內容在做甚麼？</h1><p>我的職位名稱是 AIoT Team 的 Machine Learning Engineer Intern，主要的工作就是開發公司的產品，並訓練所需的機器學習的模型，主要著重的領域是深度學習與電腦視覺，但因為是新創，所以其實也做了一些其他的事情，我覺得可能有不少的部份都在做 Software Engineering，甚至一部份的 Hardware 建置與 PM 也是算在我的工作範圍。雖然新創的壞處就是架構較為雜亂、流動率高（前同事一直抱怨沒有 senior 來帶哈哈）、工作雜事較多，但新創的好處就是可以學到很多東西、可以直接碰到產品、跟同事比較熟、且團隊成員都很年輕。</p><p>工作期間主要碰過的專案有幾個，像是人臉辨識、人流辨識、以及花最多時間的籃球智慧分析系統。其他的話，還有軟體開發、演算法規劃、硬體架設、Edge Machine 的環境建置、深度學習模型加速等等，總之就是真的蠻多樣的。至於學到甚麼的話，我覺得最主要的收穫包含：學會基礎的 Git 與 Docker 使用、對 Linux 更加熟悉、碰過 Jetson Nano 等邊緣 AI 機器、實際參與開發大型專案、學會 Survey Paper 並實際使用 Github 上的 Open Source Code 等等，我個人認為收穫真的蠻多的，也很適合做為第一份入門的實習。</p><p><img src="/img/post/2023_04/farbar.jpg" alt="公司的產品：智慧零售互動機台（Demo 用），裡面的模型就是我的工作內容"></p><h1 id="工作環境如何？"><a href="#工作環境如何？" class="headerlink" title="工作環境如何？"></a>工作環境如何？</h1><p>以下分點討論：</p><ul><li>地點：在南軟的一間辦公室，附近很多吃的，離我家也不太遠還算方便，但因為是新創人真的很少，即便到後來也是從一間辦公室擴建成兩間的大小而已。</li><li>環境：個人有自己的座位與電腦，但因為我們需要訓練模型，因此還有額外的運算資源跟小工作站。</li><li>同事：雖然流動率高，但同事人都很好，帶我的主管人也很讚，不過上班時間蠻安靜的，除了中午吃飯外互動不多，但小公司所以大家都彼此認識，我之前偶爾也會揪個打球。</li><li>福利：小公司福利就比不太上大公司了，但還是偶爾會有下午茶、聚餐等等，普普通通，我前公司稍好一些；但薪水的話主管後來有幫我調薪，這邊比較好，前公司只有基本薪資又很多雜事很累 QQ。</li></ul><p> <img src="/img/post/2023_04/4090.jpg" alt="公司的客戶給了我們一台 30 萬的訓練機，配上卡皇 4090，太鬼啦"></p><h1 id="我對這份實習的想法？"><a href="#我對這份實習的想法？" class="headerlink" title="我對這份實習的想法？"></a>我對這份實習的想法？</h1><p>其實我還蠻喜歡這份實習的，做的內容有趣，發揮空間大，但不太好的地方就是沒有資深的人可以問，很多東西要靠自己去摸，有時候就會不太確定方向對不對，或是自己鑽牛角尖，但也是這樣才能成長（剛進去的時候是有正職帶我，但他走了之後就大多都靠自己）。而我也利用這八個月加強了一些未來會很實用的技能，像是看 paper、Linux、Git 等等，也從同事身上學了不少東西，相信對未來不論研究所或是其他工作都會有不小的幫助。</p><p><img src="/img/post/2023_04/exhibition.jpg" alt="出公差去看商展，看到蠻多酷東西的，感恩主管 XD"></p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>好啦，以上就是我上一份實習的一些點滴啦，其實原本半年就要走了，但被主管加薪慰留，所以待到了八個月，也多學了一點東西，此外還有一個跟工研院合作的計畫要做，所以後面偶爾還會幫忙做點事情。儘管才剛結束上一份工作，但我現在就在為了暑期實習煩惱了，希望我能趕快拿到暑期的 Offer 嗚嗚嗚。</p>]]></content>
      
      
      <categories>
          
          <category> 工作紀錄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Conda 管理 Python 開發環境</title>
      <link href="/2023/04/04/conda-basic/"/>
      <url>/2023/04/04/conda-basic/</url>
      
        <content type="html"><![CDATA[<p>繼上篇 <a href="https://jackchen890311.github.io/Website/2023/02/24/install-windows-and-linux/">安裝雙系統</a> 並順便安裝 Miniconda 完成後，這篇來稍微介紹一下使用 Conda 的好處在哪裡，順便記錄一些常用指令，不然我自己常常忘記怎麼刪環境，每次都要重新找 XD。</p><p>Conda 為一種套件管理工具，使用 Conda 來管理開發環境非常方便，指令簡單也能保持環境乾淨整潔，要匯出環境版本時也不會有其他多餘的套件干擾。常見的安裝方式有 Anaconda 與 Miniconda 兩種，相比之下 Miniconda 只提供必要功能，Anaconda 相對全面，但也比較複雜一些。Python 的 virtualenv 也有相似的虛擬環境功能，但我個人還是認為 Conda 好用一些，也很感謝實習讓我接觸到 Miniconda。</p><p><img src="/img/post/2023_04/conda_comparison.jpg" alt="Conda Comparison"></p><p>Figure source is <a href="https://www.machinelearningplus.com/deployment/conda-create-environment-and-everything-you-need-to-know-to-manage-conda-virtual-environment/">here</a>.</p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>以下作業系統為 Ubuntu 22.04 LTS，括號內請自行替換。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Check conda version and update conda</span></span><br><span class="line">conda -V</span><br><span class="line">conda update conda</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create and remove an environment</span></span><br><span class="line">conda create -n [env_name] python=[3.x]</span><br><span class="line">conda <span class="built_in">env</span> remove -n [env_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove specific package in a environment</span></span><br><span class="line">conda remove -n [env_name] [package_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># List all Environment</span></span><br><span class="line">conda <span class="built_in">env</span> list</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get into / get out of an environment</span></span><br><span class="line">conda activate [env_name]</span><br><span class="line">conda deactivate</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an identical environment</span></span><br><span class="line">conda list --explict &gt; [spec_file_name].txt</span><br><span class="line">conda create -n [env_name] --file [spec_file_name].txt</span><br></pre></td></tr></table></figure><h2 id="實際操作"><a href="#實際操作" class="headerlink" title="實際操作"></a>實際操作</h2><p>安裝完 Miniconda 後，你的 Terminal 大概會變成這樣：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(base) jack@jack-linux:~$</span><br></pre></td></tr></table></figure><p>使用 <code>conda activate [env_name]</code> 進入環境後，會變成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(env_name) jack@jack-linux:~$</span><br></pre></td></tr></table></figure><p>此時就正常操作即可，你就可以任意的 <code>pip install</code>，而不用擔心環境很亂了，大不了再刪掉就好，是不是很簡單！其實說穿了，最常用到的指令就那幾個，再多一點上面也都包含了，完全不難學也不複雜，還可以很輕鬆的切換不同環境，良好的管理 Python 與其套件版本。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇文其實沒啥好寫的，因為 conda 就是個這麼簡單的東西，但是他卻提供了很實用的功能，來幫助開發者管理套件版本與環境。少量開發的話可能還好，但像是我實習時常常會需要調整套件版本，或是有新專案要啟動，這時 conda 就是個很實用的工具，心動的話趕快到 <a href="https://docs.conda.io/en/latest/miniconda.html">官網</a> 下載吧！</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 教學系列文 (9) - OOP 三大精隨</title>
      <link href="/2023/03/23/python-tutorial-9/"/>
      <url>/2023/03/23/python-tutorial-9/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw?view">HackMD 完整版請點我</a></p><h3 id="OOP-三大精隨-封裝、繼承、多型（補充）"><a href="#OOP-三大精隨-封裝、繼承、多型（補充）" class="headerlink" title="OOP 三大精隨 - 封裝、繼承、多型（補充）"></a>OOP 三大精隨 - 封裝、繼承、多型（補充）</h3><h4 id="封裝（Encapsulation）"><a href="#封裝（Encapsulation）" class="headerlink" title="封裝（Encapsulation）"></a>封裝（Encapsulation）</h4><p>將物件的內部狀態和行為隱藏在物件內部，只公開必要的方法給外界使用。封裝可以保護物件免於外界的非法存取，並且讓物件更容易維護和修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    __private = <span class="string">&#x27;&#x27;</span> <span class="comment"># This cannot be accessed from the outside</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__private = <span class="string">&#x27;&#x27;</span> <span class="comment"># This cannot be accessed from the outside</span></span><br></pre></td></tr></table></figure><h4 id="繼承（Inheritance）"><a href="#繼承（Inheritance）" class="headerlink" title="繼承（Inheritance）"></a>繼承（Inheritance）</h4><p>子類別可以繼承父類別的屬性和方法，並且可以擴展或覆寫父類別的行為。繼承可以提高程式碼重複使用性，並且可以讓類別之間建立階層關係，方便對類別進行分類和管理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;walking&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;eating&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = Dog(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">A.walk()</span><br><span class="line">A.eat()</span><br><span class="line"><span class="built_in">print</span>(A.name)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">walking</span><br><span class="line">eating</span><br><span class="line">A</span><br></pre></td></tr></table></figure><h4 id="多型（Polymorphism）"><a href="#多型（Polymorphism）" class="headerlink" title="多型（Polymorphism）"></a>多型（Polymorphism）</h4><p>同樣的方法名稱可以在不同的類別中有不同的實現方式，這稱為多型。多型可以讓程式碼更加靈活，並且可以讓不同的物件對相同的方法有不同的行為。多型可以通過繼承和介面實現，是物件導向設計中非常重要的概念。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;walking&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;eating&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; is using foot to walk&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; is eating bone&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">walk</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; is using two feet to walk&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; is eating worm&#x27;</span>.<span class="built_in">format</span>(self.name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = Dog(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">B = Duck(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">A.eat()</span><br><span class="line">B.eat()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">A is eating bone</span><br><span class="line">B is eating worm</span><br></pre></td></tr></table></figure><blockquote><p>Code Source: <a href="https://ithelp.ithome.com.tw/articles/10200623">搞懂Python的OOP</a></p></blockquote><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>到這裡為止你已經學完絕大部分常用的 Python 語法了，簡單開發所需的語法基本上不太會超過本篇教學的範圍。然而，資訊工程的領域極其廣大，目前碰到的還僅止於皮毛，若有興趣可以繼續鑽研資料結構、演算法等等課題，也可以透過題目或專案來練習自己的 Coding 能力。另外，網路上有很多相關資訊或教學，透過網路自我學習、不斷成長，也是件很重要的事情，加油！</p><h2 id="系列文結語"><a href="#系列文結語" class="headerlink" title="系列文結語"></a>系列文結語</h2><p>透過這次家教的機會，我也好好的重新複習了一次 Python 的基礎語法，自己在這個過程中也收穫了一些以前沒注意到的細節，難怪大家都說教學相長（但長的速度比較慢就是了）。我原本是想把上課講義做得像方便查找與複習的語法 &amp; 概念精華，後來發現發成文章也不錯，希望這九篇的系列文對你有所幫助，有任何回饋都很歡迎提供給我喔！未來有時間或有機會的話，也許可以再整理一些更進階的議題（資料結構、演算法等等的），或者是我也會分享我學習的新東西，那麼就未來見啦～</p>]]></content>
      
      
      <categories>
          
          <category> Python 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 教學系列文 (8) - 物件導向程式設計、類別</title>
      <link href="/2023/03/23/python-tutorial-8/"/>
      <url>/2023/03/23/python-tutorial-8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw?view">HackMD 完整版請點我</a></p><h2 id="Python-進階"><a href="#Python-進階" class="headerlink" title="Python 進階"></a>Python 進階</h2><h3 id="物件導向程式設計（Object-Oriented-Programming-OOP）"><a href="#物件導向程式設計（Object-Oriented-Programming-OOP）" class="headerlink" title="物件導向程式設計（Object-Oriented Programming, OOP）"></a>物件導向程式設計（Object-Oriented Programming, OOP）</h3><p>物件導向程式設計是軟體設計的一種方法，它把軟體分成數個「物件」來撰寫。每個物件都有自己的屬性和行為，並且可以跟其他物件互動。這樣的好處是，軟體的各部分之間彼此獨立，不但便於重複使用，也更容易理解和修改，提高軟體的可維護性和可擴展性。</p><p>物件導向程式設計是目前最流行的軟體設計方法之一，被廣泛應用於各種領域，包括網站開發、商用軟體、遊戲開發等等。常見的物件導向程式設計語言包括 Java、C++、C#、Python 等。</p><p>Credit: The world-wide famous <a href="https://chat.openai.com/chat">ChatGPT</a></p><h3 id="類別（Class）-簡介"><a href="#類別（Class）-簡介" class="headerlink" title="類別（Class） - 簡介"></a>類別（Class） - 簡介</h3><p>以下我們使用一個簡單的例子來說明類別的概念：在現實生活中，有各式各樣的車子，而每台車子雖然皆不相同，但都具有共同特徵，像是有四個輪胎、都有駕駛與車牌跟廠牌、都使用汽油前進等等，這時候就很適合使用物件導向的概念為車子建造一個類別。</p><p>在以下的例子中，<code>Car</code> 是一個類別名稱，這個類別包含 <code>driver, engine, meter</code> 等等屬性（Attribute），以及 <code>turnOnEngine, checkEngine, drive</code> 等等方法（Method）。</p><p>而 <code>mycar</code> 是一個屬於 <code>Car</code> 類別的物件或變數，我們也可以建立多個屬於 <code>Car</code> 類別的物件像是 <code>mycar1, mycar2...</code>，彼此之間的屬性與函數操作互不影響。</p><h4 id="宣告類別與建構函式（Constructor）"><a href="#宣告類別與建構函式（Constructor）" class="headerlink" title="宣告類別與建構函式（Constructor）"></a>宣告類別與建構函式（Constructor）</h4><p>在宣告類別時，我們使用以下語法：</p><ul><li><code>class Car</code> 代表這個類別的名稱，亦可使用 <code>class Car()</code> 或 <code>class Car(object)</code></li><li><code>def __init__()</code> 是一種特殊的類別方法，也稱為建構函式<ul><li>一個類別只有一個建構函式，若未撰寫則預設什麼事情都不做</li><li>名稱必為 <code>__init__()</code>，建立此類別物件時會自動執行，不須呼叫</li><li>主要用途為初始化相關配置，像是車子必有車牌號碼等等</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:  <span class="comment"># or class Car(): / class Car(object):</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, plateID, driver</span>):</span><br><span class="line">        self.wheels = <span class="number">4</span></span><br><span class="line">        self.plateID = plateID</span><br><span class="line">        self.driver = driver</span><br><span class="line">        self.engine = <span class="literal">False</span></span><br><span class="line">        self.meters = <span class="number">0</span></span><br><span class="line">        self.turnOnEngine()</span><br></pre></td></tr></table></figure><blockquote><p>補充：在其他語言（如 C++）中，時常會見到解構函式（Destructor）的使用<br>與建構函式相對應，解構函式在物件被銷毀時會自動執行<br>其使用主要是為了刪除 Runtime 時動態分配的記憶體空間，以避免 Memory Leak<br>Python 中也有提供解構函式，但因為我們通常不會自己分配記憶體<br>所以大多狀況下不需要使用，Python 會自己幫我們刪除分配的空間</p></blockquote><h4 id="屬性（Attribute）與方法（Method）"><a href="#屬性（Attribute）與方法（Method）" class="headerlink" title="屬性（Attribute）與方法（Method）"></a>屬性（Attribute）與方法（Method）</h4><ul><li>屬性（Attribute）：靜態，描述此物件的屬性<ul><li>車子有駕駛、引擎、公里數等等</li><li>又稱為成員變數（Member Variable）</li><li>其值可以是任何東西，像是 <code>list</code>、<code>int</code>、<code>string</code> 等等，甚至可以是另一個類別</li><li>會一直保存並且隨程式進行而更新，直到物件消滅為止</li></ul></li><li>方法（Method）：動態，對此物件執行一個動作<ul><li>車子可以點燃引擎、檢查引擎、往前開等等</li><li>又稱為成員函式（Member Function）</li><li>與一般的函式（Function）撰寫方式相同</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:  <span class="comment"># or class Car(): / class Car(object):</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, plateID, driver</span>):</span><br><span class="line">        self.wheels = <span class="number">4</span></span><br><span class="line">        self.plateID = plateID</span><br><span class="line">        self.driver = driver</span><br><span class="line">        self.engine = <span class="literal">False</span></span><br><span class="line">        self.meters = <span class="number">0</span></span><br><span class="line">        self.turnOnEngine()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">turnOnEngine</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.checkEngine():</span><br><span class="line">            self.engine = <span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Engine Started!&quot;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkEngine</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self, distance</span>):</span><br><span class="line">        <span class="keyword">if</span> self.engine:</span><br><span class="line">            self.meters += distance</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Drive %d kilometers.&quot;</span>%distance)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Engine is not turned on.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">turnOffEngine</span>(<span class="params">self</span>):</span><br><span class="line">        self.engine = <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Engine has been turned off.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">whoisDriving</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is driving the car.&#x27;</span>%self.driver)</span><br><span class="line">        <span class="keyword">return</span> self.driver</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMeters</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.meters</span><br></pre></td></tr></table></figure><h4 id="Self"><a href="#Self" class="headerlink" title="Self"></a>Self</h4><p>你應該有注意到上面出現了很多個 <code>self</code> 這個關鍵字，這個關鍵字在類別中扮演了很重要的角色，且任何類別方法中，第一個參數一定要是 <code>self</code>，他的意思是「這個物件本身」，而因為 <code>self</code> 代表這個方法中的物件本身，所以這個位置不需要傳入任何東西，在呼叫時可以直接無視。</p><p>用以下的例子來說：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self, distance</span>):</span><br><span class="line">        <span class="keyword">if</span> self.engine:</span><br><span class="line">            self.meters += distance</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Drive %d kilometers.&quot;</span>%distance)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Engine is not turned on.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMeters</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.meters</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">print</span>(myCar1.getMeters())</span><br><span class="line">myCar1.drive(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(myCar1.getMeters())</span><br><span class="line"><span class="built_in">print</span>(myCar2.getMeters())</span><br><span class="line"><span class="built_in">print</span>(myCar3.getMeters())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">1000</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>可以注意到幾個重點：</p><ul><li>每輛車的結果都不同，因為每輛車的 <code>self.meters</code> 都不同</li><li>呼叫 <code>mycar1.getMeters()</code> 時，不用傳入任何參數，但定義時卻必須定義一個參數 <code>self</code>，也就是說，類別方法的傳入參數量 + 1 &#x3D; 定義參數量</li><li>也可以在類別方法內來呼叫其他類別方法，像是 <code>self.turnOnEngine()</code></li></ul><h4 id="靜態變數（Static-Variable）"><a href="#靜態變數（Static-Variable）" class="headerlink" title="靜態變數（Static Variable）"></a>靜態變數（Static Variable）</h4><p>上述例子中，有些屬性是屬於整個類別共享的，像是 <code>self.wheels</code>，所有車子都有四個輪子。此時我們可以利用靜態變數，來宣告整個類別的屬性。詳細作法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:  <span class="comment"># or class Car(): / class Car(object):</span></span><br><span class="line">    wheels = <span class="number">4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, plateID, driver</span>):</span><br><span class="line">        self.plateID = plateID</span><br><span class="line">        self.driver = driver</span><br><span class="line">        self.engine = <span class="literal">False</span></span><br><span class="line">        self.meters = <span class="number">0</span></span><br><span class="line">        self.turnOnEngine()</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>變數&#x2F;屬性</th><th>說明</th><th>例子</th><th>語法</th></tr></thead><tbody><tr><td>實體變數</td><td>每個物件的屬性</td><td>每輛車有不同的駕駛</td><td>mycar.driver</td></tr><tr><td>類別變數</td><td>整個類別的屬性</td><td>所有車都有 4 個輪子</td><td>Car.wheels</td></tr></tbody></table><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>在完成以上的宣告後，接著我們來看使用方式：</p><ul><li>使用 <code>Car()</code> 來建立一個類別物件</li><li>使用 <code>myCar.drive()</code> 來呼叫類別方法</li><li>使用 <code>myCar.driver</code> 來獲取類別屬性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">myCar = Car(<span class="string">&quot;ABC-0311&quot;</span>,<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line">myCar.drive(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line">driverName = myCar.driver</span><br><span class="line"><span class="built_in">print</span>(driverName, <span class="string">&quot;is driving the car.&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">Engine Started!</span><br><span class="line">=====</span><br><span class="line">Drive 100 kilometers.</span><br><span class="line">=====</span><br><span class="line">Jack is driving the car.</span><br><span class="line">=====</span><br></pre></td></tr></table></figure><blockquote><p>補充：在其他語言中，為了更好的管理獲取權限<br>有時候會限制類別屬性或方法的取的與使用<br>此舉可以避免類別屬性被意外的修改，像 C++ 中 <code>private</code> 與 <code>protected</code> 的使用</p></blockquote><h4 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:  <span class="comment"># or class Car(): / class Car(object):</span></span><br><span class="line">    wheels = <span class="number">4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, plateID, driver</span>):</span><br><span class="line">        self.plateID = plateID</span><br><span class="line">        self.driver = driver</span><br><span class="line">        self.engine = <span class="literal">False</span></span><br><span class="line">        self.meters = <span class="number">0</span></span><br><span class="line">        self.turnOnEngine()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">turnOnEngine</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.checkEngine():</span><br><span class="line">            self.engine = <span class="literal">True</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Engine Started!&quot;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkEngine</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">drive</span>(<span class="params">self, distance</span>):</span><br><span class="line">        <span class="keyword">if</span> self.engine:</span><br><span class="line">            self.meters += distance</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Drive %d kilometers.&quot;</span>%distance)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Engine is not turned on.&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">turnOffEngine</span>(<span class="params">self</span>):</span><br><span class="line">        self.engine = <span class="literal">False</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Engine has been turned off.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">whoisDriving</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is driving the car.&#x27;</span>%self.driver)</span><br><span class="line">        <span class="keyword">return</span> self.driver</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMeters</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.meters</span><br><span class="line"></span><br><span class="line">myCar = Car(<span class="string">&quot;ABC-0311&quot;</span>,<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line">myCar.drive(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line">driverName = myCar.whoisDriving()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line">myCar.turnOffEngine()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line">myCar.drive(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line">myCar.turnOnEngine()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line">myCar.drive(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line">meter = myCar.getMeters()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Meters:&quot;</span>,meter)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">Engine Started!</span><br><span class="line">=====</span><br><span class="line">Drive 100 kilometers.</span><br><span class="line">=====</span><br><span class="line">Jack is driving the car.</span><br><span class="line">=====</span><br><span class="line">Engine has been turned off.</span><br><span class="line">=====</span><br><span class="line">Engine is not turned on.</span><br><span class="line">=====</span><br><span class="line">Engine Started!</span><br><span class="line">=====</span><br><span class="line">Drive 100 kilometers.</span><br><span class="line">=====</span><br><span class="line">Meters: 200</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 教學系列文 (7) - Lambda、套件、Git 簡介</title>
      <link href="/2023/03/23/python-tutorial-7/"/>
      <url>/2023/03/23/python-tutorial-7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw?view">HackMD 完整版請點我</a></p><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>Lambda 又叫做匿名函數，當我們需要快速簡潔的撰寫一個函數，但又不想幫他命名時（意即這個函數可能只會用一兩次），我們就會使用 Lambda 來幫助我們。Lambda 在使用上依然可以給予名稱，但非必要，函數內容也必須在一行內結束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>((<span class="keyword">lambda</span> x : x ** <span class="number">2</span>)(<span class="number">10</span>))</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>((<span class="keyword">lambda</span> x, y: x * y)(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>((<span class="keyword">lambda</span> x: x[<span class="number">1</span>])([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="與其他函數的搭配使用"><a href="#與其他函數的搭配使用" class="headerlink" title="與其他函數的搭配使用"></a>與其他函數的搭配使用</h4><ul><li>filter()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>]</span><br><span class="line">bignums = <span class="built_in">filter</span>((<span class="keyword">lambda</span> x: x &gt; <span class="number">50</span>), numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(bignums))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[100,1000,10000]</span><br></pre></td></tr></table></figure><ul><li>map()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>]</span><br><span class="line">doublenums = <span class="built_in">map</span>((<span class="keyword">lambda</span> x: x * <span class="number">2</span>), numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(doublenums))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[2, 20, 200, 2000, 20000]</span><br></pre></td></tr></table></figure><ul><li>sorted()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">food = [(<span class="string">&#x27;Apple&#x27;</span>,<span class="number">10</span>),(<span class="string">&#x27;Coke&#x27;</span>,<span class="number">30</span>),(<span class="string">&#x27;Bread&#x27;</span>,<span class="number">5</span>),(<span class="string">&#x27;Candy&#x27;</span>,<span class="number">25</span>)]</span><br><span class="line">food_sorted = <span class="built_in">sorted</span>(food, key = <span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(food_sorted)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[(&#x27;Bread&#x27;, 5), (&#x27;Apple&#x27;, 10), (&#x27;Candy&#x27;, 25), (&#x27;Coke&#x27;, 30)]</span><br></pre></td></tr></table></figure><blockquote><p>參考 <a href="https://www.learncodewithmike.com/2019/12/python-lambda-functions.html">Python Lambda 應用技巧</a></p></blockquote><h3 id="套件（Library）"><a href="#套件（Library）" class="headerlink" title="套件（Library）"></a>套件（Library）</h3><p>Python 強大的地方就是其眾多的使用者，讓我們在網路上有許多參考資料，以及眾多的第三方套件可供我們使用。套件其實就是別人寫好的 .py 檔案，將其整理後丟到網路上，讓我們可以透過一行簡單的 <code>import [package]</code> 就能使用。</p><ul><li>安裝套件：使用 <code>pip install [package]</code><br> 有些套件如 <code>os</code>, <code>random</code>, <code>time</code> 等等已預先包含在 python 中，就不需再另外下載</li><li>載入套件<ul><li>整個套件載入<ul><li><code>import [package]</code>（推薦）</li><li><code>from [package] import *</code></li></ul></li><li>僅載入特定模組&#x2F;函數<ul><li><code>from [package] import [module/function]</code>（推薦）</li><li><code>import [package].[module]</code></li></ul></li><li>載入且化名<ul><li><code>import [package] as [name]</code></li></ul></li></ul></li><li>使用套件：多以<code>[package].[function]</code>的方式，若是僅載入特定模組&#x2F;函數的話，前面不須加套件名稱即可使用。以下四種方式結果皆相同，但為了方便管理我們一般會選用第一種，以便知道各個函數來自哪個套件，同時也不會不小心覆寫（Overwrite）某些函數。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.getcwd())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd</span><br><span class="line"><span class="built_in">print</span>(getcwd())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os <span class="keyword">as</span> O</span><br><span class="line"><span class="built_in">print</span>(O.getcwd())</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd <span class="keyword">as</span> gw</span><br><span class="line"><span class="built_in">print</span>(gw())</span><br></pre></td></tr></table></figure><blockquote><p>進階：參考 <a href="https://medium.com/pyladies-taiwan/python-%E7%9A%84-import-%E9%99%B7%E9%98%B1-3538e74f57e3">Python 的 import 陷阱</a></p></blockquote><h4 id="常用套件"><a href="#常用套件" class="headerlink" title="常用套件"></a>常用套件</h4><ul><li>GUI：tkinter</li><li>遊戲設計：pygame</li><li>數學運算：math, random, numpy, scipy, random</li><li>資料處理：numpy, pandas</li><li>視覺化：matplotlib, seaborn</li><li>機器學習：scikit-learn, pytorch, tensorflow, keras</li><li>網站建置：flask, django</li><li>資料庫處理：pymysql</li><li>影像處理：cv2, PIL</li><li>自然語言處理：nltk, jieba</li><li>電腦操作：os, sys</li><li>時間相關：time, datetime</li><li>網路爬蟲：request, beautifulsoup, selenium<blockquote><p>參考 <a href="https://cflin.com/course/python/Python_07.pdf">Python 第三方模組</a></p></blockquote></li></ul><h2 id="Git-版本控制"><a href="#Git-版本控制" class="headerlink" title="Git 版本控制"></a>Git 版本控制</h2><p>Git 是一種版本控制系統，它可以追蹤軟體開發過程中的變更，幫助開發人員更有效地管理程式碼。使用 Git 有許多好處：</p><ol><li>版本控制：Git 可以幫助開發人員追蹤檔案的更改，並在需要時輕鬆地回復到先前的版本。這樣可以減少錯誤和失誤，並提高程式碼品質。</li><li>合作開發：Git 可以讓多個開發人員協同工作，讓他們在同一時間在同一份程式碼上工作，並且避免不同人員之間的衝突。</li><li>分支管理：Git 可以讓開發人員在不影響主分支的情況下創建和管理多個分支。這可以讓開發人員在不同的功能上工作，而不必擔心對主分支的影響。</li><li>遠端存儲：Git 可以讓開發人員將代碼儲存在遠端儲存庫中，讓多個開發人員在不同地方協同工作。</li></ol><p>Git 在許多著名的開源軟體專案中得到廣泛使用，包括Linux核心、Ruby on Rails 和 jQuery。使用 Git 的方式一般有兩種：使用指令（Command Line）或是下載 Github Desktop 使用其軟體介面（GUI），我們這邊會先介紹如何使用 Github Desktop。</p><p>Credit: The world-wide famous <a href="https://chat.openai.com/chat">ChatGPT</a></p><p>參考以下連結：</p><ul><li><a href="https://docs.github.com/zh/desktop/installing-and-configuring-github-desktop/overview/getting-started-with-github-desktop">官方說明</a></li><li><a href="/cW7RxOjzQ4eqQlZbOW9BsA">從 0 到 1 的 GitHub Pages 教學手冊</a></li><li><a href="https://gitbook.tw/">Git 教學 - 為你自己學 Git</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 教學系列文 (6) - 檔案讀取、例外處理、斷言</title>
      <link href="/2023/03/23/python-tutorial-6/"/>
      <url>/2023/03/23/python-tutorial-6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw?view">HackMD 完整版請點我</a></p><h3 id="檔案讀取（File-I-O）"><a href="#檔案讀取（File-I-O）" class="headerlink" title="檔案讀取（File I&#x2F;O）"></a>檔案讀取（File I&#x2F;O）</h3><p>在 Python 中，很常會用到檔案相關的操作，舉凡文字檔（.txt）、CSV檔（.csv）、圖片檔（.png, .jpg…）、影片檔（.mp4, .avi…）等等，都會需要讀取、寫入檔案。這邊先以文字檔作為示範，僅簡單講解基礎操作，其他檔案如圖片、影像有些會有專門的 library 來處理。</p><p>test.txt:<br>This is a test txt file.<br>This is another line.</p><ul><li>全部讀入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">data = file.read()</span><br><span class="line">file.close()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">data = data.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">This is a test txt file.</span><br><span class="line">This is another line.</span><br><span class="line">[&#x27;This is a test txt file.&#x27;, &#x27;This is another line.&#x27;]</span><br></pre></td></tr></table></figure><ul><li>逐行讀入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = file.readline()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(line,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">This is a test txt file.</span><br><span class="line">This is another line.</span><br></pre></td></tr></table></figure><ul><li>寫入檔案<ul><li>新增在原始資料後面</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">file.write(<span class="string">&#x27;This is a new line.&#x27;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>test.txt:<br>This is a test txt file.<br>This is another line.<br>This is a new line.</p><ul><li>從頭重新寫入（會覆蓋原始資料）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">file.write(<span class="string">&#x27;This is a new line.&#x27;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>test.txt:<br>This is a new line.</p><p>要記得加上 <code>file.close()</code> 來關閉檔案，以免造成潛在的 Memory Leak。有一個更好的寫法，使用 <code>with</code> 來達成，如下例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="comment"># Do some file-related operations</span></span><br><span class="line">    <span class="comment"># The file will close automatically when this block is finished</span></span><br><span class="line"><span class="comment"># Do other operations</span></span><br></pre></td></tr></table></figure><p>將檔案相關操作放在 <code>with</code> 的區塊中，而非檔案相關操作放在外面，一方面能確保檔案有被關閉，一方面也能增加可讀性。</p><h3 id="例外處理（Exception-Handling）"><a href="#例外處理（Exception-Handling）" class="headerlink" title="例外處理（Exception Handling）"></a>例外處理（Exception Handling）</h3><p>寫程式難免會遇到 Error 的狀況，當我們不希望程式因為 Error 而停止執行並噴出一大堆錯誤訊息時，可以使用以下技巧來處理。</p><ul><li><code>try</code> 必須搭配 <code>except</code> ，預設先執行 <code>try</code> 裡的程式碼</li><li>當 <code>try</code> 執行失敗時， <code>except</code> 裡才會被執行</li><li>與 <code>if...else...</code> 有異曲同工之妙，但不會因遇到錯誤而停止執行</li><li>有時候會造成難以 debug ，使用上要特別小心</li><li>另外可以使用 <code>raise</code> 來定義自己想要的 Exception</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> x.isdigit():</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;Not A Integer&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    x = <span class="built_in">int</span>(x)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    inv = <span class="number">1</span>/x</span><br><span class="line">    <span class="built_in">print</span>(inv)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Denominator cannot be 0!&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Type is not correct!&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Other Error!&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output (when input = 2): 0.5</span><br><span class="line">Output (when input = 0): Denominator cannot be 0!</span><br><span class="line">Output (when input = &#x27;A&#x27;): ... Exception: Not A Integer</span><br></pre></td></tr></table></figure><p>此處要注意的是，前兩種狀況程式可以順利結束，因為我們使用 <code>except</code> 來處理分母為0的例外；但第三種狀況 Python 會報錯，程式中斷無法繼續往下執行，因為我們 寫「當 x 不是數字時就 raise error」，Python raise error 後就會停止。</p><h3 id="斷言-（Assertion）"><a href="#斷言-（Assertion）" class="headerlink" title="斷言 （Assertion）"></a>斷言 （Assertion）</h3><p>Assertion 提供一種保護機制，確保執行到某個地方時，某樣我們預期的條件仍然成立。若不成立則會丟出 Assertion Error，可以加入自定義的訊息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">assert</span> x &gt;= <span class="number">0</span>, <span class="string">&#x27;x is not positive&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;A Positive number is:&#x27;</span>,x)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output (when input = 1): A Positive number is: 1</span><br><span class="line">Output (when input = -1): ... AssertionError: x is not positive</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 教學系列文 (5) - 函數、其他常見資料結構</title>
      <link href="/2023/03/23/python-tutorial-5/"/>
      <url>/2023/03/23/python-tutorial-5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw?view">HackMD 完整版請點我</a></p><h2 id="Python-基礎-2"><a href="#Python-基礎-2" class="headerlink" title="Python 基礎 (2)"></a>Python 基礎 (2)</h2><h3 id="函數（Function）"><a href="#函數（Function）" class="headerlink" title="函數（Function）"></a>函數（Function）</h3><p>我們以前寫 print(‘Hello’) 時，其實就是在呼叫函數，這個函數會幫我們把我們傳入的 ‘Hello’ 印出來。其他像是 range()、type()、input() 等也都是函數，各有不同的用途。</p><p>我們也可以透過特定語法來定義自己的函數，透過函數可以幫我們達成「模組化」，省去重複的 code 同時提供更多彈性來執行類似的動作。</p><p>一個函數包含名稱、本體、輸入（Input）與輸出（Output），後兩者又叫做參數（Parameters）與回傳值（Return Values）。有時我們也會在函數最一開始的地方加入註解，來說明函數的使用方式以及參數 &#x2F; 回傳值類型。</p><p><img src="https://hackmd.io/_uploads/ByAuqF8kR.png" alt="image"></p><p>以下圖為例，輸入是蘋果，輸出是切半的蘋果，函數 <code>h</code> 的作用是把蘋果切半。<br><img src="https://hackmd.io/_uploads/HJDXscDyA.png" alt="image"></p><h4 id="名稱"><a href="#名稱" class="headerlink" title="名稱"></a>名稱</h4><ul><li>用關鍵字 <code>def</code> 來宣告函數，名稱接在 <code>def</code> 後面</li><li>名稱通常會取與函數作用相關，便於使用者理解函數功能</li><li>使用函數時，用其名稱來呼叫函數</li></ul><h4 id="本體"><a href="#本體" class="headerlink" title="本體"></a>本體</h4><ul><li>把要執行的程式碼包在函數本體中</li><li>有時會在本體前面加上註解，用以說明函數功能<ul><li>說明最好包含：輸入、輸出、作用</li><li>因為函數沒有限制變數的類別，所以最好在說明中講清楚</li></ul></li></ul><h4 id="輸入（參數）"><a href="#輸入（參數）" class="headerlink" title="輸入（參數）"></a>輸入（參數）</h4><ul><li><strong>參數的作用是提供資料給函數操作</strong></li><li>函數的參數可以自行命名（如下例的 n）</li><li>可以傳入多個參數，用逗號隔開</li><li>可以給定預設值（如下例的 n &#x3D; 5）</li></ul><h4 id="輸出（回傳值）"><a href="#輸出（回傳值）" class="headerlink" title="輸出（回傳值）"></a>輸出（回傳值）</h4><ul><li><strong>回傳值的作用是把結果回傳給使用函數的人</strong></li><li>使用 <code>return</code> 來控制函數的結束點，並將回傳值放在後面</li><li>若沒有 <code>return</code> 則會自動在最後加上 <code>return None</code></li><li>可放回傳多個結果，用逗號隔開</li><li>函數結束後會回到主程式，繼續執行後面的程式</li></ul><p>以下是一個在 python 中的實際例子，輸入是一個數字 <code>n</code> ，輸出是一個清單 <code>alist</code> ，函數 <code>get_1_to_n</code> 的作用是獲取 1 ~ n 的清單。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_1_to_n</span>(<span class="params">n = <span class="number">5</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Getting a list range from 1 to&#x27;</span>,n)</span><br><span class="line">    alist = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line">x = get_1_to_n(<span class="number">10</span>)  <span class="comment"># or get_1_to_n(n = 10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X = &#x27;</span>,x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;~~~~~~~~~~&#x27;</span>)</span><br><span class="line">y = get_1_to_n()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Y = &#x27;</span>,y)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">Getting a list range from 1 to 10</span><br><span class="line">X =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">~~~~~~~~~~</span><br><span class="line">Getting a list range from 1 to 5</span><br><span class="line">Y =  [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><blockquote><p>補充：<a href="https://medium.com/ai%E5%8F%8D%E6%96%97%E5%9F%8E/python-yield%E7%9A%84%E7%94%A8%E6%B3%95%E8%A9%B3%E8%A7%A3-%E8%BD%89%E9%8C%84-52f539b67bdf">Python yield的用法詳解</a><br>補充：<a href="https://notfalse.net/6/arg-vs-param">參數（Parameters）與引數（Arguments）的差異</a></p></blockquote><h4 id="變數範圍（Scope-of-Variable）"><a href="#變數範圍（Scope-of-Variable）" class="headerlink" title="變數範圍（Scope of Variable）"></a>變數範圍（Scope of Variable）</h4><p>變數依據生命週期的不同，分為全域變數與區域變數。</p><ul><li>區域變數（Local Variable）<ul><li>定義在函數內的變數稱為區域變數</li><li>只能在函數內使用，函數結束後變數也會跟著消失</li></ul></li><li>全域變數（Global Variable）<ul><li>定義在函數外的變數稱為全域變數</li><li>所有地方（包含函數內）都可以使用，直到程式結束執行才會消失</li></ul></li><li>若函數內宣告與全域變數同名的變數，則會被當作是區域變數，對其進行的操作不影響全域變數</li><li>通常若我們需要拿到函數內的某個變數，我們會直接使用 <code>return var</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scale = <span class="number">3</span> <span class="comment"># Global</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">return</span> num * scale</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">multiply_5</span>(<span class="params">num</span>):</span><br><span class="line">    scale = <span class="number">5</span> <span class="comment"># Local</span></span><br><span class="line">    <span class="keyword">return</span> num * scale</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(scale)</span><br><span class="line"><span class="built_in">print</span>(multiply(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(multiply_5(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(scale)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">3</span><br></pre></td></tr></table></figure><blockquote><p>補充：在函數內修改全域變數與上一層變數的方法：<a href="https://ktinglee.github.io/LearningPython100days(6)_global_and_nonlocal/">Global &amp; Nonlocal</a></p></blockquote><h4 id="可變物件（Mutable-Object）與不可變物件（Immutable-Object）"><a href="#可變物件（Mutable-Object）與不可變物件（Immutable-Object）" class="headerlink" title="可變物件（Mutable Object）與不可變物件（Immutable Object）"></a>可變物件（Mutable Object）與不可變物件（Immutable Object）</h4><p>在 Python 中，不同資料類別又可以其性質分為可變物件與不可變物件。 </p><table><thead><tr><th>分類</th><th>可變物件</th><th>不可變物件</th></tr></thead><tbody><tr><td>說明</td><td>被創造出來後，其值可以被改變的物件。</td><td>被創造出來後，其值無法被改變的物件。</td></tr><tr><td>舉例</td><td>list, dict, set*</td><td>int, float, string, tuple</td></tr><tr><td>修改</td><td>可以，依資料類別不同有不同修改方式，修改時記憶體位置不會改變。</td><td>無法，只能透過重新指派的方式，此時記憶體位置亦會被重新分配。</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mutable Object</span></span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">alist = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]  <span class="comment"># Okay</span></span><br><span class="line">alist[<span class="number">1</span>] = <span class="number">100</span>  <span class="comment"># Okay</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Immutable Object</span></span><br><span class="line">astring = <span class="string">&#x27;string&#x27;</span></span><br><span class="line">astring = <span class="string">&#x27;STRING&#x27;</span> <span class="comment"># okay</span></span><br><span class="line">astring[<span class="number">1</span>] = <span class="string">&#x27;A&#x27;</span> <span class="comment"># TypeError: &#x27;str&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p>接著我們來看看記憶體位址的變化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Let&#x27;s take a look on the addresses of these objects</span></span><br><span class="line"><span class="comment"># id() is a function help finding address of a variable</span></span><br><span class="line"><span class="comment"># Mutable Object</span></span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(alist))</span><br><span class="line">alist[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(alist))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br><span class="line"><span class="comment"># Immutable Object</span></span><br><span class="line">astring = <span class="string">&#x27;string&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(astring))</span><br><span class="line">astring = <span class="string">&#x27;STRING&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(astring))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">1541330859072</span><br><span class="line">1541330859072</span><br><span class="line">=====</span><br><span class="line">1541255790064</span><br><span class="line">1541259351920</span><br></pre></td></tr></table></figure><blockquote><p>參考 <a href="https://www.maxlist.xyz/2021/01/26/python-immutable-mutable-objects/">什麼是 Immutable &amp; Mutable objects</a><br>*關於 set 可不可變其實有點<a href="https://stackoverflow.com/questions/14193438/are-python-sets-mutable">爭議</a>，在這裡先當作他是可變的</p></blockquote><h4 id="Pass-by-Assignment-Example-Illustration"><a href="#Pass-by-Assignment-Example-Illustration" class="headerlink" title="Pass by Assignment - Example Illustration"></a>Pass by Assignment - Example Illustration</h4><p>此處我們「不會」深入講當傳參數時發生了什麼事情，因為牽扯到一些記憶體跟參照等等的概念，我們會用幾個例子來說明何謂 Python 的 Pass by Assignment。</p><p>Python 中函數依據傳入參數的類別不同，會有不同的行為。</p><ul><li>當傳入參數可變物件時：<ul><li><strong>若未經重新指派，而是在函數裡直接修改參數，則會原始變數的值也會一同被修改</strong></li><li><strong>若經重新指派，則視為全新的變數，原始變數不會被影響</strong></li></ul></li><li>當傳入參數為不可變物件時：<ul><li><strong>任何對參數的操作都不影響原始變數（除非使用全域變數方式修改）</strong></li></ul></li></ul><p>聽起來很複雜對吧？我們直接用例子來看會比較清楚一些：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">listchange</span>(<span class="params">l</span>):</span><br><span class="line">    l[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span></span><br><span class="line">alist = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">listchange(alist)</span><br><span class="line"><span class="built_in">print</span>(alist)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[&#x27;A&#x27;,2,3]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">strchange</span>(<span class="params">s</span>):</span><br><span class="line">    s = <span class="string">&#x27;STRING&#x27;</span></span><br><span class="line">astring = <span class="string">&#x27;string&#x27;</span></span><br><span class="line">strchange(astring)</span><br><span class="line"><span class="built_in">print</span>(astring)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>在以上的例子中，<code>alist</code> 為可變物件，因此做為參數傳入並在函數中修改時，原始的 <code>alist</code> 也一同被修改；而 <code>astring</code> 為不可變物件，因此做為參數傳入時，我們並無法直接修改他的值，只能透過重新指派的方式給予 <code>&#39;STRING&#39;</code> 這個值，而原始的 <code>astring</code> 依然存放 <code>string</code> 這個值沒有改變。</p><p>我們在撰寫函數時，比較好的方式是不要直接修改原始參數的值，而是將修改後的值存放在新的變數中，並作為回傳值傳回給呼叫函數的地方，以避免混淆的狀況。</p><blockquote><p>參考 <a href="https://luka.tw/Python/%E5%9F%BA%E7%A4%8E%E6%95%99%E5%AD%B8/past/2021-09-21-is-python-call-by-sharing-122a4bf5a956/">關於 Python 獨有的 Pass by Assignment</a>，以及 <a href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">英文版本（Stackoverflow）</a></p></blockquote><h4 id="遞迴（Recursion）-An-example-on-factorial"><a href="#遞迴（Recursion）-An-example-on-factorial" class="headerlink" title="遞迴（Recursion） - An example on factorial"></a>遞迴（Recursion） - An example on factorial</h4><p>遞迴是一種概念，指的是「在函數在執行過程中呼叫自己」的方法。這種技術對於解決某些複雜問題特別有用，例如處理樹狀結構、遞迴搜尋、組合數學等。以下是遞迴的基本概念和特性:</p><ol><li>基礎案例（Base Case）：遞迴函數必須有一個基礎案例，也就是遞迴呼叫的終止條件。當滿足這個條件時，遞迴將不再進行，從而避免無限迴圈。</li><li>遞迴案例（Recursive Case）：如果沒有滿足基礎案例的條件，函數就會進入遞迴案例。在這個案例中，函數會呼叫一個較小的子問題版本。</li><li>問題簡化：遞迴案例通常將原始問題簡化為一個較小的子問題，直到滿足基礎案例為止。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="comment"># base case</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># recursive case</span></span><br><span class="line">        recurse = find_fact(n-<span class="number">1</span>)</span><br><span class="line">        result = n * recurse</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/S1gBbY810.png" alt="image"></p><blockquote><p>補充：<a href="https://clay-atlas.com/blog/2020/09/20/python-cn-recursionerror-maximum-recursion-depth-exceeded/">遞迴深度的上限</a></p></blockquote><p>關於函數還有很多可以講：Recursion 的設計方法、Call by Reference、Call by Value…。但有些東西太進階了，我們先停在這裡，以後有機會或是遇到的時候再細講。</p><h3 id="其他常見資料結構"><a href="#其他常見資料結構" class="headerlink" title="其他常見資料結構"></a>其他常見資料結構</h3><h4 id="元組（Tuple）"><a href="#元組（Tuple）" class="headerlink" title="元組（Tuple）"></a>元組（Tuple）</h4><ul><li>與 list 類似，但是屬不可變物件</li><li>不同於 list 使用 <code>[]</code> ，tuple 使用 <code>()</code> </li><li>一個元素的 tuple 須以 <code>(item, )</code> 表示</li><li>因屬不可變物件，故僅能以重新指派的方式修改其值，如下例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mytuple = (11, 22, 33)</span><br><span class="line">&gt;&gt;&gt; saved = mytuple</span><br><span class="line">&gt;&gt;&gt; mytuple += (44,)</span><br><span class="line">&gt;&gt;&gt; mytuple</span><br><span class="line">(11, 22, 33, 44)</span><br><span class="line">&gt;&gt;&gt; saved</span><br><span class="line">(11, 22, 33)</span><br></pre></td></tr></table></figure><ul><li>zip()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">char = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">CHAR = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(num, char, CHAR):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">(1, &#x27;a&#x27;, &#x27;A&#x27;)</span><br><span class="line">(2, &#x27;b&#x27;, &#x27;B&#x27;)</span><br><span class="line">(3, &#x27;c&#x27;, &#x27;C&#x27;)</span><br></pre></td></tr></table></figure><h4 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h4><p>當我們需要了解某個字的讀音時，我們會去查找字典，在其中尋找對應的讀音。這種 {字: 讀音} 的配對，在 Python 中可以透過字典來實現。</p><ul><li>字典的組成包含鍵（Keys，不可變）與值（Values，可變）</li><li>使用 Key 來尋找對應的 Value，以上述例子來說即為使用字尋找讀音</li><li>Key 跟 Value 可以是任何資料類別，也可以不用一樣</li><li>字典是無序的（在 <code>collections</code> 這個 library 中有提供有序字典）</li><li>若查找不存在的 key 則會報錯，可以使用 <code>in</code> 或 <code>dict.get()</code> 來檢查</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mydict = <span class="built_in">dict</span>()  <span class="comment"># or mydict = &#123;&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Here is an empty dictionary:&quot;</span>, mydict)</span><br><span class="line"><span class="comment"># Add new pair in dictionary</span></span><br><span class="line">mydict[<span class="number">1</span>] = <span class="string">&#x27;one&#x27;</span></span><br><span class="line">mydict[<span class="number">2</span>] = <span class="string">&#x27;two&#x27;</span></span><br><span class="line">mydict[<span class="number">3</span>] = <span class="string">&#x27;three&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Dictionary now looks like: &quot;</span>, mydict)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;2 is corresponding to:&quot;</span>, mydict[<span class="number">2</span>]) <span class="comment"># Access value</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">Here is an empty dictionary: &#123;&#125;</span><br><span class="line">Dictionary now looks like: &#123;1: &#x27;one&#x27;, 2: &#x27;two&#x27;, 3: &#x27;three&#x27;&#125;</span><br><span class="line">2 is corresponding to: two</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Continued from last cell</span></span><br><span class="line"><span class="built_in">print</span>(mydict.keys())</span><br><span class="line"><span class="built_in">print</span>(mydict.values())</span><br><span class="line"><span class="built_in">print</span>(mydict.items())</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> <span class="keyword">in</span> mydict)</span><br><span class="line"><span class="built_in">print</span>(mydict.get(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">dict_keys([1, 2, 3])</span><br><span class="line">dict_values([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])</span><br><span class="line">dict_items([(1, &#x27;one&#x27;), (2, &#x27;two&#x27;), (3, &#x27;three&#x27;)])</span><br><span class="line">False</span><br><span class="line">None</span><br></pre></td></tr></table></figure><h4 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h4><ul><li>與數學中的集合概念類似，只能儲存唯一（Unique）元素，相同元素不會重複出現</li><li>因為是無序，故我們不能使用 <code>set[0]</code> 的方式來取值</li><li>可以使用 <code>set.add(item)</code> 與 <code>set.remove(item)</code> 來新增與刪除元素</li><li>可以使用 <code>set(list)</code> 將 List 轉為 Set，藉此檢查清單中唯一元素個數</li><li>相關操作有聯集、交集、差集等等</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">aset = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;</span><br><span class="line">bset = &#123;<span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Union:&quot;</span>, aset | bset)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Intersection:&quot;</span>, aset &amp; bset)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Difference(A-B):&quot;</span>, aset - bset)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Difference(B-A):&quot;</span>, bset - aset)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Symmetric difference:&quot;</span>, aset ^ bset)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">Union: &#123;33, 22, 55, 11, 44&#125;</span><br><span class="line">Intersection: &#123;33&#125;</span><br><span class="line">Difference(A-B): &#123;11, 22&#125;</span><br><span class="line">Difference(B-A): &#123;44, 55&#125;</span><br><span class="line">Symmetric difference: &#123;11, 44, 22, 55&#125;</span><br></pre></td></tr></table></figure><p><img src="https://hackmd.io/_uploads/BkvMrFNM0.png" alt="image"></p><blockquote><p>補充：特別注意 <a href="https://june.monster/python-101-operators-and-priority/">運算元優先順序</a>！</p></blockquote><h4 id="統整"><a href="#統整" class="headerlink" title="統整"></a>統整</h4><table><thead><tr><th>類別</th><th>Tuple</th><th>List</th><th>Dict</th><th>Set</th></tr></thead><tbody><tr><td>符號</td><td>( )</td><td>[ ]</td><td>{ }</td><td>{ }</td></tr><tr><td>可變性</td><td>不可變</td><td>可變</td><td>可變</td><td>可變</td></tr><tr><td>順序性</td><td>有序</td><td>有序</td><td>無序</td><td>無序</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 教學系列文 (4) - 清單、CSV 檔案</title>
      <link href="/2023/03/23/python-tutorial-4/"/>
      <url>/2023/03/23/python-tutorial-4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw?view">HackMD 完整版請點我</a></p><h3 id="清單（List）"><a href="#清單（List）" class="headerlink" title="清單（List）"></a>清單（List）</h3><ul><li>清單是 Python 最常用、也最好用的資料類別，具順序性</li><li>甚麼東西都可以裝，裝的東西也可以不同，也可以用清單包清單</li><li>想成一個百寶袋，甚麼都可以塞，再拿出來<ul><li>32位python的儲存上限是536870912 個元素</li><li>64位python的儲存上限是1152921504606846975 個元素</li></ul></li><li>前面提到的字母陣列其實概念跟清單很像</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; l = [1, 1.0, 10, &quot;test&quot;]</span><br><span class="line">&gt;&gt;&gt; print(l[0])</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(l[2])</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l[2] = 100</span><br><span class="line">&gt;&gt;&gt; print(l[2])</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(l[-1])</span><br><span class="line">&quot;test&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(len(l))</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l.append(&quot;123&quot;)</span><br><span class="line">&gt;&gt;&gt; print(l)</span><br><span class="line">[1, 1.0, 100, &quot;test&quot;, &quot;123&quot;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; l.pop()</span><br><span class="line">&quot;123&quot;</span><br><span class="line">&gt;&gt;&gt; print(l)</span><br><span class="line">[1, 1.0, 100, &quot;test&quot;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(l + l)</span><br><span class="line">[1, 1.0, 100, &quot;test&quot;, 1, 1.0, 100, &quot;test&quot;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(l * 3)</span><br><span class="line">[1, 1.0, 100, &quot;test&quot;, 1, 1.0, 100, &quot;test&quot;, 1, 1.0, 100, &quot;test&quot;]</span><br></pre></td></tr></table></figure><ul><li>Traverse a list：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:   <span class="comment"># or for i in range(len(l))</span></span><br><span class="line">    <span class="built_in">print</span>(i * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure><ul><li>常見操作（Common Operations，供參考）：</li></ul><table><thead><tr><th>Method</th><th>Usage</th></tr></thead><tbody><tr><td>list.append(x)</td><td>Add element x to end of list.</td></tr><tr><td>list.sort()</td><td>Sort (order) the list. A comparison function may be passed as a parameter.</td></tr><tr><td>list.reverse()</td><td>Reverse the list.</td></tr><tr><td>list.index(x)</td><td>Returns index of first occurrence of x.</td></tr><tr><td>list.insert(i, x)</td><td>Insert x into list at index i.</td></tr><tr><td>list.count(x)</td><td>Returns the number of occurrences of x in list.</td></tr><tr><td>list.remove(x)</td><td>Deletes the first occurrence of x in list.</td></tr><tr><td>list.pop(i)</td><td>Deletes the ith element of the list and returns its value.</td></tr></tbody></table><h4 id="List-Copying"><a href="#List-Copying" class="headerlink" title="List Copying"></a>List Copying</h4><ul><li>在複製 List 時，要特別留意以下狀況，並非正確的 List 複製方法：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wrong Copy (Reference Copy Only)</span></span><br><span class="line">aList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">anotherList = aList</span><br><span class="line">anotherList[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(aList)</span><br><span class="line"><span class="comment"># Check their address</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(aList), <span class="built_in">id</span>(anotherList))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[5, 2, 3]</span><br><span class="line">1805364504896 1805364504896</span><br></pre></td></tr></table></figure><ul><li>當我們修改 <code>anotherList</code> 時，原本的 <code>aList</code> 也一同被修改</li><li>主要是因為 List 儲存的是記憶體參照（或是說 List 是可變物件，後面會提到），第三行做的事情僅僅是將參照傳給另一個變數，因此也可以發現他們的記憶體其實是相同的</li></ul><h5 id="How-to-copy-a-list-correctly"><a href="#How-to-copy-a-list-correctly" class="headerlink" title="How to copy a list correctly?"></a>How to copy a list correctly?</h5><p>有以下幾種方式可以正確地複製 List：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Correct Copy</span></span><br><span class="line">aList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># Three different ways to copy a list (Shallow)</span></span><br><span class="line">anotherList = <span class="built_in">list</span>(aList)</span><br><span class="line">anotherList = aList[:]</span><br><span class="line">anotherList = aList.copy()</span><br><span class="line"></span><br><span class="line">anotherList[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(aList)</span><br><span class="line"><span class="comment"># Check their address</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(aList), <span class="built_in">id</span>(anotherList))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[1, 2, 3]</span><br><span class="line">1805364505024 1805364643392</span><br></pre></td></tr></table></figure><blockquote><p>補充：此處使用的稱為「Shallow Copy」，僅複製容器中元素的地址<br>若連容器中的元素本身都想完全複製，需要使用「Deep Copy」<br>延伸閱讀： <a href="https://ithelp.ithome.com.tw/articles/10221255">Python - 淺複製(shallow copy)與深複製(deep copy)</a></p></blockquote><h3 id="CSV（Comma-separated-value）檔案"><a href="#CSV（Comma-separated-value）檔案" class="headerlink" title="CSV（Comma-separated value）檔案"></a>CSV（Comma-separated value）檔案</h3><ul><li>CSV 是常見的儲存資料格式</li><li>簡潔、統一、格式化、方便處理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QuotaAmount,StartDate,OwnerName,Username</span><br><span class="line">150000,2016-01-01,Chris Riley,trailhead9.ub20k5i9t8ou@example.com</span><br><span class="line">150000,2016-02-01,Chris Riley,trailhead9.ub20k5i9t8ou@example.com</span><br><span class="line">150000,2016-03-01,Chris Riley,trailhead9.ub20k5i9t8ou@example.com</span><br><span class="line">150000,2016-01-01,Harold Campbell,trailhead14.jibpbwvuy67t@example.com</span><br><span class="line">150000,2016-02-01,Harold Campbell,trailhead14.jibpbwvuy67t@example.com</span><br><span class="line">150000,2016-03-01,Harold Campbell,trailhead14.jibpbwvuy67t@example.com</span><br><span class="line">150000,2016-01-01,Jessica Nichols,trailhead19.d1fxj2goytkp@example.com</span><br><span class="line">150000,2016-02-01,Jessica Nichols,trailhead19.d1fxj2goytkp@example.com</span><br><span class="line">150000,2016-03-01,Jessica Nichols,trailhead19.d1fxj2goytkp@example.com</span><br></pre></td></tr></table></figure><p>結合前面的字串與清單處理方式，我們可以輕鬆的處理 CSV file 中的每一行資料：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; line = &#x27;amount,date,owner,user&#x27;</span><br><span class="line">&gt;&gt;&gt; data = line.split(&#x27;,&#x27;)</span><br><span class="line">&gt;&gt;&gt; print(data)</span><br><span class="line">[&#x27;amount&#x27;, &#x27;date&#x27;, &#x27;owner&#x27;, &#x27;user&#x27;]</span><br><span class="line">&gt;&gt;&gt; print(data[0])</span><br><span class="line">amount</span><br></pre></td></tr></table></figure><p>那如何處理整個 CSV file？使用檔案處理相關函數（之後再講）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.csv&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    lines = data.split(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    result.append(line.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">[[QuotaAmount,StartDate,OwnerName,Username],</span><br><span class="line">[150000,2016-01-01,Chris Riley,trailhead9.ub20k5i9t8ou@example.com],</span><br><span class="line">[150000,2016-02-01,Chris Riley,trailhead9.ub20k5i9t8ou@example.com],</span><br><span class="line">...]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 教學系列文 (3) - 條件判斷、迴圈、字串處理</title>
      <link href="/2023/03/23/python-tutorial-3/"/>
      <url>/2023/03/23/python-tutorial-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw?view">HackMD 完整版請點我</a></p><h2 id="Python-基礎-1"><a href="#Python-基礎-1" class="headerlink" title="Python 基礎 (1)"></a>Python 基礎 (1)</h2><h3 id="條件判斷（Conditionals）"><a href="#條件判斷（Conditionals）" class="headerlink" title="條件判斷（Conditionals）"></a>條件判斷（Conditionals）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">price = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> price &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s cheap.&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> price &gt;= <span class="number">100</span> <span class="keyword">and</span> price &lt; <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s okay.&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;It&#x27;s too expensive!&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>若…則… (<code>if</code>) ，否則若…則… (<code>elif</code>) ，若以上皆非則… (<code>else</code>)</li><li><code>if</code> 跟 <code>else</code> 是一組的，後面要放條件判斷 or 布林值，<code>elif</code> 可有可無</li><li>底下的指令則需縮排，讓 Python 知道哪些是條件成立需要執行的</li><li>裡面還可以再包 <code>if-else</code> （巢狀條件判斷）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ...</span><br><span class="line">    <span class="keyword">if</span> ...</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">else</span> ...</span><br><span class="line">    <span class="keyword">if</span> ...</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><ul><li>另一種寫法：A <code>if</code> condition <code>else</code> B（若 condition 為真，則執行 A ，否則執行 B）</li><li>重要：在 Python 中，縮排是很重要的，Python 會用縮排來判斷每行程式碼的所在層級，縮排不同，執行起來的結果有可能完全不同！</li></ul><h3 id="迴圈（Iterations）"><a href="#迴圈（Iterations）" class="headerlink" title="迴圈（Iterations）"></a>迴圈（Iterations）</h3><ul><li>我們很常需要電腦幫我們做重複的工作</li><li>迴圈就可以幫我們達到此目的</li><li>迴圈基本上分為兩種語法： <code>while</code> 跟 <code>for</code></li><li><code>while</code> 可以想成不斷執行的 <code>if</code>，直到條件不再成立為止<ul><li>要小心「無窮迴圈」的發生</li></ul></li><li><code>for</code> 則是針對清單內的元素，每個都執行一次所有指令<ul><li>常搭配 range() 或是清單一起使用</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The loop ends.&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]:  <span class="comment"># Or for i in range(3):</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The loop ends.&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Output：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">The loop ends.</span><br></pre></td></tr></table></figure><blockquote><p>備註：<code>i</code> is called ‘Loop Counter’ in above examples<br>For 迴圈會自動更新 Loop Counter，While 迴圈則不會</p></blockquote><h4 id="無窮迴圈（Infinite-Loop）"><a href="#無窮迴圈（Infinite-Loop）" class="headerlink" title="無窮迴圈（Infinite Loop）"></a>無窮迴圈（Infinite Loop）</h4><ul><li>當一個迴圈無法停止執行時，就稱為無窮迴圈</li><li>無窮迴圈只能透過強制停止的方式來結束！（Ctrl + C）</li><li>示範：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="number">4</span> &gt; <span class="number">3</span>:  <span class="comment"># A always true condidtion </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Loop&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Range"><a href="#Range" class="headerlink" title="Range()"></a>Range()</h4><p>上面的例子中有使用到 range()，而 range() 是能夠幫助我們創造一個範圍的函數，其用法為：</p><ul><li><code>range(n)</code> 會回傳 <code>[0,1,2,...n-1]</code> 的清單</li><li><code>range(m,n)</code> 會回傳 <code>[m,m+1,m+2,...n-1]</code> 的清單</li><li><code>range(m,n,k)</code> 會回傳 <code>[m,m+k,m+2k,...]</code> 的清單，最後一個元素不超過 n-1</li></ul><p>一般的情況下使用第一個就好。</p><blockquote><p>備註：回傳型態其實不完全是清單，但我們先把它當成清單用就好<br>可以透過 <code>list()</code> 將其轉為清單</p></blockquote><h4 id="巢狀迴圈（Nested-Loop）"><a href="#巢狀迴圈（Nested-Loop）" class="headerlink" title="巢狀迴圈（Nested Loop）"></a>巢狀迴圈（Nested Loop）</h4><ul><li>迴圈裡也可以再放迴圈，很多複雜的程式都需要用到</li><li>要注意各個迴圈的執行順序與邏輯，同時撰寫避免不必要的迴圈</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&gt;&quot;</span>,j)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=====&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">0</span><br><span class="line">&gt; 0</span><br><span class="line">&gt; 1</span><br><span class="line">=====</span><br><span class="line">1</span><br><span class="line">&gt; 0</span><br><span class="line">&gt; 1</span><br><span class="line">=====</span><br><span class="line">2</span><br><span class="line">&gt; 0</span><br><span class="line">&gt; 1</span><br><span class="line">=====</span><br></pre></td></tr></table></figure><h4 id="迴圈特殊處理-break-continue"><a href="#迴圈特殊處理-break-continue" class="headerlink" title="迴圈特殊處理 - break &amp; continue"></a>迴圈特殊處理 - break &amp; continue</h4><ul><li><code>break</code>：跳出迴圈外，直接結束迴圈執行</li><li><code>continue</code>：跳過後面的指令，直接結束此次迴圈，並進行下一次迴圈</li><li>用以控制迴圈，給予迴圈多個「出口」</li><li>若放在多重迴圈內，只會跳出一層迴圈</li><li>要小心不要寫出沒有意義的 <code>break</code> &amp; <code>continue</code>！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>):</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="字串處理"><a href="#字串處理" class="headerlink" title="字串處理"></a>字串處理</h3><ul><li>字串基本上可視為字母陣列 (Array)，基本操作如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &#x27;String&#x27;</span><br><span class="line">&gt;&gt;&gt; print(type(s))</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s[0])</span><br><span class="line">&#x27;S&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s[-1])</span><br><span class="line">&#x27;g&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(len(s))</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s+s)</span><br><span class="line">&#x27;StringString&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s,s)</span><br><span class="line">String String</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s+&quot;&amp;&quot;+s)</span><br><span class="line">String&amp;String</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s*3)</span><br><span class="line">StringStringString</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s.replace(&#x27;Str&#x27;,&#x27;do&#x27;))</span><br><span class="line">doing</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s.find(&#x27;ing&#x27;))</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s.upper())</span><br><span class="line">STRING</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(s.lower())</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; print(&#x27;t&#x27; in s)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 教學系列文 (2) - 寫程式的流程、電腦架構、二進位制、排版方式</title>
      <link href="/2023/03/23/python-tutorial-2/"/>
      <url>/2023/03/23/python-tutorial-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw?view">HackMD 完整版請點我</a></p><h3 id="寫程式的流程（Workflow）"><a href="#寫程式的流程（Workflow）" class="headerlink" title="寫程式的流程（Workflow）"></a>寫程式的流程（Workflow）</h3><ul><li>Debug：在我們遇到各種 Error 時，需要去檢查程式哪裡寫錯</li><li>有時候是語法錯、有時候是邏輯錯…</li><li>整體的寫程式流程：<br><img src="https://i.imgur.com/kDs6oep.png"></li></ul><h3 id="電腦架構"><a href="#電腦架構" class="headerlink" title="電腦架構"></a>電腦架構</h3><p>非常簡易版的架構圖如下：</p><ul><li>Input：鍵盤、滑鼠、觸控螢幕、麥克風等等</li><li>Output：螢幕、喇叭、印表機等等</li><li>Storage：硬碟、光碟機等等</li><li>CPU（中央處理器）：負責電腦的大部分運算</li><li>Memory：電腦內暫存的記憶體空間</li></ul><blockquote><p>補充 - GPU（顯示卡）：負責遊戲、3D繪圖、機器學習等等運算<br>若對這個有興趣的話，可以去查「計算機結構」或修相關課程</p></blockquote><p><img src="https://i.imgur.com/pmeyrcm.png"></p><h3 id="二進位制"><a href="#二進位制" class="headerlink" title="二進位制"></a>二進位制</h3><ul><li>電腦使用二進位制來儲存數值，簡易的對照如下圖</li></ul><blockquote><p>若對這個有興趣的話，可以去查「數位邏輯」、「電路學」或修相關課程</p></blockquote><p><img src="https://i.imgur.com/o0VuIPk.png"></p><h3 id="排版方式（Formatting）"><a href="#排版方式（Formatting）" class="headerlink" title="排版方式（Formatting）"></a>排版方式（Formatting）</h3><p>一些排版準則如下：</p><ul><li>通常在運算元前後會空白</li><li>在每個區段的 code 前後會空行，才不會全部擠在一起不好分辨</li><li>變數命名要有意義，讓別人也看得懂你在寫什麼</li><li>加入註解提高程式易讀性，並說明撰寫邏輯、使用方法等等</li></ul><p>寫程式除了讓他可以執行以外，讓別人看懂也是一件很重要的事情。<br>當未來需要進行多人的大型開發時，程式碼的簡潔易懂可以大大加快開發協作時間。<br>想了解更多可以搜尋 Google coding style 或 SOLID 原則。</p>]]></content>
      
      
      <categories>
          
          <category> Python 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 教學系列文 (1) - Overview、環境建置、基礎語法</title>
      <link href="/2023/03/23/python-tutorial-1/"/>
      <url>/2023/03/23/python-tutorial-1/</url>
      
        <content type="html"><![CDATA[<p>哈囉！這次來發一些關於 Python 的教學文章，會有這個系列文，主要是因為前陣子接了一個家教，就順便把辛苦整理的自編講義一起放上來了，內容雖然不深，但也涵蓋了初學 Python 所會碰到的各主題，若完全對 Python 不了解的話，這個系列文應該可以給你一些概念，完成後若想再自我進修也能大概有個方向。</p><p>此系列文預計會分十篇左右，內容涵蓋基礎語法、迴圈、函數、套件、類別等等主題，皆有範例程式碼可以參考，基本內容都會涵蓋到，不過因為我原本是做講義用，文字部分不會太詳盡。另外，雖然公開在網路上，但希望各位轉載還是標註一下來源，畢竟也是我辛辛苦苦整理的心血呢。<del>最後，有興趣的話，我還有在接學生（偷打廣告 XD）。</del></p><p><a href="https://hackmd.io/w5n1Ow8NSea_-UAeXTJDSw?view">HackMD 完整版請點我</a></p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>程式語言分為高階語言、組合語言、機器語言等等，Python屬於高階語言的一種。機器語言與組合語言直接控制電腦硬體，但難以閱讀與開發；高階語言易於閱讀與開發，但需要「翻譯」給電腦聽。</p><blockquote><p>來自 Python 官方網站的介紹：<br>Python 是一種易學、功能強大的程式語言。它有高效能的高階資料結構，也有簡單但有效的方法去實現物件導向程式設計。Python 優雅的語法和動態型別，結合其直譯特性，使它成為眾多領域和大多數平臺上，撰寫腳本和快速開發應用程式的理想語言。</p></blockquote><p>常見應用：網站開發、資料分析、機器學習、遊戲開發、網路爬蟲…<br>其他語言：C、C++、R、Java、JavaScript、SQL、Go、Ruby……</p><h3 id="學習地圖"><a href="#學習地圖" class="headerlink" title="學習地圖"></a>學習地圖</h3><p>以臺大資工系必修為例：<br><img src="https://i.imgur.com/Y2AdRO3.png"><br>以臺大資管系必修為例：<br><img src="https://i.imgur.com/aC9lfrs.png"></p><h2 id="Python-入門"><a href="#Python-入門" class="headerlink" title="Python 入門"></a>Python 入門</h2><h3 id="環境建置"><a href="#環境建置" class="headerlink" title="環境建置"></a>環境建置</h3><ul><li>互動模式<ul><li>Open Terminal（終端機） and input ‘python’</li><li>Execute each line directly</li><li>If Python is not installed, go to <a href="https://www.python.org/downloads/">Python official website</a></li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 + 2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><ul><li>腳本模式<ul><li>Need interpreter（直譯器） to help ‘translate’</li><li>Execute the whole file or block at once</li><li>VSCode 示範 - .py 檔 與 .ipynb 檔</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The loop ends.&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Output：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">The loop ends.</span><br></pre></td></tr></table></figure><ul><li><a href="https://www.citerp.com.tw/citwp2/2021/12/22/vs-code_python_01/">VSCode 安裝教學</a></li></ul><blockquote><p>補充：<a href="https://medium.com/ccclub/ccclub-python-for-beginners-tutorial-c23859d2bde4">使用 Anaconda 來建置開發環境</a></p></blockquote><h3 id="基礎語法（Basic-Syntax）"><a href="#基礎語法（Basic-Syntax）" class="headerlink" title="基礎語法（Basic Syntax）"></a>基礎語法（Basic Syntax）</h3><ul><li>Our first program: <code>print(&quot;Hello World!&quot;)</code><ul><li><code>print()</code> 是一個函數 （function）</li><li>“Hello World!” 是給予這個函數的輸入</li><li>此函數會幫助我們印出給定的輸入，給使用者看</li></ul></li></ul><h4 id="計算（Computation）"><a href="#計算（Computation）" class="headerlink" title="計算（Computation）"></a>計算（Computation）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; # This is a comment（註解）</span><br><span class="line">&gt;&gt;&gt; # A comment will not be executed by python</span><br><span class="line">&gt;&gt;&gt; 1 + 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; 3 - 1</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 5 * 2</span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; 5 ** 2      # 5 的 2 次方</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; 8 / 5       # 8 除以 5（回傳小數）</span><br><span class="line">1.6</span><br><span class="line">&gt;&gt;&gt; 8 // 5      # 8 除以 5 的商</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 8 % 5       # 8 除以 5 的餘數（取 mod）</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; (50 - 5 * 6) / 4</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure><h4 id="變數（Variable）"><a href="#變數（Variable）" class="headerlink" title="變數（Variable）"></a>變數（Variable）</h4><ul><li>我們會需要變數來存放數值運算的結果，使用 <code>=</code> 可以將數值指派給變數，可以參考 <a href="https://ithelp.ithome.com.tw/articles/10217188">基本命名規則</a></li><li>若重複指派給相同名稱的變數，原本的值會被覆蓋掉！</li><li><code>a = 10</code> 意為指派 10 給 a（右邊的值丟給左邊的容器）</li><li><code>a == 10</code> 意為比較 a 是否等於 10（為邏輯判斷式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; width = 20</span><br><span class="line">&gt;&gt;&gt; height = 5 * 9</span><br><span class="line">&gt;&gt;&gt; width * height</span><br><span class="line">900</span><br></pre></td></tr></table></figure><ul><li>讀取變數</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; var = input()</span><br><span class="line">3   # 使用者自行輸入</span><br><span class="line">&gt;&gt;&gt; print(var)</span><br><span class="line">3   # 電腦將 var 的值印出</span><br></pre></td></tr></table></figure><blockquote><p>進階：<a href="https://zhuanlan.zhihu.com/p/36173202">Python 下劃線的意義</a></p></blockquote><h4 id="資料類別（Data-Type）"><a href="#資料類別（Data-Type）" class="headerlink" title="資料類別（Data Type）"></a>資料類別（Data Type）</h4><ul><li>在宣告變數時，Python 自動幫我們決定資料類別</li><li>其他語言（如 C++） 可能需要做類別宣告：<code>int a = 1</code></li><li>常見的基礎資料類別如下：<ul><li>整數 integer - <code>3</code></li><li>小數（浮點數） float - <code>3.0</code></li><li>字母 character - <code>&#39;a&#39;</code></li><li>字串 string - <code>&quot;This is a string&quot;</code></li><li>布林值 Boolean - <code>True</code> (Non-zero) &#x2F; <code>False</code> (Zero)</li></ul></li></ul><blockquote><p>補充：String 是由 Character 組成的陣列，其他語言有可能會將 String 與 Character 當作兩種資料類別，但在 Python 中沒有 Character 的概念，因此長度為一的字母在 Python 中也會被當成字串來做處理。</p></blockquote><h4 id="型別轉換（Casting）"><a href="#型別轉換（Casting）" class="headerlink" title="型別轉換（Casting）"></a>型別轉換（Casting）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str(3)</span><br><span class="line">&#x27;3&#x27;</span><br><span class="line">&gt;&gt;&gt; int(&quot;3&quot;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; float(3)</span><br><span class="line">3.0</span><br><span class="line">&gt;&gt;&gt; float(&quot;string&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">ValueError: could not convert string to float: &#x27;string&#x27;</span><br><span class="line">&gt;&gt;&gt; type(3)  # 檢查資料類別</span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure><h4 id="指派-自我指派-（Assignment-Self-assignment）"><a href="#指派-自我指派-（Assignment-Self-assignment）" class="headerlink" title="指派 &amp; 自我指派 （Assignment &amp; Self-assignment）"></a>指派 &amp; 自我指派 （Assignment &amp; Self-assignment）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a = a + <span class="number">2</span>    <span class="comment"># 把 a + 2 指派給 a</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">a += <span class="number">2</span>       <span class="comment"># a 自己等於自己 + 2</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Output:</span><br><span class="line">10</span><br><span class="line">12</span><br><span class="line">14</span><br></pre></td></tr></table></figure><blockquote><p>相同的還有 <code>-=</code> <code>/=</code> <code>*=</code> <code>//=</code> <code>**=</code> <code>%=</code> …</p></blockquote><h4 id="比較-邏輯運算元（Comparison-Logical-Operators）"><a href="#比較-邏輯運算元（Comparison-Logical-Operators）" class="headerlink" title="比較&#x2F;邏輯運算元（Comparison &amp; Logical Operators）"></a>比較&#x2F;邏輯運算元（Comparison &amp; Logical Operators）</h4><ul><li>&lt; &#x2F; &lt;&#x3D;：小於 &#x2F; 小於等於</li><li>&gt; &#x2F; &gt;&#x3D;：大於 &#x2F; 大於等於</li><li>&#x3D;&#x3D; &#x2F; !&#x3D;：等於 &#x2F; 不等於</li><li><code>and</code>：且</li><li><code>or</code>：或</li><li><code>not</code>：非</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python 教學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Tutorial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安裝 Windows 與 Linux 雙系統</title>
      <link href="/2023/02/24/install-windows-and-linux/"/>
      <url>/2023/02/24/install-windows-and-linux/</url>
      
        <content type="html"><![CDATA[<p>繼上一篇選完電腦配件、下完單取完貨之後，拿回家第一件事就是裝作業系統啦，不然開機只有 BIOS 介面，都沒辦法使用呢。我對這塊一開始也是完全不熟，還好在慢慢摸索跟問朋友之後，花個一兩天總算是都搞定了。本文會簡單分享我裝雙系統的過程，還有途中遇到的一些小困難，順便也會分享一些實用的資源給大家。</p><p>本文圖少連結多，因為拍圖太麻煩了，還請見諒，提供的連結中很多圖跟影片，可以去那邊看。</p><h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>其實一般來說，買電腦時若有順便加購正版的 Windows，店家通常會幫你一起裝好再交給你，但我因為想省一些預算（正版真的太貴了，我預算都花在顯卡上嗚嗚，但這樣還是不太好大家不要學），所以我並沒有購買，而是打算自己上網研究如何自己安裝。</p><p>而 Linux 本身是個免費且完全開源的作業系統，也很推薦大家去使用，但使用的大多是有工作需求等等，或是想自己對作業系統有更多的操作及掌握，不然一般消費者主要還是用 Windows 居多。我自己本身是有學業需求，加上我需要 Windows 讓我玩遊戲（不然就白白浪費我的顯卡了！），所以決定以雙系統的方式，買兩顆硬碟一個系統各一顆，也建議雙系統最好買兩個硬碟，不然搞磁碟分割會大概搞死你。</p><p>在電腦還沒來之前，我們可以先用 <a href="https://rufus.ie/zh_TW/">Rufus</a> 來製作好開機隨身碟，等到電腦來就可以馬上安裝。開機隨身碟的意思就跟灌系統的光碟差不多，我們用 Rufus 來將系統映像檔（副檔名是 .iso）燒錄到隨身碟中，這樣就可以暫時先用該隨身碟開機，並且裡面的檔案會幫助我們將作業系統安裝到電腦上的硬碟中。</p><p>我的安裝順序：Windows 11 - Win 11 相關驅動 - Win 11 相關軟體 - Ubuntu 22.04 LTS - Ubuntu 深度學習環境建立 - Ubuntu 相關軟體，各位可以視自己需要哪些東西挑選查看。另外我主要的流程都是參照 <a href="https://www.youtube.com/watch?v=yMHOpOuyjdc">這個影片</a>，他是在已有 Win 11 的狀況下安裝 Ubuntu，講解得非常詳細，也很推薦大家參考。</p><h2 id="Windows-環境建立"><a href="#Windows-環境建立" class="headerlink" title="Windows 環境建立"></a>Windows 環境建立</h2><h3 id="安裝-Windows-11"><a href="#安裝-Windows-11" class="headerlink" title="安裝 Windows 11"></a>安裝 Windows 11</h3><p>前面提到的 <a href="https://trnpp-my.sharepoint.com/personal/taiwan001ytshare01_trnpp_onmicrosoft_com/_layouts/15/onedrive.aspx?id=/personal/taiwan001ytshare01_trnpp_onmicrosoft_com/Documents/YT%20Files/Win11%20%E7%A0%B4%E8%A7%A3%E5%AE%89%E8%A3%9D%E6%AA%94&ga=1">映像檔</a> 我是在網路上找到的，他還有附上 <a href="https://www.youtube.com/watch?v=On1ItiNo6qo">教學影片</a>，應該算是蠻詳細的，基本上照著操作就好，Rufus 的操作方法則可以參考 <a href="https://www.cc.ntust.edu.tw/var/file/50/1050/img/2915/USB_boot_disk(C)1105.pdf">這裡</a>，在硬碟都沒系統的狀況下，可開機 USB 插下去後打開電腦，應該就會自動從該 USB 進行開機，若沒有的話再進 BIOS 調整，這部分後面會提到。另外，如果安裝完成且連上網路後，Win 11 仍沒有啟用，可以參考相同作者開發的 <a href="https://www.youtube.com/watch?v=xmNmExsJeB4">啟用器</a>，但我是沒有用到啦，他原本提供的破解版我是可以正常使用，連上網路後就一切正常。</p><h3 id="如何安裝相關驅動"><a href="#如何安裝相關驅動" class="headerlink" title="如何安裝相關驅動"></a>如何安裝相關驅動</h3><p>在安裝完 Win 11 後還沒結束，我們還需要做一些基本的設置，電腦才能正常使用。推薦大家參考 <a href="https://ofeyhong.pixnet.net/blog/post/213842830-%E3%80%90%E7%B6%93%E9%A9%97%E8%AB%87%E3%80%91%E9%A9%85%E5%8B%95%E7%A8%8B%E5%BC%8F%E7%9A%84%E5%AE%89%E8%A3%9D%E9%A0%86%E5%BA%8F">這篇</a> 跟 <a href="https://ofeyhong.pixnet.net/blog/post/223795851">這篇</a> 介紹，簡單來說就是要安裝主機板驅動、顯卡驅動跟做 Windows Update 啦。</p><p>安裝主機板驅動時，你可能會遇到跟我一樣的問題：我家中沒有有線網路，需要連 wifi 才能下載，但為甚麼我找不到相關的設定頁面？答案是：因為你還沒裝 wifi 驅動！我當初在這邊卡了好一段時間，家中找不到網路線，當時大半夜的也沒地方買，還好友人提供給我一個辦法：從筆電上下載再移到桌機中安裝，真的是解救我沒網路的困境。而三個東西都完成後，基本上 Windows 11 就安裝完成啦！你就可以去安裝你想安裝的各種軟體，開始正常使用它了~</p><p>補充：主機板驅動與顯卡驅動，到官網尋找對應型號下載，並視自己需求安裝即可，基本上主機板驅動有幾個是可以不用裝的，顯卡驅動應該是一定得裝除非你沒顯卡。Windows Update 就到設定裡讓他自己下載就好。另外有些主機板好像會連網後自動下載驅動，但因為我是下載驅動後才能連網所以我也不確定。</p><h2 id="Linux-環境建立"><a href="#Linux-環境建立" class="headerlink" title="Linux 環境建立"></a>Linux 環境建立</h2><h3 id="安裝-Ubuntu-22-04-LTS"><a href="#安裝-Ubuntu-22-04-LTS" class="headerlink" title="安裝 Ubuntu 22.04 LTS"></a>安裝 Ubuntu 22.04 LTS</h3><p>現在我們已經裝好 Windows 11 了，下一步準備來裝 Ubuntu，因為我們現在的狀況跟第一部影片一樣，基本上可以跟著操作。Ubuntu 的系統映像檔在官網上就有了，應該很容易找到，下載後一樣用 Rufus 燒錄到隨身碟中。（補充：前面安裝的映像檔好像因為版本而不能關閉 Win 11 的快速啟動，不過沒關係這個不影響我們之後開機）</p><p>這邊要注意，因為我們已經有安裝好的作業系統了，開機預設便會是從已安裝好的地方啟動，因此我們在插入開機 USB 後，要進入 BIOS 手動修改開機順序，將 USB 的順位移到第一個，如同影片中所操作的，再重開機就可以進入 Ubuntu 安裝頁面了；或者是有些 BIOS 會有地方讓你直接點選想開機的裝置，直接選該 USB 即可進入 Ubuntu 安裝頁面，後面就跟隨說明安裝就好。</p><p>分配硬碟空間時要小心，盡量一次決定好如何分配，我第一次安裝時因為想說留點空間之後用，結果後來又想說全配給 Ubuntu，在那邊亂修改硬碟的 Partition Table，搞到最後無法開機，只好進 Windows 把 Ubuntu 的硬碟格式化全部重裝，浪費了我不少時間跟精力，也算是學個經驗吧。</p><h3 id="如何建立深度學習環境（顯卡驅動、CUDA、cuDNN、Miniconda）"><a href="#如何建立深度學習環境（顯卡驅動、CUDA、cuDNN、Miniconda）" class="headerlink" title="如何建立深度學習環境（顯卡驅動、CUDA、cuDNN、Miniconda）"></a>如何建立深度學習環境（顯卡驅動、CUDA、cuDNN、Miniconda）</h3><p>關於這些東西的安裝，網路上還蠻多一步一步的教學跟錯誤解釋，我就不贅述了，附上幾個連結給大家參考：</p><ul><li><a href="https://medium.com/@scofield44165/ubuntu-20-04%E4%B8%AD%E5%AE%89%E8%A3%9Dnvidia-driver-cuda-11-4-2%E7%89%88-cudnn-install-nvidia-driver-460-cuda-11-4-2-cudnn-6569ab816cc5">Ubuntu 20.04中安裝nvidia-driver-460版 &amp; CUDA-11.4.2版 &amp; cuDNN</a></li><li><a href="https://hackmd.io/@RinKu1998/B1MpzO3sD">Ubuntu 20.04 安裝深度學習環境(Nvidia驅動、CUDA 10+CuDNN 7.6.5)</a></li><li><a href="https://zhuanlan.zhihu.com/p/474343311">Ubuntu20.04 NVIDIA 显卡驱动，CUDA，CuDNN安装</a></li></ul><p>雖然三者的指令有些差異，安裝方法也不盡相同，但反正大家就參考一下，自己判斷如何安裝最適合，以下提供檢查是否安裝成功的指令：</p><ul><li>Nvidia Driver：<code>nvidia-smi</code>，也可以使用 <code>gpustat</code> 來檢查，有出現版本或顯卡名稱即可</li><li>CUDA：<code>nvcc -V</code>，有出現版本及相關資訊即可</li><li>cuDNN：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /usr/src/cudnn_samples_v8/ .</span><br><span class="line"><span class="built_in">cd</span>  ./cudnn_samples_v8/mnistCUDNN</span><br><span class="line">make clean &amp;&amp; make</span><br><span class="line">./mnistCUDNN</span><br><span class="line"><span class="comment"># 若出現 Test Passed 則代表安裝成功</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若 make 時報 fatal error: FreeImage.h，則執行以下指令，並重新執行 make</span></span><br><span class="line">sudo apt-get install libfreeimage3 libfreeimage-dev</span><br></pre></td></tr></table></figure><p>至於 Miniconda 就到官網下載安裝就好，毫無難度，用來建立虛擬環境很方便；其他軟體也可以到 Ubuntu 的商店頁面尋找，或是上瀏覽器直接下載安裝包，也很簡單。</p><h2 id="BIOS-設定及開機方式"><a href="#BIOS-設定及開機方式" class="headerlink" title="BIOS 設定及開機方式"></a>BIOS 設定及開機方式</h2><p>兩者都安裝完成後，再回到 BIOS 頁面，將開機順位中，Ubuntu 所在的硬碟設為第一順位，並順手關掉主機板的快速啟動，就完成整個雙系統的設定了。以後按下電腦的電源鍵後，會進入 Ubuntu 的開機選單頁面，這時候約十秒後預設會進入 Ubuntu，若要進入 Windows 則在時間內手動選擇即可。大功告成，是不是很有成就感呢！</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>桌電相關的文章應該暫時告一段落了，之後有想到再回來補充分享，目前我已經可以正常使用雙系統，用 Windows 打遊戲、用 Linux 跑模型了，一機兩用真的是十分方便，也不會浪費我超貴的電腦配備，若是對雙系統有興趣，不仿自己試著裝裝看，在過程中也可以對電腦有更深入的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PC </tag>
            
            <tag> OS </tag>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新手自己配電腦 -  64k 跑遊戲 + 深度學習用桌機</title>
      <link href="/2023/02/18/build-my-own-pc/"/>
      <url>/2023/02/18/build-my-own-pc/</url>
      
        <content type="html"><![CDATA[<p>先說結論，最近在學習如何選購桌電配備，對於桌電領域完全不熟的我，研究了好一陣子之後，最後用 64k 的價格，配了一臺效能令我十分滿意的桌電。身為資工所的宅宅學生，沒有一臺強大的桌電用來打遊戲、跑模型，那怎麼說的過去呢！</p><p>好啦，其實事情緣起是這樣的：去年十一月在尋找指導教授，跑訪各實驗室時，都會順便詢問學長姐實驗室的硬體資源如何，畢竟研究所的課對硬體要求頗高，如果硬體不好應該會過得很痛苦。雖說資工所大部分的實驗室硬體資源都不錯，有些一人一張 3090，甚至還有聽說正要添購 40 系列的，然而，我最後找的教授的實驗室，共用硬體竟然只有 4 張 10 系列顯卡，真的是完全沒辦法用啊！當初學長就有跟我講過這件事，最後根據整體考量下還是硬著頭皮選了，所以自己組一臺電腦就成了必須（順便組起來玩遊戲也方便），也因此才有今天這篇文章的產出。</p><p><img src="/img/post/2023_02/mypc.jpg" alt="最後組起來的樣子，RGB 燈光真的是賞心悅目"></p><h2 id="我的需求、預算與配置"><a href="#我的需求、預算與配置" class="headerlink" title="我的需求、預算與配置"></a>我的需求、預算與配置</h2><p>在我需求的部分，我最主要是學業所需，兩年的研究所內我預計會需要跑不少的深度學習模型，所以效能不能太差，在 CPU 與 GPU 方面皆是，特別是顯卡的 VRAM 不能太低；而預算方面我預計這臺可以用個五到十年，所以抓 60k - 70k 左右，不太希望超過 70k。</p><p>我最後的配置如下，價格（除顯卡）是 2&#x2F;11 在欣亞購買的價格（臺北比較有名的電腦店就是原價屋跟欣亞了，兩者聽說差不多，如果你有其他信任的店家應該也可以），也會請他們幫忙組裝，從下單到組裝完成到我等了 7 天。這裡不得不抱怨一下，原本跟我說週三、週四會好，週四打過去問又說週五，週五當天打過去跟我說完全還沒裝，怒噴了他一番後終於承諾晚上給我，看了地圖上評論最近好像常常這樣，建議各位要有心理準備，然後記得定期打電話查勤。不過工作人員人都很好啦，所以還是不跟他計較太多了：</p><p><img src="/img/post/2023_02/mypc_setup.jpg" alt="我的桌電配備，機殼還給我突然沒貨 QQ"></p><h2 id="各項配件挑選方式"><a href="#各項配件挑選方式" class="headerlink" title="各項配件挑選方式"></a>各項配件挑選方式</h2><p>一直到最近開始認真研究，我才知道一臺電腦的基本組成配件有哪些，以及該如何看配件的規格。這邊就簡單說一下我大概如何挑選（以下也是我自己的理解，若有誤還請見諒），也針對每個部件的功用做簡單介紹，讓對桌電完全不懂的人，看完後也能大概有點概念，若想更深入了解可以參考下方相關網站的第一個，裡面針對各個配件有很詳細的介紹。</p><h3 id="中央處理器（CPU）"><a href="#中央處理器（CPU）" class="headerlink" title="中央處理器（CPU）"></a>中央處理器（CPU）</h3><p>中央處理器就如同人的大腦，主要負責電腦大大小小的運算與任務排程、資源分配等等，而一般消費者主要的選擇不外乎就是 Intel 與 AMD 這兩家公司，若是做深度學習則建議選 Intel，以避免一些奇奇怪怪的問題。</p><p>Intel 的 CPU 型號主要看兩個點，一個是系列（i3, i5, i7, i9）一個是世代（最新為 13 代），兩者都是數字越大越好：</p><ul><li>i3：低階，多為文書機使用，但基本上一般不選這個</li><li>i5：中階，是一般消費者最常選的系列，效能也算可接受</li><li>i7：中高階，追求效能的遊戲機多選這個，我自己也是</li><li>i9：高階，多是頂級遊戲使用者才會選擇</li></ul><p>舉例來說，我買的 CPU 型號是 Intel i7-13700，就是 Intel i7 系列第 13 代的產品，有些後面還會有英文後綴如 K（可超頻，就是可以手動讓他更強）、F（無內顯，但我不建議，有內顯的好處是顯卡壞了還可以用內顯擋一下）等等，就看個人需求選擇。題外話，我筆電是大一時買的，CPU 是 i5-8250U，當初應該是最新的，過了五年 CPU 差了五代，只能說電子產品真的是更新很快！</p><p><img src="/img/post/2023_02/pc_inside.jpg" alt="電腦的內部長相，玻璃側板很方便就可以打開來"></p><h3 id="顯示卡（GPU）"><a href="#顯示卡（GPU）" class="headerlink" title="顯示卡（GPU）"></a>顯示卡（GPU）</h3><p>顯示卡主要用途為顯示（廢話），基本上就是連接電腦主機跟螢幕的地方啦，而由於其一些特殊的運算性質，所以舉凡玩遊戲、3D 繪圖、影片剪輯、挖礦、跑深度學習等等，都對顯卡的效能有一定的要求。對我來說最主要組桌電的原因，也是因為我的筆電顯卡超級爛（筆電一般也不會塞或塞不下太好的顯卡啦），跑深度學習實在是太吃力了，再加上實驗室的顯卡老實說也是蠻爛的，只好自己花點錢買給自己用。</p><p>主流顯卡分為兩種晶片架構，分別是 NVIDIA 與 AMD，而深度學習又多以 NVIDIA 為主，性能表現兩家應該差不多。前述兩家是晶片商，而晶片商會再與其他公司搭配，由其他公司推出完整的顯卡商品，主要廠商像是華碩、微星、技嘉等等，我們主要買也是從這三家去挑，而同樣的晶片型號會因這三家廠商的調教不同，而推出不同等級的產品，像是技嘉就有 EAGLE 或 Gaming 系列等等。</p><p>晶片型號的辨別方式的話，以 NVIDIA 來說會有四個數字跟後綴英文，數字兩兩一組，分別代表世代以及性能，舉例來說 4090 就是 40 世代中 90 系列的顯示卡，若後綴有像是 SUPER 或 TI 等通常表示再更上一個等級，像是 3090 TI 就比 3090 再更強一些。關於顯卡晶片的強度很多網站都有詳細比較，這邊推薦一個 <a href="https://www.mydrivers.com/zhuanti/tianti/gpu/index.html">顯卡天梯</a> 給大家，在選購時我主要會比較 VRAM、CUDA 核心數、功耗等等數據，這邊順便給大家一些判准參考：</p><ul><li>一般消費者對顯卡的選擇大約落在 50 - 70 系列，高階遊戲玩家或有特殊需求才會上到 80、90 系列</li><li>要順跑現在的 3A 遊戲大作，大概 3060 系列以上都可以，2060 左右的應該勉強也行</li><li>若是要跑深度學習，則 VRAM 越大越有優勢，Batch Size 可以調大，也可以放更大的 Model</li><li>顯卡越好其他配件也要做相應的提升，才有辦法好好發揮顯卡的能力（這項適用所有配件）</li></ul><p><img src="/img/post/2023_02/gpu.jpg" alt="在臉書社團收到的二手 3090 TI，我還特地跑去新竹面交"></p><p>買顯示卡算是我在配這台電腦的過程中，波折最多的一項配件了。在以前好像只有遊戲玩家才會對他有一定的要求，然而最近因為該死的礦潮，顯示卡的價格可以說是波動頻繁又居高不下，甚至已經到了離譜的地步，最新的 4090 一張賣到 6 萬塊，都可以組兩臺文書機了，這價錢根本是在開玩笑，買到撞到。以我的預算以及需求，在研究了一陣子之後，最適合的我覺得大概是 3090 系列，效能強、VRAM 又大，完全可以符合我玩遊戲 + 跑深度學習的需求，現在的價位也還算勉強可以接受，大約一張 3 萬上下。</p><p>但很不幸的，2023 年初正在經歷顯卡換代，3080 與 3090 系列已經停產，加上廠商為了 40 系列的鋪路，也已經將 30 高階系列的庫存清得差不多（價格甜蜜點在 2022 年下半年，那時候 3080、3090 可以用 2 萬 - 3 萬買到），所以現在市場上的庫存只剩超級盤的 40 系列，以及 3070 TI 以下的 30 中低階顯卡，我跑遍了整個光華商場，問遍了八德路上每家電腦店，完全找不到 3090 系列（有找到一張過，但手腳不夠快被他組掉了…）。</p><p>完全束手無策之際，我只剩下兩個選項：買二手顯卡或是等效能更強的 4090 降價。思考了一陣子後，覺得 4090 要降到我願意接受的價格，大概還要個一年到一年半，到時候我碩士都念一半了！所以最後只好到臉書的電腦配件交易社團買二手顯卡，還好運氣還算不錯，最後用 28.5k 的價格，買到去年 12 月購入的 3090 TI，面交時實際看他測跑分也沒什麼問題，就等到時候其他配件到貨，再裝上去試試看了。</p><p>這邊要特別注意的是，因為最近礦潮退燒，所以現在二手市場上充斥著許多二手礦卡，而礦卡我建議能不碰就不碰，因為礦卡大多都是 24 小時不休息在跑的，而長時間處在高溫高壓的環境下，對電子零件的壽命很有影響，因此常常看到買二手礦卡沒多久就出問題，而原廠也會因為一些規定，即使在保固內也不給礦卡維修，到頭來等於花了冤枉錢。顯卡這東西，最好還是購買新品，除非你像我一樣迫不得已才往二手市場找，找的時候也要特別注意看有沒有可能是礦卡的特徵。</p><h3 id="主機板（Motherboard）"><a href="#主機板（Motherboard）" class="headerlink" title="主機板（Motherboard）"></a>主機板（Motherboard）</h3><p>主機板就像人的骨架，他的功用就是提供地方連接所有其他零件，你可以想像他上面就是一堆插槽，專門用來接其他東西，像是記憶體、硬碟、CPU、GPU 等等。不同規格主要就是差在接口數量不同，還有可不可以超頻等等功能。</p><p>這部分其實我沒有太深入研究，所以也沒有辦法太詳細的介紹，主要大廠牌像是華碩、微星等等，而主板型號有分 Z、H、B 以及後面的數字，就我聽到的是 Z &gt; H &gt; B，而後面的第一個數字代表世代，像是我買的 B760 代表第七代這樣。另外也有不同產線的產品，像是華碩有 TUF 跟 ROG 等等系列，我最後是選比較好的 ROG 系列。</p><p>總而言之這部分還是交給店家或朋友推薦吧！但要注意店家如果推薦你超好的板子，要小心注意是不是被他話術了，說不定你根本用不到。還有一部份要注意的是，不同主機板的部分腳位不同，所以在 CPU 跟 RAM 等等的相容性上就會有差，像是 DDR4 與 DDR5 的插槽就是不同的，這部分要小心，也建議請店家幫你再三檢查。最後最後，記得檢查一下是否有提供 Wifi 跟 Bluetooth 的功能，以及有沒有買到迷你版的主板（迷你版會寫 mATX，正常版就是 ATX）！</p><h3 id="CPU-散熱器"><a href="#CPU-散熱器" class="headerlink" title="CPU 散熱器"></a>CPU 散熱器</h3><p>CPU 散熱器顧名思義，就是幫 CPU 散熱用的，基本上 i3、i5 應該是非必要，i7、i9 這種效能較好的才需要，有分空冷與水冷，水冷較貴散熱效果也較好。而選購方面我是請店家跟朋友推薦，基本上應該也都差不多，最後自己挑一款順眼的就好。這個如果要認真比的話，有些指標可以參考散熱效果，也可以去論壇看一下大家都推哪些。我記得除了我最後選的這個九州風神 AG620 之外，利民的 PA120、鐮刀的無限伍、君主的 DT24 聽說都還不錯。</p><p><img src="/img/post/2023_02/cooler.jpg" alt="CPU 風扇架在主機板上面的樣子，RAM 的燈光都被擋住了哈哈"></p><h3 id="硬碟（SSD-HDD）"><a href="#硬碟（SSD-HDD）" class="headerlink" title="硬碟（SSD &#x2F; HDD）"></a>硬碟（SSD &#x2F; HDD）</h3><p>硬碟就像圖書館一樣，存放著你電腦裡的所有資料。常見硬碟又可以分為 SSD 跟 HDD 兩種，就我理解大致可以歸納出以下性質：</p><ul><li>SSD 存取速度快、容量較小、價格較高、壞的風險較高</li><li>HDD 存取速度快、容量較大、價格較低、壞的風險較低</li></ul><p>而現在基本上必備 SSD，多作為開機碟或遊戲碟提高存取速度，不裝 HDD 也 ok，像我就是只裝兩顆 SSD，價錢上也沒有相差太多，SSD 也沒那麼容易壞。此外，現在剛好在 Gen 3 與 Gen 4 的世代交替，我個人建議直接選擇 Gen 4，兩者價格差不多，但 Gen 4 讀寫速度較快。讀寫速度越快的話，在電腦內進行 I&#x2F;O 相關操作也會越順暢，不論是讀取文件、照片、遊戲等等都有影響，所以主要就依照這個挑選，加上記得選大牌子就好，像是金士頓、威剛、美光、WD 等等都是不錯的選擇。容量因人而異，我個人選擇 1 TB + 1 TB 的組合，應該是很夠用了，若需要存大量影片等狀況再自己提高容量就好。</p><h3 id="記憶體（RAM）"><a href="#記憶體（RAM）" class="headerlink" title="記憶體（RAM）"></a>記憶體（RAM）</h3><p>很多人搞不清楚硬碟跟記憶體的差別，簡單來說硬碟是你存放各種檔案的裝置，容量越大你可以放的檔案就越多，關機後檔案都會繼續保留；而記憶體是暫時容納你程序執行的地方，容量越大你可以同時開的程序就越多，且關機後裡面就清空了，兩者對電腦來說都很重要。</p><p>現在記憶體正好也面臨 DDR 4 與 DDR 5 的世代交替，然而，這邊我會推薦選擇舊的 DDR 4，主要是因為 DDR 5 現在還是太貴，搭配的主板也是又再高一個價位，但效能卻沒有差太多，所以算下來還是用 DDR 4 比較划算，可能再過個一年左右 DDR 5 較成熟了，價格降下來才會建議選 DDR 5。</p><p>挑選的話，大廠牌如金士頓、威剛、美光等等，個人建議選雙通道 16 GB 以上，若預算 ok 就像我一樣直上 32 GB。規格部分主要有兩個數字，分別為時脈與延遲時間，時脈會長的像 3200、3600 這種數字，越大越好；而延遲時間則是像 CL16、CL18，越小越好，聽說先選時脈大的再選延遲低的，不過我不小心選反了 QQ，但聽說差異也不大就是了啦。</p><h3 id="電源供應器（Power-or-PSU）"><a href="#電源供應器（Power-or-PSU）" class="headerlink" title="電源供應器（Power or PSU）"></a>電源供應器（Power or PSU）</h3><p>電源供應器就像人的心臟，提供能量給所有電子元件，所以也是很重要的一環，聽說很多電腦用久後都是電供掛了開不了機，有些還會開到冒煙，十分危險，所以好好挑電供還蠻重要的。基本上選擇的話注意廠牌，大廠牌以海韻、全漢等為主，再注意一下有沒有十年保固，應該問題都不大；另外還有模組化程度、轉換效率以及最大瓦數等等也是需要注意的地方。特別是最大瓦數，因為現在顯卡都超吃電，所以你電供的瓦數若不足，就有可能無法正常使用硬體，可以使用這種 <a href="https://www.bequiet.com/tw/psucalculator">電源瓦數計算器</a> 來計算你需要多少瓦數的電供，通常為求安全會把算出來再往上加一個等級，來避免全力運轉下電供吃緊的問題。</p><h3 id="機殼"><a href="#機殼" class="headerlink" title="機殼"></a>機殼</h3><p>機殼就像人的皮膚或長相，其實還蠻重要的，因為他會決定你電腦的外觀好不好看，除非你對外觀不要求啦，不過現在不用花太多錢也可以買到不錯看的殼，可以自己斟酌一下。這部分我也是請店家跟朋友推薦，然後稍微看一下外觀，覺得 ok 就好，不過我買的這款是玻璃側板，在網路上有看到不少災情是玻璃因溫度變化整片碎裂，所以選購時也得自己考慮這點（希望我不會遇到…）。另外要特別注意，在挑的時候要注意空間夠不夠大，夠不夠塞下你其他的配件，有些會標註顯卡或散熱最大可以塞多長的，像是我的顯卡就很大一張，所以我有稍微注意這點（但安裝時還是塞得很緊，建議多留一點空間），建議可以給店家稍微檢查一下，他們經驗多應該比較知道哪些點要注意。</p><p><img src="/img/post/2023_02/gpu_inside.jpg" alt="顯卡太長，得麻煩店家把風扇拆開，才勉強塞的進去，我看我也拿不出來了"></p><h2 id="相關網站"><a href="#相關網站" class="headerlink" title="相關網站"></a>相關網站</h2><p>以下的網站都是我挑選時有參考的網站或論壇，特別是第一個，對新手來說很實用：</p><ul><li><a href="https://ofeyhong.pixnet.net/blog/post/224315583">歐飛先生</a></li><li><a href="https://www.coolpc.com.tw/evaluate.php">原價屋</a> 和 <a href="https://www.sinya.com.tw/diy/">欣亞</a></li><li><a href="https://www.ptt.cc/bbs/PC_Shopping/index.html">PC_Shopping PTT</a></li><li><a href="https://forum.gamer.com.tw/A.php?bsn=60030">電腦應用綜合討論版 巴哈姆特</a></li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>一不小心又廢話太多了，但配電腦的過程真的是波折連連，經歷了快一個月才結束。開始打這篇文章的時候還沒拿到我的電腦，等到拿到電腦後這篇文章應該就會發表，因為我想放幾張電腦的照片做紀錄，哈哈。這幾天都在暗自希望他趕快組好，我就可以趕快拿到趕快來玩遊戲之類的（咦不是學業用途嗎？）。總而言之，這篇大致記錄了我選購的心路歷程，希望我的經驗對各位有所幫助，下一篇文章我會分享拿到電腦後，如何幫全新的電腦灌作業系統（Windows &amp; Linux 雙系統）。</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>關於我在英國伯明罕大學交換的這半年</title>
      <link href="/2023/02/02/about-my-exchange/"/>
      <url>/2023/02/02/about-my-exchange/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/post/2023_02/airport.jpg" alt="初到伯明罕機場，永遠記得那時候的興奮！"></p><p>距離我抵達英國伯明罕剛滿一年，至今依然超級無敵懷念在歐洲生活的每一天，想說趁著還沒有完全忘記，再把一些想說的隨意記錄在這裡。其實我已經在我的 <a href="https://drive.google.com/file/d/14SxoAykrN-P9K9EWbZMy3JPj-MPAvaqB/view?usp=sharing">交換心得</a> 裡講的很詳細了，還沒看過的話可以先進去看看，但因為心得中大多走攻略取向，有點像交換懶人包的概念，所以我打算在這裡再稍微補充一些其他東西，如果想看更多圖片也可以到我的心得裡喔！</p><p>我從小出生長大都在臺北，大學也在臺北念所以都與家人同住，雖然臺灣的每個縣市都有去過，也去過中國、日本幾個地方，但從沒有獨自離家超過一週，頂多就是參加個四五天的營隊，或去南部玩個兩三天之類的。也因此這次的交換機會很難得，對我來說是全新的體驗，獨自一個人離家前往探索未知的歐洲，加上行前準備都是我自己一個人處理，可以說是既害怕又興奮。</p><p>題外話，抵達伯明罕的第一天就出了點小問題，先是不知道怎麼買公車票（最後沒買票司機就讓我搭了哈哈），抵達宿舍後又因為是假日所以沒有人在，導致當天差點沒地方住，加上已經搭了超過 24 小時的飛機超級疲倦。還好去之前就先聯繫上已經在那邊的中國室友，她很熱心的幫助我，還邀請我一起吃晚餐；以及友善的黑人警衛小哥的大力協助，才算是順利找到地方落腳，平安度過第一天。</p><p><img src="/img/post/2023_02/brum.jpg" alt="Jubilee Celebration @ Birmingham"></p><h2 id="關於心境"><a href="#關於心境" class="headerlink" title="關於心境"></a>關於心境</h2><p>我覺得，在交換之前很重要的一件事情是，先想好為什麼你想去交換。這個理由不用很高尚，只要別人問你「為什麼想去交換？」時，你可以很有自信的回答他的問題就好了，這就足以證明你不是為了去而去。對我來說，我想去交換的原因大致上有訓練英文能力、學習獨立自主與體驗西方文化。我認為交換這個體驗雖不是必要，卻是一個錯過不再的機會，等到脫離學生時代後，就會從交換的「去當地生活」變成短期的「去當地旅遊」（當然，長期的移居外國或出國工作那種除外），兩種的心境與體驗可說是完全不同，也因此能有這個機會到歐洲生活我可以說是真的超級幸運。</p><p>六個月說長不長說短不短，我好好把握了每一天，去努力練習英文口說、學習英國文化、培養獨立技能、四處旅行體驗、充實每天的生活等等。在回來臺灣之後很感傷，好希望能繼續留在歐洲生活，不過至少我覺得沒有白費這半年與這難得的機會，唯一的遺憾是還有好多好多想做的事情、想去的地方，那些就留給未來吧。</p><p>對我而言，這次的交換體驗，增進了國際觀、豐富了歷史與文化涵養、交到了世界各地的朋友……還有好多好多，都是我交換前沒有想到的，這些體悟真的只能意會，難以言傳，所以有機會有興趣的話，去交換吧！</p><p><img src="/img/post/2023_02/window.jpg" alt="房間看出去的景色，很喜歡盯著窗外發呆，希望以後的房間也要有窗戶"></p><h2 id="關於學習"><a href="#關於學習" class="headerlink" title="關於學習"></a>關於學習</h2><h3 id="學習獨立、學習一個人生活"><a href="#學習獨立、學習一個人生活" class="headerlink" title="學習獨立、學習一個人生活"></a>學習獨立、學習一個人生活</h3><p>這次交換對我很重要的一部份是，學習獨立與一個人生活。其實我自認是一個獨立的人，話雖如此，但畢竟還是沒有實際經驗，所以也不確定自己對獨立生活的接受度。在英國的這半年，我必須自己打掃、自己洗衣服、自己買菜跟煮飯，必須說我真的愛死了！如同北上念大學的南部學子，有種初次嘗到自由空氣的感覺，享受著每天打理自己生活的樂趣，以及對於自己生活完全的掌控感，大概我就是個喜愛自由的人吧！當然獨立技能也增進了不少，像是廚藝就因為每天煮飯變得比較好了，每天煮給自己跟朋友吃都煮得很開心。雖然回臺灣以後又被便宜的外食打回原形，但至少這段旅程讓我知道自己獨立生活也可以過得很好很快樂，也多體驗了一種生活型態。</p><p><img src="/img/post/2023_02/shopping.jpg" alt="定期大採購！（每次都會買太多 XD）"><br><img src="/img/post/2023_02/cook.jpg" alt="邊上網課邊煮菜的悠閒生活，真的愛到不行"></p><h3 id="學習安排與規劃行程"><a href="#學習安排與規劃行程" class="headerlink" title="學習安排與規劃行程"></a>學習安排與規劃行程</h3><p>剛到英國時，我擔心著疫情而不太敢到處亂跑，第一次搭火車去其他城市時也十分緊張。但隨著時間流逝，到交換期間的後半段我可以說是駕輕就熟，一個人就能規劃好完整的出國數天行程，甚至有時跟別人出去玩的行程也是我安排的，朋友還會說我太認真 XD。在臺灣時因為沒有經驗，以往出國時也都是跟團，所以會有點擔心自己會漏掉什麼重要的東西，但其實完全不難，網路上的資源多到不行，只要有心肯花時間下點功夫，別人都可以沒有道理你不行，多做幾次就熟悉了。</p><p>我會覺得安排行程是個很實用的技能，未來日子那麼長，如果偶爾想給自己放個小假，自己安排行程不但最有彈性，可以只去想去的地方，也不用顧及別人，可以隨時來場說走就走一個人的旅行。但在歐洲還是建議盡量結伴同行，遇到奇怪的事情時可以有人照應，像我就時不時會遇到各種詐騙或跟蹤，還好最後都全身而退，也算很幸運了。</p><p>如果你對規劃出國行程有興趣，但不確定要注意什麼的話，可以參考下圖中 <a href="https://docs.google.com/document/d/1n1U8HdAEks4StN_Mv4-9Ia-KjvNahi8qiqnR44YBMS8/edit?usp=sharing">我六月去中歐、北歐與蘇格蘭的 14 天行程</a>。</p><p><img src="/img/post/2023_02/travel_plan.png" alt="中歐 + 北歐 + 蘇格蘭 爆玩 14 天 7 城市旅遊行程！"><br><img src="/img/post/2023_02/london.jpg" alt="大笨鐘與一點點的倫敦眼"></p><h3 id="生活步調與教育文化的不同"><a href="#生活步調與教育文化的不同" class="headerlink" title="生活步調與教育文化的不同"></a>生活步調與教育文化的不同</h3><p>以學生的身分前來歐洲，除了體驗生活步調之外，教育文化的不同也是一大重點。對於學生來說，<strong>課業上的負擔基本上決定了你的生活品質</strong>（在不考慮外務的狀況下。對於這點我可以說是有深刻體悟，大一下因為不懂事修了一堆超重的課，差點沒能活過那個學期，身體狀況也奇慘無比，還好還活著還能出國交換），以臺大資管系的大學生來說，若都是紮實的課程，每學期修 18 學分就算多了，也就是說你每週大約有 18 小時的上課時間，其他時間則要拿來處理作業、複習考試等等，若要四年準時畢業基本上平均起來每學期也是差不多 15 ~ 18 學分上下。</p><p>而這邊的學分是多少呢？據我所知，這邊不論交換生與本地生都是 60 Credits，換算回臺大的學分大約就是 9 學分的量，直接砍半，每週我只要花 10 小時上課就好，甚至有些不需要去！再加上他們的作業極少，行事曆安排中正課只有 11 週，學期間有 5 週的假期，考試分散在 3 週內，我彷彿來到了天堂啊！也因為課業上的負擔相比臺灣可以說是非常輕鬆也非常簡單，所以我的生活品質非常好，每週都有很多時間可以出去玩，每天都可以悠哉地在宿舍煮飯，或是跟朋友去市中心晃。我只能說，這才是學生生活該有的樣子吧，亞洲這種競爭激烈的環境實在是太不友善，也極度的不平衡，學生的個人生活被課業與學習壓得喘不過氣，長久下來對個人發展絕非益事。</p><p>教育文化方面，大家可能已有耳聞說西方教育自由、東方教育填鴨等等，我必須說這是真實無比的情況。從大概國高中開始，我便很討厭臺灣的教育制度，學了一堆東西卻不知道要幹嘛，老師在課堂上一直講一直寫，我們在台下一直聽一直抄，放學後繼續補習到深夜回家睡覺，明天早早起床再重複一輪，只為了考試拿到好成績、考上好學校，似乎就能出人頭地。關於國高中生活也可以講很多，但這邊暫且不論，先著重在兩邊的大學比較。</p><p>以臺灣的大學來說，狀況其實跟國高中差不多，老師台上講、學生台下聽、兩次大考、數次作業，好一點的大概是時數比較少，且不用去補習班，學的內容也比較有趣，但整體上課方式依然沒有改變太多。而英國的大學除了時數更少之外，老師講課更注重於啟發學生去思考，也因此聽課像在聽教授講故事，而不是感覺教授在塞東西給你。此外，老師與學生的互動也很頻繁，學生會很主動地去思考、提問，藉此真正的「學到東西」。當然，這些是我自己觀察到的，不能一竿子打翻一條船，但這次的機會讓我對於學習有了新的體悟，相信對於研究所兩年或更遙遠的未來也會有些幫助。</p><p><img src="/img/post/2023_02/lay_on_grass.jpg" alt="新嗜好解鎖：氣溫正好，躺在草地上享受陽光 @ 伯明罕大學"></p><h2 id="關於觀察-歐洲與亞洲的不同"><a href="#關於觀察-歐洲與亞洲的不同" class="headerlink" title="關於觀察 - 歐洲與亞洲的不同"></a>關於觀察 - 歐洲與亞洲的不同</h2><h3 id="城市特色"><a href="#城市特色" class="headerlink" title="城市特色"></a>城市特色</h3><p>相比於住了二十多年的臺北，歐洲的城市風貌全然不同，不單單只是東西方文化差異這麼簡單，而是整個城市的編排都有很大的不同。歐洲歷史發展悠久，且文化保存做得很好，不論城市大小，走在路上都隨處可見歷史痕跡，充滿文化氣息，像是教堂、運河等等；反觀臺北因快速現代化，大多數的城市編排都以實用為主，因此犧牲了不少歷史與文化特色（不知道超多招牌算不算文化特色？）。</p><p>相比之下，同樣是亞洲的大都市，北京就不會給我這種感覺，整座城市依然保有一些舊時的樣貌與型態，不高的建築也讓天空比臺北更加清楚可見，多了幾分開闊感。我想可能是臺灣的發展比較晚期，加上臺灣人口又多，根本沒辦法達到北京或歐洲城市的那種樣子吧。如果能生活在一個歷史悠久的城鎮，也許我會不那麼討厭歷史這個科目，至少經過這半年我開始對它有了點興趣。</p><p>（本段是我個人見解，但我也不是什麼城市學家或對這方面多有研究，至少我的觀察與想法是這樣，也歡迎分享你的想法！）</p><p><img src="/img/post/2023_02/european_city.jpg" alt="So true lol"></p><h3 id="文化差異"><a href="#文化差異" class="headerlink" title="文化差異"></a>文化差異</h3><p>關於東西方文化差異實在有太多可以講了，關於生活、飲食、傳統、建築、語言等等，一定是講不完，所以這邊講一個點就好：人們的個性與處世態度。整體感覺下來，我覺得西方人有一些特質是我們比較沒有的，像是個人意識大於群體意識、性格樂天、特別有生活上的小幽默等等，這些在東方都比較難以看到。當然相比之下一定有好有壞，不過在這邊與當地人互動，了解他們的思考方式，也是一種很特別的體驗，可以學習到一些以前沒想過的處世哲學，未來在遇到事情時，也能多一種角度來看待。</p><p><img src="/img/post/2023_02/netherland.jpg" alt="旅途的最後一站：絕美又宜居的荷蘭"></p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>打完這篇文章後，大概是真的真的要放下交換回憶了，不能一直陷在過去的美好。時光飛逝，轉眼間距離啟程已過一年，但那些交換旅途中的體驗與回憶，至今仍歷歷在目、難以忘懷，雖然聽起來很唬爛但這是真的。也很感謝一切，感謝我能有這個寶貴的機會、感謝我在歐洲一切平安順順利利、感謝在歐洲遇到的每個人與經歷的每件事、感謝三年前有勇敢追逐英國夢的自己。如果我的經驗有什麼能幫到你的，或是你有什麼想說的，都很歡迎跟我互動，希望你也有個精彩的交換體驗！</p><p>啊但我的 <a href="https://www.instagram.com/jacksuklife/">IG 交換帳號</a> 還沒整理完所有照片，所以可能還會偶爾擾民一下就是了 XD。未來絕對還要再回去歐洲！</p><p><img src="/img/post/2023_02/me_uob.jpg" alt="Me @ University of Birmingham"></p>]]></content>
      
      
      <categories>
          
          <category> 生活隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Exchange </tag>
            
            <tag> UK </tag>
            
            <tag> Birmingham </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>112 年臺大資訊相關科系推甄（資工、資工 AI、資管、資料科學、電信丙）</title>
      <link href="/2023/01/24/get-into-graduate-school/"/>
      <url>/2023/01/24/get-into-graduate-school/</url>
      
        <content type="html"><![CDATA[<p>去年很幸運透過推甄的方式錄取了臺大資工所，本人自認為相較於網路上看到的各路大神們，我的經歷真的是一點都比不上他們，唯二能說嘴的大概只有校名跟成績，因此能直接正取真的很意外也很開心，也省去了等待備取上的焦慮以及準備考試的心力。在此也推薦成績不差的都可以推推看，有推就有機會、沒上當繳學費。</p><p>不過這段準備過程確實也花了我不少力氣，每周都得從實習 &#x2F; 上課 &#x2F; 家教的空檔中擠出一點時間修備審準備面試，甚至到後來也沒什麼在準備。總之，在這邊簡單分享給未來有類似背景或目標的人隨意參考，有任何問題都很歡迎提問。</p><h2 id="相關背景"><a href="#相關背景" class="headerlink" title="相關背景"></a>相關背景</h2><p>在推甄時本人的學業背景為：</p><ul><li>臺大會計系大五，雙主修資管系</li><li>輔修工科海工系，完成商業資料分析學程</li><li>推甄 GPA 4.07 &#x2F; 4.3（11 %，20 &#x2F; 179），兩次臺大書卷獎</li><li>至英國伯明罕大學交換半年，主修 Computer Science</li></ul><p>其他有放在備審上的經歷：</p><ul><li>在兩家新創實習過，只有一家做相關工作（ML Intern），另外參加過前端體驗營</li><li>約十多個學術專案，學士專題做商標查找與生成 App（文字 &#x2F; 影像 &#x2F; GAN）</li><li>參加數個系上或學校活動，當過隊輔、副召、組長等等</li></ul><p>對，大概就這樣，除了雙主修輔修一堆聽起來很多，跟成績還可以看之外，的確是沒什麼亮點。後來推甄完在 Dcard 上看到各路大神的分享，幾乎都有甚麼程式比賽、發 Paper、考證照檢定等等，相比之下我真的就是個普通人。另外我在今年一月畢業時放棄了原主修以及輔修，所以我最後畢業的身分只有資管系與商資學程。</p><h2 id="推甄結果"><a href="#推甄結果" class="headerlink" title="推甄結果"></a>推甄結果</h2><p>那時候想說大學都念臺大了，研究所自然目標也放在臺大，所以只推了以下五個系所：</p><ul><li>臺大資工所：正取 101 名</li><li>臺大資工所 AI 組：落榜</li><li>臺大資管所：優先錄取 13 名</li><li>臺大資料科學學程：落榜</li><li>臺大電信所丙組：備取 18 名</li></ul><p>很幸運資工、資管都有正取，最後決定去臺大資工所，算是圓了一個臺大資工的夢。<del>（超級期待進入電資學院的啦）</del></p><p>除了上述系所外，如果你跟我一樣是走資訊相關領域的話，也很推薦報名臺大的電機丙、電機資安跟網媒所，我沒報單純是想省錢加上有點過度自信 XD。題外話，傳聞說資工、資工 AI、網媒三所會一起分發來避免重榜，好像有個判準來決定你去哪裡，而若上了一所其他所的分數就會被打很低。那基本上三者師資跟課程也都幾乎一樣，但資工所在修課與師資的限制最少，因此我最為推薦。（補充：前幾天發現資工、資工 AI、網媒的正取一都是同一個人，有夠強，看來只要夠厲害照樣會讓你重榜，不過這麼強的話為何不省點錢只報一所就好）</p><h2 id="相關時程"><a href="#相關時程" class="headerlink" title="相關時程"></a>相關時程</h2><p>直接附給你了就自己看吧，連 <a href="http://exam.aca.ntu.edu.tw/graf/">網站</a> 一同附上，但可能會換就是了。</p><p><img src="/img/post/2023_01/112%E7%A2%A9%E7%8F%AD%E7%B0%A1%E7%AB%A0.png" alt="臺大112碩班甄試簡章節錄"></p><p>準備的話，我看大多數學長姊都是從暑假開始慢慢做備審，理想的話開學後備審接近完成，並開始準備相關資料與面試或筆試。不要太小看推甄，雖然不用像考試仔念一大堆科目或去報大碩，但各種資料、各校流程、面試及筆試準備還是很頭痛的。</p><p>我自己的話七月中到回臺灣，隔離完快八月才回到臺北，真正開始動備審的功大概是九月初。而且老實說我覺得我做的還蠻隨意的，只花一個月的空檔完成，十月初以後就沒什麼再修改了，所以我的經驗真的聽聽就好哈哈哈。</p><h2 id="推薦信"><a href="#推薦信" class="headerlink" title="推薦信"></a>推薦信</h2><p>推薦信的話網路上也很多討論了，像是盡量找認識的教授或是修課成績都不錯的教授等等，雖然大多系所對於推薦信的要求都可有可無，但秉持著輸人不能輸陣的精神我還是拜託了兩位教授幫我寫：一位是我的專題教授，另一位是我修過兩堂課（A、A+）且當初找專題教授時有被他接受的教授，所以應該是都對我還算有印象，事後我也有帶著小點心給他們當作回禮。</p><p>這邊要注意的就是盡量提早詢問，畢竟教授都很多事情在忙，太晚問可能他也沒空理你。我大概是九月中寄信去，並記得隨信附上備審、成績單、欲推甄系所等資料，讓教授若不記得你，至少可以透過這些東西大致了解你。在教授答應幫你寫推薦信後，最好也再附上自己先擬草稿，讓教授可以直接修改，網路上應該很多公版了，自己再調整即可。</p><h2 id="備審撰寫"><a href="#備審撰寫" class="headerlink" title="備審撰寫"></a>備審撰寫</h2><p>備審真的太普通就不放了，以下依據我的架構：個人簡歷、求學歷程、申請動機、讀書計畫，分段簡單講述：</p><h3 id="個人簡歷（2頁）"><a href="#個人簡歷（2頁）" class="headerlink" title="個人簡歷（2頁）"></a>個人簡歷（2頁）</h3><p>這部分就跟寫履歷很像，基本上就是把我上面列的相關背景整理美化一下，再丟到這塊就好。針對每個學術專案或是活動，我都用一句話簡單帶過，讓教授可以大致了解我這個東西在做什麼，另外我用粗體來加強重點，整篇都有。</p><h3 id="求學歷程（2頁）"><a href="#求學歷程（2頁）" class="headerlink" title="求學歷程（2頁）"></a>求學歷程（2頁）</h3><p>這部分主要著重在大學的求學歷程即可，不要扯太遠到國小資優班或國中優良學生之類的等等，沒人想聽。因為我的背景算是比較特殊（這個有機會再另寫一篇哈哈），我是在大一上修了商管程式設計（在此推爆這堂課）後，加上對會計的排斥，毅然決然決定轉換跑道，申請兩次雙轉資管終於錄取後，再以資管系身分畢業，所以我的求學歷程基本上都圍繞在這個故事，另外還有提到相關實習跟出國交換的經驗，同時埋了些伏筆以銜接下一大項的申請動機。</p><p>這邊我認為比較要注意的就是<strong>強調你自己與別人不同的特色，並且把你求學歷程中相關的成長與體悟盡量寫出來</strong>，這樣教授才會對你有印象，而不是看完整篇只覺得看了一個大學生的故事而不知所云，雖然也不保證教授會細看就是了。</p><h3 id="申請動機（1頁）"><a href="#申請動機（1頁）" class="headerlink" title="申請動機（1頁）"></a>申請動機（1頁）</h3><p>這部分我運用跟大學備審一樣的格式：<strong>「為何我選擇你」以及「為何你選擇我」</strong>。這部分還蠻關鍵的，說白了大多數的面試都圍繞在這兩點，為何你想來以及為何我該讓你來。</p><p>「為何我選擇你」著重在你對系所（甚至是未來找工作的公司）的了解，教授們想看到你是真的對於這個系所有充分的理解，以及你是否有強烈的動機非進不可。這邊我是著重在系所資源的描述，以及我對於研究所的想像 ，不過老實說我自己也覺得寫得不大好就是了。</p><p>「為何你選擇我」著重在你與眾不同的地方，為何教授要在眾多菁英中把一個名額給你？你有什麼特別之處是別人沒有的？把握這個原則，應該就有辦法發揮一些東西出來，這邊我著重在我資管系的背景、專案與實習以及 GPA，雖說 GPA 高的人應該不少，但要怎麼把他發揮成一個屬於你的故事，就是看你的文筆了。</p><h3 id="讀書計畫（1頁）"><a href="#讀書計畫（1頁）" class="headerlink" title="讀書計畫（1頁）"></a>讀書計畫（1頁）</h3><p>這部分我也是運用跟大學備審一樣的格式（我就懶 XD）：<strong>短、中、長期目標</strong>。主要是因為這樣分比較有架構，而且每階段你的人生計劃本來也就會不同。這邊我會覺得撰寫原則就是畫大餅，你不用真的未來都做到，你只要都規劃出來就好，教授想看的應該只是你是否對於研究所有個大致明確的目標與方向。但也要記得大餅不要畫太大，畫太大就沒人相信了，高雄發大財你相信嗎？我個人劃分短期為推甄完到入學前，中期為研究所期間，長期則為研究所畢業後，大致將我想在各階段做的事情簡單敘述。</p><p>其實寫備審大概就一個重點：隱惡揚善，並運用你的三寸不爛之舌，盡量將你的經驗講成教授想聽的樣子，但也不要太過火，講得太誇張教授也會不買單。</p><h2 id="面試準備"><a href="#面試準備" class="headerlink" title="面試準備"></a>面試準備</h2><p>我推甄的五個系所中，只有三個需要面試，資工所與資工所 AI 組則是純書審。照時程上來說，完成備審後就該準備面試了，且因為要複習基礎科目（看系所不一定）會需要花一段時間。我則是因為沒什麼時間，所以每周都只能零碎的念一些書，雖然排了讀書計畫但最後也幾乎沒有實行，不過因為意外的少掉兩次面試（資管所優先錄取不用面試，資料科學學程落榜沒的面試），所以影響倒是不大。</p><p>這邊稍微簡單分享各系所面試流程，因為我也只面一個就不詳細說了，網路上應該也很多經驗分享，也很推薦去問學長姐，或是靠人脈想辦法要到那種每年往下傳的口試心得。資管往年大多都是分四關（資訊應用、資訊技術、數學、生涯），我有拿到系上口試心得分享；資料科學學程是要準備簡報，四分鐘講完就好不限內容，有兩分鐘問答；電信丙近兩年都改成僅一關五分鐘，內容就看教授們想問啥就問啥，非官方消息聽說有專題或 paper 就問專題或 paper，沒有就問技術問題，我自己是都在聊專題跟實習經驗居多，這也是我唯一面的系所。</p><h2 id="指導教授"><a href="#指導教授" class="headerlink" title="指導教授"></a>指導教授</h2><p>這部分也是一門大大大學問啊！好的指導教授帶你上天堂，壞的就……帶你上頂樓（沒有啦開玩笑）。這部分我就不花篇幅多說，我主要參考 <a href="https://www.dcard.tw/f/graduate_school/p/237992393">這篇</a>，挑了一些自己注重的問題去問教授跟學長姐。記得一定要去 Lab 敲門看看生態與風氣，只要有禮貌，學長姐大多人都很好，不好的你也可以不用來了。有時候只跟教授聊天是不準的，直接問學長姐可以對教授的帶人方式更加了解，對於你做選擇絕對很有幫助，然後貨比三家不吃虧呀！</p><p>備註：理工科教授搶得很快，熱門教授放榜幾天後就滿了，建議提前做好功課。我放榜前一周開始問，問了十幾個教授加實驗室，大概在放榜隔周確定上岸。然後電信丙基本上好教授都被逕取生搶光了，面試後錄取的基本上只能挑剩的，大家自行衡量。</p><p><img src="/img/post/2023_01/prof_meme.jpg" alt="大家不要想不開，人生不是只有研究所而已"></p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>花一天速速完成這篇文章，寫的時候常常懶得打，就跳過了一些不大重要或網路上已經有的細節，不過希望我這篇大概都有涵蓋到整個推甄的重要事項，如果對哪部分有興趣可以另外再問我。總而言之，能靠推甄就錄取臺大資工所真的是很幸運，也很感謝大學的自己有好好念書顧成績。很期待兩年的研究生活，未來再來跟大家分享更多！</p>]]></content>
      
      
      <categories>
          
          <category> 生活隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTU </tag>
            
            <tag> Master </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Hexo + Github pages 建立個人網站</title>
      <link href="/2023/01/19/build-my-blog/"/>
      <url>/2023/01/19/build-my-blog/</url>
      
        <content type="html"><![CDATA[<p>嗨！在經過一個假日的摸索之後，這個網站算是有點樣子了。很早以前就有建立個人網站的想法，但一直很忙（懶）所以沒有做，這次趁著進入研究所前的空檔，打算好好經營個人網站並且做一些有興趣的事，同時希望以後可以持續更新技術相關的學習筆記在這裡。</p><p>作為第一篇文章，先來分享一下如何使用 Hexo + Github pages 建立個人網站，並修改一些基礎的 Configuration。本網站的文章都會預設讀者有一定的技術了解，因此不會寫的完完全全白話，若有疑問歡迎下方留言，或是自己搜尋相關介紹。（又或是問強大的 ChatGPT，我都用他來 Debug 🤣）</p><h2 id="靜態網站產生器"><a href="#靜態網站產生器" class="headerlink" title="靜態網站產生器"></a>靜態網站產生器</h2><p>靜態網站產生器是快速架網站的實用工具，他提供了便於使用的框架以及多種不同的主題，讓一般使用者也能夠快速方便的建置自己的網站。常見的框架有 Jekyll、Hexo、Hugo，詳細的比較有興趣可以參考 <a href="https://raychiutw.github.io/2019/Static-Site-Generator-Comparison/">這裡</a>，本篇會介紹 Hexo 框架的使用流程。</p><h2 id="下載-Hexo-並建置第一個網站"><a href="#下載-Hexo-並建置第一個網站" class="headerlink" title="下載 Hexo 並建置第一個網站"></a>下載 <a href="https://hexo.io/zh-tw/">Hexo</a> 並建置第一個網站</h2><ul><li>下載 <a href="https://nodejs.org/en/">Node.js</a>，完成以後用 <code>node -v</code> 檢查是否安裝成功</li><li>執行 <code>npm install hexo-cli -g</code> ，使用 npm 來安裝 Hexo</li><li>完成後先切換到你想存放檔案的路徑，執行 <code>hexo init [repo_name]</code></li><li>使用 <code>cd [repo_name]</code> 進入該資料夾，執行 <code>npm install</code> 安裝所需套件</li><li>完成後執行 <code>hexo server</code>，點擊 Terminal 中出現的網址 <a href="http://localhost:4000/[repo_name]/">http://localhost:4000/[repo_name]/</a> ，大功告成！</li></ul><p>如上，是不是很簡單！接著我們來看看要怎麼配置主題。</p><h2 id="配置-Butterfly-主題"><a href="#配置-Butterfly-主題" class="headerlink" title="配置 Butterfly 主題"></a>配置 <a href="https://github.com/jerryc127/hexo-theme-butterfly/">Butterfly 主題</a></h2><p>完成上述安裝後，進入瀏覽器看到的會是預設的 Landscape 主題，但如果只用預設主題就太沒意思了，因此接著我們要來配置 Butterfly 主題，可以在 <a href="https://butterfly.js.org/">這裡</a> 觀看該主題的 Demo。除此之外，Hexo 也有 <a href="https://hexo.io/themes/">眾多主題</a> 可以挑選，大家可以自行比較挑選。在剛剛的路徑下執行：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-theme-butterfly</span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>安裝完成後，將目錄底下的 <code>_config.yml</code> 打開，修改以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><p>最後執行 <code>hexo server</code>，就可以看到修改主題過後的結果了。</p><h2 id="使用-Github-Pages-來部署網站"><a href="#使用-Github-Pages-來部署網站" class="headerlink" title="使用 Github Pages 來部署網站"></a>使用 Github Pages 來部署網站</h2><p>有了主題之後，接著就是設定部署方式。這邊使用 Github Pages 來幫助我們部署網站，Github Pages 提供穩定的服務以及客製化的網域名，若不想花錢花時間搞自己的伺服器跟網域，可以說是相當不錯的選擇。</p><p>首先我們要先具備 Github 帳號以及 Github Desktop，如何申請及下載不在此贅述。打開 Github Desktop 後，找到剛才的路徑的上一層，並以 <code>[repo_name]</code> 來創建新的 Repository，這邊記得要選 Public Repository，才能使用 Github Pages 的相關功能，然後再將前面下載的檔案都 Push 上 Github。</p><p>將目錄底下的 <code>_config.yml</code> 打開，修改以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://[user_name].github.io/[repo_name]</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/Website/</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/[user_name]/[repo_name]</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">github-pages</span></span><br></pre></td></tr></table></figure><p>後半部的 Deploy 設置部分，是為了讓我們日後可以快速部署所需的設定，另外還要下載 <code>hexo-deployer-git</code>，就能使用 <code>hexo deploy</code> 完成快速部署：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>當我們輸入 <code>hexo generate</code> 後，Hexo 會幫我們產生靜態檔案，也就是常聽到的 HTML、CSS、JS等等，再使用 <code>hexo deploy</code> 推上 Github Repository 裡 github-pages 這個分支。我們的 Repository 上共會有兩個分支，main 存放主要程式碼及配置檔案，github-pages 則存放部署相關檔案。</p><p>接著我們需要再到 Github 網站上，設定使用 github-pages 這個分支來進行部署，可以在 <code>Repository -&gt; Settings -&gt; Pages</code> 裡找到相關的設置。設置完成後稍等幾分鐘，就可以到 <a href="https://github.com/[user_name]/[repo_name]">https://github.com/[user_name]/[repo_name]</a> 來觀看成果了。</p><h2 id="Hexo-常用指令"><a href="#Hexo-常用指令" class="headerlink" title="Hexo 常用指令"></a>Hexo 常用指令</h2><p>更詳細的說明可以到 <a href="https://hexo.io/zh-tw/docs/">官方文件</a> 尋找，這邊列出幾個常用指令：</p><ul><li><code>hexo generate</code>：產生靜態檔案到 <code>/public</code> 資料夾中</li><li><code>hexo clean</code>：清除 <code>/public</code> 資料夾</li><li><code>hexo deploy</code>：將 <code>/public</code> 資料夾中檔案推上 Github</li><li><code>hexo server</code>：在本地端執行 Server，可預覽網站呈現效果，同時監聽本地文件的修改</li><li><code>hexo server --draft</code>：可同時預覽草稿在網站上的呈現效果</li><li><code>hexo new [layout] [title]</code>：新增以 <code>layout</code> 為樣式的文件</li><li><code>hexo publish [layout] [title]</code>：將草稿以 <code>layout</code> 為樣式發布出去</li></ul><p>不過有時候 <code>hexo server</code> 會怪怪的，突然無法監聽本地文件的修改，不太清楚原因。正常來說，除了修改 <code>_config.yml</code> 檔需要重啟 Server 外， Markdown 檔的修改應該都能直接即時更新，有人知道的話歡迎跟我分享。</p><h2 id="如何設定-Configuration"><a href="#如何設定-Configuration" class="headerlink" title="如何設定 Configuration"></a>如何設定 Configuration</h2><p>Butterfly 主題提供了很大的彈性，讓我們可以自訂各種設置。詳細的設定可以直接到 <a href="https://butterfly.js.org/categories/Docs%E6%96%87%E6%AA%94/">Butterfly 官方說明</a> 這裡參考，裡面解釋得很詳細，也有圖片展示不同的效果。可以先到 <a href="https://github.com/jerryc127/hexo-theme-butterfly/blob/dev/_config.yml">Github 上的 _config.yml</a> 複製一份，另外存放在 <code>_config.butterfly.yml</code> 中，在以這個為基礎進行修改。注意不要刪除原本就有的 <code>_config.yml</code>，一個是配置 Butterfly 主題，另一個則是配置 Hexo。</p><h2 id="如何新增內容"><a href="#如何新增內容" class="headerlink" title="如何新增內容"></a>如何新增內容</h2><p>Hexo 框架中，頁面都是使用 Markdown 語法撰寫，若不熟悉的話可能要先去研究一下。Markdown 是一種簡單的標記語言，多用來排版與美化版面，像是 # 代表標題等等。透過上面的 <code>hexo new [layout] [title]</code> 指令，Hexo 會先去 <code>\scaffolds</code> 底下尋找名為 <code>[layout].md</code> 的檔案，並以其樣式為基礎，在 <code>\source</code> 或 <code>\source\_post</code> 底下新增名為 <code>[title].md</code> 的檔案，而我們直接編輯這個檔案即可。</p><p>使用 Markdown 的好處除了排版方便之外，之後若要更換框架，或是移動文章， Markdown 的相容性都很高，可以減少移動所需的成本。另外，若需要放其他類型的檔案，像是圖片檔等等，也可以自己在 <code>\source</code> 底下新增資料夾，執行 <code>hexo generate</code> 的時候 Hexo 會幫你一起搬過去。</p><h3 id="Page、Draft、Post"><a href="#Page、Draft、Post" class="headerlink" title="Page、Draft、Post?"></a>Page、Draft、Post?</h3><p><code>\scaffolds</code> 底下預設有三個檔案，分別為 Page、Draft、Post，分別對應到頁面、草稿、跟文章的模板。簡單來說，你需要使用與頁面放一些相關訊息時用 Page，想寫草稿時用 Draft，想直接寫文章就用 Post；而三者分別會存放於 <code>\source</code>、<code>\source\_drafts</code>、<code>\source\_posts</code>，而草稿不會展示在網站上。當然，你也可以自己新增自己所需的模板，再使用 <code>hexo new [layout] [title]</code> 時就能有更多彈性的選擇，也不用每次都重新修改頁面前面的設置。（可以參考 <a href="https://butterfly.js.org/posts/dc584b87/">這裡</a> 了解更多關於前置設置的細節）</p><h3 id="Tags、Categories、Link"><a href="#Tags、Categories、Link" class="headerlink" title="Tags、Categories、Link?"></a>Tags、Categories、Link?</h3><p>這三個算是比較特別的頁面，分別存放所有的標籤、分類以及自定義的外部連結。標籤跟分類可以幫助你網站的使用者快速找到相關文章，日後要回顧時也比較方便。外部連結則視個人需求，想放什麼連結都可以。設定這三個頁面的方式是在頁面的前置設置加上 type：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">tags/catrgories/link</span> <span class="comment">#三選一即可</span></span><br></pre></td></tr></table></figure><p>前兩者基本上 Butterfly 會幫你配置好，沒有需要可以不用修改， Link 頁面就需要自己新增，看是要加在 <code>\source\link\index.md</code> 底下，或是依照官方說明加在 <code>\source\_data\link.yml</code> 都可以。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這篇文章斷斷續續寫了五天，總算是把他完成了，赫然發現寫技術文章並沒有想像中的輕鬆。在本文內我盡量涵蓋到所有內容，同時以精簡的方式，整理架設個人網站所需要的所有指令與知識，若寫得不好還請多多包涵，也歡迎給予我一些回饋。</p><p>我認為對於資訊相關科系的學生來說，有一個自己的網站還是蠻不錯的，一來可以練習架設網站所需的技術，對於一些框架、服務能更加瞭解；二來可以分享在學期間的學習筆記，像是論文解讀、指令整理等等，分享之餘自己也能受惠；再來就是自己架網站彈性較大，也不用受限於其他網站的各種限制，更能自己擴充其他功能。希望在未來繁忙的研究所或工作生活中，還有時間回來這邊分享一些東西。</p><p>本文到此結束，感謝觀看的每一個你！</p>]]></content>
      
      
      <categories>
          
          <category> 學習筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找回自己 - 戒除社交軟體後</title>
      <link href="/2020/02/21/social_media/"/>
      <url>/2020/02/21/social_media/</url>
      
        <content type="html"><![CDATA[<p>2025 更新：<br>這篇文章是我 2020 在 <a href="https://medium.com/@JackChen89">Medium</a> 寫的，不過現在已經被我隱藏所以看不到了。當初嘗試了一個月不使用社交軟體，因此想順便記錄一下自己的想法與心路歷程（但覺得自己文筆太爛，加上沒人看，所以後來就隱藏了）。但我這幾天看到<a href="https://www.youtube.com/watch?v=6Y8Wmroaq-I">賀瓏夜夜秀在介紹演算法</a>，以及其在社群媒體中扮演的角色，就讓我想到這篇文章。剛好最近又在整理 Blog，因此就把它搬回來，作為紀念以及提醒。</p><p>雖說現在我依然會使用社交媒體，但我覺得我的焦慮感以及依賴感已經相較之前好很多。有一點還可以改善的，是對於Facebook的依賴，因為目前研究還蠻需要接觸一些AI界的消息，而我最主要的方法還是透過Facebook，因此就會仍然被上面的內容給佔用不少時間，如果有專門討論學術的平台就好了……。</p><hr><p>這個月初，我做了一個決定 - 我決定登出Instagram跟Facebook。</p><p>相信有些人曾經考慮過這個念頭，而每個人都會有不同的動機。對我來說，Instagram跟Facebook雖然讓社交、獲取資訊、分享心情等等變得非常簡單，卻也簡單到容易上癮，無意識地就會把Instagram打開來滑個兩下，不論在念書、等待、或是有任何小空檔時。</p><p>這項習慣不僅時常打亂我正在做的事情，造成我難以專注，也常常讓我忽略我身旁的環境與人們。而且，Instagram上的東西真的那麼重要嗎？大家極力把自己生活最好的一面呈現在你眼前，不僅絕大多數與你不相關，也時常激起比較的心態。活在Instagram裡就等於你活在別人的世界裡，而錯過了自己世界裡的種種美好。</p><h1 id="我真的需要戒掉社交軟體嗎？"><a href="#我真的需要戒掉社交軟體嗎？" class="headerlink" title="我真的需要戒掉社交軟體嗎？"></a>我真的需要戒掉社交軟體嗎？</h1><p>以下我會簡單講述我認為Instagram、Facebook這類平台的好處與壞處，以及為什麼你根本不需要社交軟體。</p><ol><li>通知讓你難以專心<br>時常跳出的通知總是讓我在手邊的工作做到一半時，拿起手機查看發生了什麼新鮮事。當我意識到我開始分心時，通常已經是十幾二十分鐘後的事了。有許多研究顯示，持續的分心會造成專注力永久的損害-你會再也無法好好完成一件事。</li><li>關心別人更甚你自己<br>別人的生活真的值得花這麼多時間關心嗎？當關注別人佔用了大多數的時間，給自己的時間便少的可憐，這也是為什麼我們明明想做很多事、想好好打理生活，卻總是覺得沒時間的原因。</li><li>比較心態與負面情緒<br>當大家把自己最好的一面呈現在Instagram上，便會讓我覺得為什麼他們都過得這麼精彩、為什麼他們都這麼快樂？陷入了與他人比較的漩渦之內後，接著而來的往往是自己不如他人的負面情緒。（特別是你只看到了每個人快樂的一面，卻忽略他們其實也有低潮的時候）</li><li>無用的內容充斥版面<br>這點主要是針對Facebook公司政策的小抱怨。Facebook主頁常充斥著廣告、假新聞、或是一些標題吸引人，內容空洞的文章，十分浪費時間。Instagram其實也是，記得之前聽過平均看三個人的限動，就會跳一則廣告的說法。</li></ol><h1 id="一無是處的社交軟體？"><a href="#一無是處的社交軟體？" class="headerlink" title="一無是處的社交軟體？"></a>一無是處的社交軟體？</h1><p>當然，社交軟體會盛行不是沒有原因的，他們能夠帶給我們不少好處。</p><ol><li>最便利的娛樂<br>當我無聊時，拿出手機滑個一兩下，便能帶來新鮮感以及愉悅。</li><li>獲取資訊的來源<br>這點是我覺得最有幫助的一點。不論是新聞、活動、或是各種資訊，總是會有人想與大家分享。透過社交軟體我們能更快速、及時得到這些消息。</li><li>容易進入別人的生活<br>不必多說，看別人發布的貼文或動態便能夠知道他們生活中發生了什麼事，往往也是個很棒的聊天話題。</li><li>分享心情<br>人們都渴望被聽見。當你需要一個管道分享、發洩、紓壓等等，社交軟體是個不錯的管道。（老實說，以前的我就是這樣，心情不好時就會上社交軟體宣洩）</li></ol><p>但說句老實話，其實這些所謂的「好處」，不需要社交軟體也能夠達到。世界上有無盡種娛樂方式、獲取資訊的方法也有很多，若你想要了解別人、或是渴望被了解，直接跟他聊天豈不是更快？再退一步的話，Line這類通訊軟體也能幫助你達成目標。（雖然說戒除社交軟體，但我覺得Line不算在內 - 畢竟我不會對Line上癮，對我來說只是個讓聊天更方便的工具）</p><p>在這種社交軟體還沒問世之前，人們依然過日子，依然有娛樂、能夠獲取資訊、與別人社交。社交軟體的確為我們帶來了方便，但就是因為太方便了，我們不加思索便把手機拿出來滑，無形間也帶給我們上述的壞處。</p><p>總結以上，社交軟體絕對不是必需的，而是由你選擇的。如果你不會覺得生活被Instagram或Facebook綁架，那很好；但如果你覺得我說得有道理，或是感覺自己的生活正在被掌控，那不妨跟上我的腳步。</p><p>A TED talk might help you : Why you should quit social media</p><iframe width="800" height="450" src="https://www.youtube.com/embed/3E7hkPZ-HTk?si=dMNFuKxfCiDHfSNG" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe><h1 id="過得更好"><a href="#過得更好" class="headerlink" title="過得更好"></a>過得更好</h1><p>最後與大家分享，在我戒除社交軟體之後，生活上的轉變。</p><p>在我登出Instagram跟Facebook前，我把所有的訊息跟動態都回完、看完，還未發的文也發完，然後才登出。總覺得有種完成一個儀式的感覺，也能更下定決心的改變。</p><p>按下登出的那刻，我有種放鬆感。感覺就像放下了肩膀上的重擔，從現在開始，裡面發生什麼事情、誰又去了哪裡玩，都與我無關了。真正重要的只有我，和我周遭發生的事。</p><p>接下來幾天，我注意到的感覺是無聊。時間過得很慢，彷彿一天被拉長成兩天，突然有了大量時間。我意識到我必須找點事情做，於是我開始讀放了很久的書、開始建立健身課表、開始放慢走路的速度觀察人們、開始學習煮菜、開始寫這篇（第一篇）文章。</p><p>登出社交軟體並沒有讓我與世界完全斷開連結。我還是偶爾會找朋友吃飯聊天、討論出遊、或是線上通話等等。雖然還是會覺得自己有點脫離世界，但也正是因為這樣，我才會有許多自己的時間，可以拿來做自己想做的事。</p><p>除此之外，我還注意到了幾種感覺。當我在做任何事的時候，比以前更能夠專心的完成（那份研究可不是說說的），當然偶爾還是會有拿起手機的衝動，但一想到自己已經下定決心，便會放下手機。還有一種更踏實、更能夠感受世界的感覺，有點難以形容，但總之就是覺得煥然一新。</p><p>過去，社交軟體提供的新鮮感和渴望被人們聽到的心情綁架了我，我不斷發文、看限動，透過這些舉動來感受自己與大家的連結。而這些需求逐漸增強，最後的結果就是上癮，頻繁打開Instagram成為我的惡習。透過登出社交軟體，我找回了自己，學會花更多時間與自己相處，逐步找回對自己生活的主導權。</p>]]></content>
      
      
      <categories>
          
          <category> 生活隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Life </tag>
            
            <tag> Social Media </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
