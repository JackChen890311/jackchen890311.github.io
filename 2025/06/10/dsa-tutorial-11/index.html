<!DOCTYPE html><html lang="zh-TW" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題 | Jack's Space</title><meta name="author" content="Jack Chen"><meta name="copyright" content="Jack Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="HackMD 完整版請點我 最大子數列問題 (Maximum Subarray Problem)最大子陣列問題是指在一個整數數列中，找出一段連續子陣列，使其元素總和最大。這是經典的動態規劃問題之一，常用於資料分析，如股價變動趨勢。   例子：給定一個陣列 [-2, -3, 4, -1, -2, 1, 5, -3]，找出總和最大的子陣列。 解答：最大子陣列為 [4, -1, -2, 1, 5]，其總">
<meta property="og:type" content="article">
<meta property="og:title" content="資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題">
<meta property="og:url" content="https://jackchen890311.github.io/2025/06/10/dsa-tutorial-11/index.html">
<meta property="og:site_name" content="Jack&#39;s Space">
<meta property="og:description" content="HackMD 完整版請點我 最大子數列問題 (Maximum Subarray Problem)最大子陣列問題是指在一個整數數列中，找出一段連續子陣列，使其元素總和最大。這是經典的動態規劃問題之一，常用於資料分析，如股價變動趨勢。   例子：給定一個陣列 [-2, -3, 4, -1, -2, 1, 5, -3]，找出總和最大的子陣列。 解答：最大子陣列為 [4, -1, -2, 1, 5]，其總">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://jackchen890311.github.io/img/cover/color_macbook.jpg">
<meta property="article:published_time" content="2025-06-10T07:57:11.000Z">
<meta property="article:modified_time" content="2025-07-12T15:47:21.357Z">
<meta property="article:author" content="Jack Chen">
<meta property="article:tag" content="Tutorial">
<meta property="article:tag" content="Data Structure">
<meta property="article:tag" content="Algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jackchen890311.github.io/img/cover/color_macbook.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題",
  "url": "https://jackchen890311.github.io/2025/06/10/dsa-tutorial-11/",
  "image": "https://jackchen890311.github.io/img/cover/color_macbook.jpg",
  "datePublished": "2025-06-10T07:57:11.000Z",
  "dateModified": "2025-07-12T15:47:21.357Z",
  "author": [
    {
      "@type": "Person",
      "name": "Jack Chen",
      "url": "https://jackchen890311.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon_J.ico"><link rel="canonical" href="https://jackchen890311.github.io/2025/06/10/dsa-tutorial-11/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-V3TXPM1E19"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-V3TXPM1E19')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-V3TXPM1E19', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '複製成功',
    error: '複製失敗',
    noSupport: '瀏覽器不支援'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '剛剛',
    min: '分鐘前',
    hour: '小時前',
    day: '天前',
    month: '個月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Jack Chen","link":"連結: ","source":"來源: Jack's Space","info":"著作權歸作者所有。如需商業轉載，請聯絡作者獲得授權，非商業轉載請註明出處。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '載入更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">載入中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/me/ghent.jpg" onerror="this.onerror=null;this.src='/img/website/emoji.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="/ramen/"><i class="fa-fw fas fa-utensils"></i><span> 拉麵</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/cover/color_macbook.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Jack's Space</span></a><a class="nav-page-title" href="/"><span class="site-name">資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首頁</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page" href="/ramen/"><i class="fa-fw fas fa-utensils"></i><span> 拉麵</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 關於</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">發表於</span><time class="post-meta-date-created" datetime="2025-06-10T07:57:11.000Z" title="發表於 2025-06-10 15:57:11">2025-06-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新於</span><time class="post-meta-date-updated" datetime="2025-07-12T15:47:21.357Z" title="更新於 2025-07-12 23:47:21">2025-07-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DSA-%E6%95%99%E5%AD%B8/">DSA 教學</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">總字數:</span><span class="word-count">1.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">閱讀時間:</span><span>7分鐘</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">瀏覽量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://hackmd.io/KM8DV4vRSzSnm9z3HZCC5Q">HackMD 完整版請點我</a></p>
<h2 id="最大子數列問題-Maximum-Subarray-Problem"><a href="#最大子數列問題-Maximum-Subarray-Problem" class="headerlink" title="最大子數列問題 (Maximum Subarray Problem)"></a>最大子數列問題 (Maximum Subarray Problem)</h2><p>最大子陣列問題是指在一個整數數列中，找出一段連續子陣列，使其元素總和最大。這是經典的動態規劃問題之一，常用於資料分析，如股價變動趨勢。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hackmd.io/_uploads/BJFh7JLZxx.png" alt="image"></p>
<ul>
<li>例子：給定一個陣列 [-2, -3, 4, -1, -2, 1, 5, -3]，找出總和最大的子陣列。</li>
<li>解答：最大子陣列為 [4, -1, -2, 1, 5]，其總和為 7。</li>
</ul>
<h3 id="Kadane’s-Algorithm"><a href="#Kadane’s-Algorithm" class="headerlink" title="Kadane’s Algorithm"></a>Kadane’s Algorithm</h3><p>Kadane’s Algorithm 是一種專門用來解決此問題的演算法，可在線性時間內計算完成。要了解 Kadane’s Algorithm，讓我們從暴力法一步一步來看。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85188269">滴滴面试手撕算法题-kadane算法</a></li>
</ul>
<h4 id="暴力法：遍歷全部連續子陣列"><a href="#暴力法：遍歷全部連續子陣列" class="headerlink" title="暴力法：遍歷全部連續子陣列"></a>暴力法：遍歷全部連續子陣列</h4><p>最簡單的方式，就是窮舉所有可能的連續子陣列，並計算每一個子陣列的總和，再從中找出最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArrayBF</span>(<span class="params">nums</span>):</span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            total = <span class="built_in">sum</span>(nums[i:j])</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, total)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>

<ul>
<li>時間複雜度：$O(n^3)$</li>
<li>空間複雜度：$O(1)$</li>
</ul>
<p>就算我們用小技巧 curr_sum，來優化 sum() 的計算，時間複雜度依舊很高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArrayBF2</span>(<span class="params">nums</span>):</span><br><span class="line">    max_sum = nums[<span class="number">0</span>]</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        curr_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            curr_sum += nums[j]</span><br><span class="line">            max_sum = <span class="built_in">max</span>(max_sum, curr_sum)</span><br><span class="line">    <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>

<ul>
<li>時間複雜度：$O(n^2)$</li>
<li>空間複雜度：$O(1)$</li>
</ul>
<h4 id="優化時間：動態規劃"><a href="#優化時間：動態規劃" class="headerlink" title="優化時間：動態規劃"></a>優化時間：動態規劃</h4><p>如果我們知道「以某個位置結尾的最大子陣列和」，那我們就可以用它來推導下一個位置的最大值 -&gt; 動態規劃！</p>
<ul>
<li>dp[i]: 表示 以 index i 結尾 的最大連續子陣列和。</li>
<li>dp[i] &#x3D; max(dp[i-1], 0)+ nums[i]<ul>
<li>延續之前的子陣列（dp[i-1] + nums[i]） or 重新開始（nums[i]）</li>
<li>若前面總和小於 0，則完全不取前面，重新計算</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArrayDP</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [<span class="number">0</span>] * n</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>], <span class="number">0</span>) + nums[i]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>

<ul>
<li>時間複雜度：$O(n)$</li>
<li>空間複雜度：$O(n)$</li>
</ul>
<h4 id="優化空間：Kadane’s-Algorithm"><a href="#優化空間：Kadane’s-Algorithm" class="headerlink" title="優化空間：Kadane’s Algorithm"></a>優化空間：Kadane’s Algorithm</h4><p>如果我們仔細觀察動態規劃的解法，會發現其實根本不需要整個 dp 陣列，因為我們只關心上一個 dp[i-1] 和目前的值。因此，Kadane’s Algorithm 利用以下兩個變數，來更進一步優化 dp 解法的空間複雜度：</p>
<ul>
<li>local_max：目前位置為結尾的最大子陣列和</li>
<li>global_max：迄今為止出現過的最大子陣列和</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArrayKadane</span>(<span class="params">nums</span>):</span><br><span class="line">    local_max = global_max = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        local_max = <span class="built_in">max</span>(local_max, <span class="number">0</span>) + nums[i]</span><br><span class="line">        global_max = <span class="built_in">max</span>(global_max, local_max)</span><br><span class="line">    <span class="keyword">return</span> global_max</span><br></pre></td></tr></table></figure>

<ul>
<li>時間複雜度：$O(n)$</li>
<li>空間複雜度：$O(1)$</li>
</ul>
<p>至此，最大子數列問題已經被我們用僅僅 6 行的程式碼，加上 $O(n)$ 的時間與 $O(1)$ 的空間解決了。Kadane’s Algorithm 是不是很精美呢？</p>
<h3 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/description/">53. Maximum Subarray</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-sum-circular-subarray">918. Maximum Sum Circular Subarray</a></li>
</ul>
<h2 id="背包問題（Knapsack-Problem）"><a href="#背包問題（Knapsack-Problem）" class="headerlink" title="背包問題（Knapsack Problem）"></a>背包問題（Knapsack Problem）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hackmd.io/_uploads/SJHGJ6jgyx.png" alt="image"></p>
<p>背包問題（Knapsack Problem）是最佳化中的經典問題之一。<br>該問題的基本形式是：</p>
<ul>
<li>給定一個背包，其容量為固定的正整數（C）</li>
<li>給定 N 種物品，每個物品都有自己的重量（w）與價值（v）</li>
<li>目標是在不超過背包容量的前提下，選擇若干物品，使得它們的總價值最大</li>
</ul>
<p>這個問題常用來模擬像是資源分配、投資選擇、或是行程安排等情境，也是一個常出現在演算法課程和競賽中的經典題型。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://web.ntnu.edu.tw/~algo/KnapsackProblem.html">Knapsack Problem - 演算法筆記</a></li>
<li><a target="_blank" rel="noopener" href="https://www.csie.ntu.edu.tw/~yvchen/f107-ada/doc/181011_DynamicProgramming2.pdf">ADA Handout (DP), Vivian Chen, NTU CSIE</a></li>
</ul>
<p>根據限制的種類，背包問題又可以分為以下幾種：</p>
<h3 id="分數背包問題（Fractional-Knapsack-Problem）"><a href="#分數背包問題（Fractional-Knapsack-Problem）" class="headerlink" title="分數背包問題（Fractional Knapsack Problem）"></a>分數背包問題（Fractional Knapsack Problem）</h3><ul>
<li>每樣物品可以被切割（可放部分物品）</li>
<li>解法：用貪婪演算法，依據「單位價值」高到低排序放入背包</li>
</ul>
<p>這個問題的解法很直覺，直接依據「單位價值」（v &#x2F; w，也就是我們常說的 CP 值）的高低放入背包，直到背包裝滿為止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fractional_knapsack</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    items = <span class="built_in">sorted</span>(<span class="built_in">zip</span>(weights, values), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]/x[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    total_value = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> w, v <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> capacity &gt;= w:</span><br><span class="line">            total_value += v</span><br><span class="line">            capacity -= w</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            total_value += v * (capacity / w)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> total_value</span><br></pre></td></tr></table></figure>

<h3 id="0-1-背包問題（0-1-Knapsack-Problem）"><a href="#0-1-背包問題（0-1-Knapsack-Problem）" class="headerlink" title="0&#x2F;1 背包問題（0&#x2F;1 Knapsack Problem）"></a>0&#x2F;1 背包問題（0&#x2F;1 Knapsack Problem）</h3><ul>
<li>每樣物品只能選一次（不可切割），也是最經典的背包問題</li>
<li>解法：用動態規劃，考慮每一項物品「選」或「不選」</li>
</ul>
<p>0&#x2F;1 背包問題是最常見也最經典的背包問題，基本的解法是用 n x C 的 2D DP 矩陣，來代表在不同情況下，背包能達到的最大 total value，計算完後 dp[n][C] 即為解答。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hackmd.io/_uploads/By0VJYKGgg.png" alt="image"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_2d</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    dp = [[<span class="number">0</span>] * (capacity + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(capacity + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> weights[i - <span class="number">1</span>] &lt;= w:</span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][w], dp[i - <span class="number">1</span>][w - weights[i - <span class="number">1</span>]] + values[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i][w] = dp[i - <span class="number">1</span>][w]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n][capacity]</span><br></pre></td></tr></table></figure>

<p>我們也可以再更優化成 1D DP 來節省空間，並同時維持方法的正確性。要注意的是，若僅用一個 DP Array，則在內層迴圈要以倒序方式，才不會讓在該輪更新的值影響到計算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_1d</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    dp = [<span class="number">0</span>] * (capacity + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(capacity, weights[i] - <span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 倒序，避免重複選</span></span><br><span class="line">            dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[capacity]</span><br></pre></td></tr></table></figure>


<h3 id="有限背包問題（Bounded-Knapsack-Problem）"><a href="#有限背包問題（Bounded-Knapsack-Problem）" class="headerlink" title="有限背包問題（Bounded Knapsack Problem）"></a>有限背包問題（Bounded Knapsack Problem）</h3><ul>
<li>每樣物品有固定數量，可能可以選擇大於 1 次</li>
<li>解法：將物品拆成多個 0&#x2F;1 物品，把問題轉化成 0&#x2F;1 背包問題來解</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bounded_knapsack</span>(<span class="params">weights, values, counts, capacity</span>):</span><br><span class="line">    expanded_weights = []</span><br><span class="line">    expanded_values = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weights)):</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(counts[i]):</span><br><span class="line">            expanded_weights.append(weights[i])</span><br><span class="line">            expanded_values.append(values[i])</span><br><span class="line">    <span class="keyword">return</span> knapsack_1d(expanded_weights, expanded_values, capacity)</span><br></pre></td></tr></table></figure>

<h3 id="無限背包問題（Unbounded-Knapsack-Problem）"><a href="#無限背包問題（Unbounded-Knapsack-Problem）" class="headerlink" title="無限背包問題（Unbounded Knapsack Problem）"></a>無限背包問題（Unbounded Knapsack Problem）</h3><ul>
<li>每樣物品可以選無限次</li>
<li>解法：動態規劃，不同於 0&#x2F;1 背包，內層迴圈需順序處理</li>
</ul>
<p>因為每種物品可以選無限次，我們就不必用倒序方法來避免重複選擇，直接在內層迴圈順序選取即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">unbounded_knapsack</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    dp = [<span class="number">0</span>] * (capacity + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(weights)):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(weights[i], capacity + <span class="number">1</span>):  <span class="comment"># 順序，允許重複選</span></span><br><span class="line">            dp[w] = <span class="built_in">max</span>(dp[w], dp[w - weights[i]] + values[i])</span><br><span class="line">    <span class="keyword">return</span> dp[capacity]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="換錢問題（Coin-Change-Problem）"><a href="#換錢問題（Coin-Change-Problem）" class="headerlink" title="換錢問題（Coin Change Problem）"></a>換錢問題（Coin Change Problem）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hackmd.io/_uploads/rkR7YYtfgg.png" alt="image"></p>
<p>換錢問題是一個經典的演算法問題，目的是在給定一組硬幣面額與一個目標金額的情況下，找出可以湊出該金額所需的最少硬幣數量。</p>
<p>這個問題常用於訓練動態規劃（Dynamic Programming）技巧，並在許多實際應用中具有重要意義，例如金融系統、自動販賣機與資源分配等。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://web.ntnu.edu.tw/~algo/KnapsackProblem.html">Knapsack Problem#Coin Problem - 演算法筆記</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@cutesciuridae/dynamic-programming-%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-%E4%BB%A5coin-change%E7%82%BA%E4%BE%8B-4a4f3e7d98ea">Dynamic programming 深入淺出 - 以 Coin change 為例</a></li>
</ul>
<p>利用這個問題，我們順便來複習一下動態規劃（Dynamic Programming）：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hackmd.io/_uploads/rJby5FtGex.png" alt="image"></p>
<p>以這個問題為例：</p>
<ol>
<li>定義狀態 [我在哪裡]<br>DP[n] &#x3D;找出n元最精簡的找零零錢數目(用最少數目的銅板湊出)</li>
<li>定義狀態轉移關係式(通則) [我從哪裡來] &#x3D;&gt; [答案從哪裡推導而來]<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://hackmd.io/_uploads/HkegB9YFfgl.png" alt="image"></li>
<li>釐清初始狀態(終止條件) [第一步怎麼走，怎麼出發的]<br>用每個銅板去縮小找零問題的規模，從n元找零問題一直化簡，降到0元的找<br>終止狀態：<br>0元的找零方法：0，代表不拿任何一枚銅板<br>&lt;0元的找零方法：不合法，應該停止計算，可用 float(‘inf’) 來處理</li>
</ol>
<h3 id="Leetcode-1"><a href="#Leetcode-1" class="headerlink" title="Leetcode"></a>Leetcode</h3><ul>
<li><a target="_blank" rel="noopener" href="https://leetcode.com/problems/coin-change/description/">322. Coin Change</a></li>
</ul>
<!-- - [518. Coin Change II](https://leetcode.com/problems/coin-change-ii/description/) -->

<!-- ## 旅行銷售員問題（TSP, Traveling Salesman Problem）
![image](https://hackmd.io/_uploads/Sk8U16sekl.png)  -->


<!-- # Progress check
## 講義
- TODO: 尋找更多主題
- TODO: Update to blog

## 學生
- 進階演算法： LC 42, 239 not finished, Kadane finish
--></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://jackchen890311.github.io">Jack Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章連結: </span><span class="post-copyright-info"><a href="https://jackchen890311.github.io/2025/06/10/dsa-tutorial-11/">https://jackchen890311.github.io/2025/06/10/dsa-tutorial-11/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版權聲明: </span><span class="post-copyright-info">本部落格所有文章除特別聲明外，均採用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 授權協議。轉載請註明來源 <a href="https://jackchen890311.github.io" target="_blank">Jack's Space</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Tutorial/">Tutorial</a><a class="post-meta__tags" href="/tags/Data-Structure/">Data Structure</a><a class="post-meta__tags" href="/tags/Algorithm/">Algorithm</a></div><div class="post-share"><div class="social-share" data-image="/img/cover/color_macbook.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/07/01/fulltime-2025/" title="2025 年科技業正職預聘/研替面試心得（TSMC, Google, NVIDIA, Synology, MediaTek, Perfect Corp., Appier)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/perfect_clean.png" onerror="onerror=null;src='/img/website/404_cool.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">2025 年科技業正職預聘/研替面試心得（TSMC, Google, NVIDIA, Synology, MediaTek, Perfect Corp., Appier)</div></div><div class="info-2"><div class="info-item-1">前言每年的面試分享文，似乎已經默默的成為我的某種習慣了（還沒看過我之前文章的，可以參考 2023 跟 2024 的分享）。但今年比較不同的是，我要碩士畢業了！因此本篇分享會從以往的實習轉成正職，職位的部分我大多都是找 ML 相關為主。 面試紀錄 投遞履歷：7 家公司 面試邀請：6 家公司 Offer Get：2 家公司  TSMC應徵職位：沒分，統一丟備註：有研替時程：  8&#x2F;30 EPO interview invitation 9&#x2F;12 EPO interview 10&#x2F;1 EPO Thank you 9&#x2F;16? 收到 IT 副理電話聊天詢問面試意願 9&#x2F;23? 沒收到後續，打電話回去問，他好像說他忘記，當天就收到面試邀請 10&#x2F;15 收到 IT 另一個處約時間，想約同天但卡到 10&#x2F;18 IT interview (AAPD) 10&#x2F;25 IT interview (MLAD) 11&#x2F;1 收到資歷查核 11&#x2F;5 資歷查核送出，有問是否需要廠測，對方說去年有紀錄不用 11&#x...</div></div></div></a><a class="pagination-related" href="/2025/06/10/dsa-tutorial-10/" title="資料結構與演算法教學系列文 (10) - 差分陣列、單調堆疊/佇列"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" onerror="onerror=null;src='/img/website/404_cool.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">資料結構與演算法教學系列文 (10) - 差分陣列、單調堆疊/佇列</div></div><div class="info-2"><div class="info-item-1">HackMD 完整版請點我 差分陣列（Difference Array） 差分陣列是一種快速處理區間更新的技巧，特別適用於頻繁對陣列特定區間進行加減的情境，其基於前綴和（Prefix Sum）的概念來輔助實現。 其核心概念是透過維護一個輔助陣列 diff，來記錄原陣列的數值變化，使得區間的加減可以在 O(1) 時間內完成，而最終結果則可透過前綴和的技巧來計算。 輔助陣列的建立輔助陣列 diff 的計算方法為：diff[0] &#x3D; nums[0]diff[i] &#x3D; nums[i] - nums[i-1] (i &gt; 0)   以上圖來看，原陣列 nums 是 [8, 2, 6, 3, 1]：diff[0] &#x3D; 8diff[1] &#x3D; nums[1] - nums[0] &#x3D; 8 - 2 &#x3D; -6diff[2] &#x3D; nums[2] - nums[1] &#x3D; 6 - 2 &#x3D; 4…diff &#x3D; [8, -6, 4, -3, -2] 有注意到嗎？每個 diff 記錄的是「這個位置與上個位置的差異...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相關推薦</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/06/10/dsa-tutorial-4/" title="資料結構與演算法教學系列文 (4) - 矩陣、堆積、優先佇列"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-10</div><div class="info-item-2">資料結構與演算法教學系列文 (4) - 矩陣、堆積、優先佇列</div></div><div class="info-2"><div class="info-item-1">HackMD 完整版請點我 矩陣（Matrix） 在介紹 Graph 的表示方法時，我們提到了兩種不同的表示方式，分別是鄰接串列（Adjacency List）與鄰接矩陣（Adjacency Matrix）。不過其實，矩陣本身也可以被當作一種資料結構來使用，舉凡像是迷宮、地圖等等具有 2D 性質的資料型態，都可以使用矩陣來表示。 Matrix 的相關操作其實都與 Graph 差不多，不外乎就是在 Matrix 中進行搜尋或遍歷，但因為我們可以以 $O(1)$ 的複雜度，直接取用 Matrix 內部中的任一元素（matrix[row][col]），所以 Matrix 在某些應用上具有較為快速的優勢。那接著就讓我們直接實戰演練吧！ Leetcode 200. Number of Islands 994. Rotting Oranges 1351. Count Negative Numbers in a Sorted Matrix  堆積（Heap）一種具有特殊性質（Parent Node 大於或小於 Child Node）的 Complete Binary Tree。 堆積排序法(H...</div></div></div></a><a class="pagination-related" href="/2025/06/10/dsa-tutorial-2/" title="資料結構與演算法教學系列文 (2) - 陣列、鏈結串列、堆疊、佇列"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-10</div><div class="info-item-2">資料結構與演算法教學系列文 (2) - 陣列、鏈結串列、堆疊、佇列</div></div><div class="info-2"><div class="info-item-1">HackMD 完整版請點我 資料結構（Data Structure）資料結構是一種設計、組織、儲存資料的方式，以實現最佳性能和效率。這些結構包含不同形式，像是陣列、鍊結列表、樹、圖等等。選擇適當的資料結構對於解決特定的問題至關重要，不同的資料結構可以用於不同的應用，並且可以極大地影響程序的運行時間和記憶體使用。 陣列（Array）可隨機存取的一串連續記憶體位址。  陣列 (Array) 簡介 補充：List Are Arrays in Python    Leetcode 26. Remove Duplicates from Sorted Array 27. Remove Element  鏈結串列（Linked List）元素間彼此串聯在一起，形成一條鍊子的資料結構。也可以是上圖雙向連結的形式。  Linked List：Intro(簡介) Linked List：新增資料、刪除資料、反轉  Leetcode 21. Merge Two Sorted Lists 24. Swap Nodes in Pairs 206. Reverse Linked List  堆疊（Stack...</div></div></div></a><a class="pagination-related" href="/2025/06/10/dsa-tutorial-1/" title="資料結構與演算法教學系列文 (1) - 概述、排序、搜尋、時間複雜度"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-10</div><div class="info-item-2">資料結構與演算法教學系列文 (1) - 概述、排序、搜尋、時間複雜度</div></div><div class="info-2"><div class="info-item-1">哈囉！久違又來更新教學文系列了，這次的主題是在學完基礎程式設計後，一定也需要會的東西：資料結構與演算法。若你對程式設計還不太熟悉，或是想回去複習一下 Python 或 C++，可以參考我下面的系列文：  Python 教學  C++ 教學  這個系列文應該會很長，因為 DSA（i.e. Data Structure and Algorithm）這個主題是在是涵蓋太多東西了，甚至我寫的內容也沒有到很完整。這次的來源一樣是拿來做家教講義，文字部分不會太詳盡，有需要更詳盡的內容歡迎聯絡我，如果我有空就可以幫你上課 XD。 最後就是轉載請記得標註來源，這裡面的內容都是作者本人收集的心血！ HackMD 完整版請點我  入門介紹 Google Coding Style 甚麼是演算法？ 甚麼是資料結構？  來複習一下學習地圖，以臺大資工系必修為例：以臺大資管系必修為例： 而在演算法與資料結構的世界裡面，大概又可以分為以下幾種類別。在我們之後的課程中，會逐漸的介紹每個名詞以及其對應概念： 相關連結：  How to master DSA labuladong 的算法筆記 演算法與資料結構  競...</div></div></div></a><a class="pagination-related" href="/2025/06/10/dsa-tutorial-7/" title="資料結構與演算法教學系列文 (7) - 分治法、動態規劃、前綴和"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-10</div><div class="info-item-2">資料結構與演算法教學系列文 (7) - 分治法、動態規劃、前綴和</div></div><div class="info-2"><div class="info-item-1">HackMD 完整版請點我 分治法（Divide-and-Conquer） Divide-and-Conquer又稱為分治法。其中 Divide 指的是將一個較大的問題不斷切割成小問題。而 Conquer 是當最後切割成的小問題簡單到可以直接解決，就可以組合成大問題的答案。在程式語言中時常都會用到分治法的觀念，並結合遞迴的概念求解。  Source: 分而治之法與遞迴關係  還記得之前教過的 Merge Sort 嗎？（合併排序法：將陣列不斷細分，再將細分後的結果兩兩合併。）其實 Merge Sort 的精神本質上就是 Divide-and-Conquer！  【舌尖上的演算法】Day15 – Divide and Conquer - Merge Sort  Leetcode  108. Convert Sorted Array to Binary Search Tree 148. Sort List  動態規劃（Dynamic Programming） Dynamic Programming &#x3D; Divide-and-Conquer + Memoization 動態規...</div></div></div></a><a class="pagination-related" href="/2025/06/10/dsa-tutorial-3/" title="資料結構與演算法教學系列文 (3) - 樹、圖"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-10</div><div class="info-item-2">資料結構與演算法教學系列文 (3) - 樹、圖</div></div><div class="info-2"><div class="info-item-1">HackMD 完整版請點我 樹（Tree）基本單位為 Node，且只有一個 Node 是 Root（無人指向的 Node），且不存在任何 Cycle。每個 Node 可以指向多個 Child。  Tree(樹): Intro(簡介)  二元樹（Binary Tree）當樹中的每個 Node 都只有兩個 Child，即為 Binary Tree。  Binary Tree: Intro(簡介) Binary Tree: Traversal(尋訪)  以上面的 Binary Tree 為例： Pre-Order Traversal: ABDECFG In-Order Traversal: DBEAFCG Post-Order Traversal: DEBFGCA   延伸閱讀：Binary Tree: 建立一棵Binary Tree      二元搜尋樹（Binary Search Tree）若一個二元樹中，所有 Node 都滿足 Node.left.value &lt; Node.value &lt; Node.right.value，就稱為二元搜尋樹。二元搜尋樹有良好的排序特質，...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 評論</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/me/ghent.jpg" onerror="this.onerror=null;this.src='/img/website/emoji.gif'" alt="avatar"/></div><div class="author-info-name">Jack Chen</div><div class="author-info-description">Hello there! I'm Jack Chen. This is the place where I share my thoughts and experiences.</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">標籤</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分類</div><div class="length-num">7</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://www.facebook.com/jack.chen.89311/" target="_blank" title="Facebook"><i class="fab fa-facebook"></i></a><a class="social-icon" href="https://www.instagram.com/jackchen_2000/" target="_blank" title="Instagram"><i class="fab fa-instagram"></i></a><a class="social-icon" href="https://www.linkedin.com/in/jack-chen-2000/" target="_blank" title="LinkedIn"><i class="fab fa-linkedin"></i></a><a class="social-icon" href="https://github.com/jackchen890311" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:jackchen20000311@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome! Feel free to explore and connect with me!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目錄</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B8%E5%88%97%E5%95%8F%E9%A1%8C-Maximum-Subarray-Problem"><span class="toc-number">1.</span> <span class="toc-text">最大子數列問題 (Maximum Subarray Problem)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kadane%E2%80%99s-Algorithm"><span class="toc-number">1.1.</span> <span class="toc-text">Kadane’s Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%B4%E5%8A%9B%E6%B3%95%EF%BC%9A%E9%81%8D%E6%AD%B7%E5%85%A8%E9%83%A8%E9%80%A3%E7%BA%8C%E5%AD%90%E9%99%A3%E5%88%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">暴力法：遍歷全部連續子陣列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%84%AA%E5%8C%96%E6%99%82%E9%96%93%EF%BC%9A%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83"><span class="toc-number">1.1.2.</span> <span class="toc-text">優化時間：動態規劃</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%84%AA%E5%8C%96%E7%A9%BA%E9%96%93%EF%BC%9AKadane%E2%80%99s-Algorithm"><span class="toc-number">1.1.3.</span> <span class="toc-text">優化空間：Kadane’s Algorithm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode"><span class="toc-number">1.2.</span> <span class="toc-text">Leetcode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C%EF%BC%88Knapsack-Problem%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">背包問題（Knapsack Problem）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%95%B8%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C%EF%BC%88Fractional-Knapsack-Problem%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">分數背包問題（Fractional Knapsack Problem）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C%EF%BC%880-1-Knapsack-Problem%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">0&#x2F;1 背包問題（0&#x2F;1 Knapsack Problem）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C%EF%BC%88Bounded-Knapsack-Problem%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">有限背包問題（Bounded Knapsack Problem）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%84%A1%E9%99%90%E8%83%8C%E5%8C%85%E5%95%8F%E9%A1%8C%EF%BC%88Unbounded-Knapsack-Problem%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">無限背包問題（Unbounded Knapsack Problem）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%9B%E9%8C%A2%E5%95%8F%E9%A1%8C%EF%BC%88Coin-Change-Problem%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">換錢問題（Coin Change Problem）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Leetcode-1"><span class="toc-number">3.1.</span> <span class="toc-text">Leetcode</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/01/fulltime-2025/" title="2025 年科技業正職預聘/研替面試心得（TSMC, Google, NVIDIA, Synology, MediaTek, Perfect Corp., Appier)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/perfect_clean.png" onerror="this.onerror=null;this.src='/img/website/404_cool.jpg'" alt="2025 年科技業正職預聘/研替面試心得（TSMC, Google, NVIDIA, Synology, MediaTek, Perfect Corp., Appier)"/></a><div class="content"><a class="title" href="/2025/07/01/fulltime-2025/" title="2025 年科技業正職預聘/研替面試心得（TSMC, Google, NVIDIA, Synology, MediaTek, Perfect Corp., Appier)">2025 年科技業正職預聘/研替面試心得（TSMC, Google, NVIDIA, Synology, MediaTek, Perfect Corp., Appier)</a><time datetime="2025-07-01T07:57:07.000Z" title="發表於 2025-07-01 15:57:07">2025-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/10/dsa-tutorial-11/" title="資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" onerror="this.onerror=null;this.src='/img/website/404_cool.jpg'" alt="資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題"/></a><div class="content"><a class="title" href="/2025/06/10/dsa-tutorial-11/" title="資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題">資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題</a><time datetime="2025-06-10T07:57:11.000Z" title="發表於 2025-06-10 15:57:11">2025-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/10/dsa-tutorial-10/" title="資料結構與演算法教學系列文 (10) - 差分陣列、單調堆疊/佇列"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" onerror="this.onerror=null;this.src='/img/website/404_cool.jpg'" alt="資料結構與演算法教學系列文 (10) - 差分陣列、單調堆疊/佇列"/></a><div class="content"><a class="title" href="/2025/06/10/dsa-tutorial-10/" title="資料結構與演算法教學系列文 (10) - 差分陣列、單調堆疊/佇列">資料結構與演算法教學系列文 (10) - 差分陣列、單調堆疊/佇列</a><time datetime="2025-06-10T07:57:10.000Z" title="發表於 2025-06-10 15:57:10">2025-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/10/dsa-tutorial-9/" title="資料結構與演算法教學系列文 (9) - 圖的進階議題"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" onerror="this.onerror=null;this.src='/img/website/404_cool.jpg'" alt="資料結構與演算法教學系列文 (9) - 圖的進階議題"/></a><div class="content"><a class="title" href="/2025/06/10/dsa-tutorial-9/" title="資料結構與演算法教學系列文 (9) - 圖的進階議題">資料結構與演算法教學系列文 (9) - 圖的進階議題</a><time datetime="2025-06-10T07:57:09.000Z" title="發表於 2025-06-10 15:57:09">2025-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/10/dsa-tutorial-8/" title="資料結構與演算法教學系列文 (8) 字串比對、位元運算、雙重指標"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/color_macbook.jpg" onerror="this.onerror=null;this.src='/img/website/404_cool.jpg'" alt="資料結構與演算法教學系列文 (8) 字串比對、位元運算、雙重指標"/></a><div class="content"><a class="title" href="/2025/06/10/dsa-tutorial-8/" title="資料結構與演算法教學系列文 (8) 字串比對、位元運算、雙重指標">資料結構與演算法教學系列文 (8) 字串比對、位元運算、雙重指標</a><time datetime="2025-06-10T07:57:08.000Z" title="發表於 2025-06-10 15:57:08">2025-06-10</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By Jack Chen</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="閱讀模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日夜模式切換"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="單欄和雙欄切換"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="設定"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目錄"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往評論"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到頂端"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'

  const disqusReset = conf => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: conf
    })
  }

  const loadDisqus = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyDisqus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    window.disqus_identifier = isShuoshuo ? path : '/2025/06/10/dsa-tutorial-11/'
    window.disqus_url = isShuoshuo ? location.origin + path : 'https://jackchen890311.github.io/2025/06/10/dsa-tutorial-11/'

    const disqus_config = function () {
      this.page.url = disqus_url
      this.page.identifier = disqus_identifier
      this.page.title = '資料結構與演算法教學系列文 (11) - 最大子數列問題、背包問題、換錢問題'
    }

    if (window.DISQUS) disqusReset(disqus_config)
    else {
      const script = document.createElement('script')
      script.src = 'https://jackchen890311.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }

    btf.addGlobalFn('themeChange', () => disqusReset(disqus_config), 'disqus')
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=jackchen890311&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if (isShuoshuo) {
    'Disqus' === 'Disqus'
      ? window.shuoshuoComment = { loadComment: loadDisqus }
      : window.loadOtherComment = loadDisqus
    return
  }

  if ('Disqus' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>